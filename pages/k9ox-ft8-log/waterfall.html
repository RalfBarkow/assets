<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.14.2/d3.js"></script>
  </head>
  <body style="font-family:sans-serif;">
    <style>
      .grid {color:#ccc;}
    </style>
    <table cellpadding=30><tr>
      <td>
        We simulate in 2d a visualization we intend to produce in 3d table-top augmented reality.<br>
        Signals from multiple radios are plotted by frequency and time and layered vertically.<br>
        Portland blue, Medford green, previously contacted stations show as brown.<br>
        Viewpoints sequence through six positions including looking straight down.
      <td id="output">
    </table>
    <div id="scene"></div>
    <script>


// P A R A M S
  
      function hashed(hash, assign) {
        op=assign.split(/=/)
        if (op[1]) hash[op[0]]=op[1]
        return hash
      }

      let query = window.location.href.split(/\?/)[1]||''
      let args = query.split(/&/)
      let params = args.reduce(hashed,{})
      let log = params.log || 'http://found.ward.bay.wiki.org/assets/pages/k9ox-ft8-log/wsjtx_log.adi'
      let copy = params.copy || 'http://ward.asia.wiki.org/plugin/wsjt/copy'
      // also offset, width & height below


// D A T A

      logged = {}
      decodes = []
      done = {}

      fetch(log)
        .then(res=>res.text())
        .then(text=>rawlog(text.split(/\r?\n/)))

      fetch(copy)
        .then(res=>res.text())
        .then(text=>rawcopy(text.split(/\r?\n/)))

      // http://ward.asia.wiki.org/plugin/wsjt/copy?last=500


      function rawlog(lines) {
        for (let line of lines) {
          if (!line.match(/^</)) continue 
          let field = /<(\w+):\d+>([^<]*)/g
          let r = {}
          while (m = field.exec(line)) {
            r[m[1]] = m[2].trim()
          }

          // r.qso_date
          // r.time_on
          // r.call
          // r.gridsquare
          // r.rst_sent
          // r.rst_rcvd

          logged[r.call] = true
        }
        console.log('logged', logged)
        done['rawlog'] = true
        if (done['rawcopy']) report()
      }

      function rawcopy(lines) {
        let today = Date.now()-Date.now()%86400000
        for (let line of lines) {
          if (!line.length) continue
          let fields = line.split(' ')
          // if (fields[0] != '73.157.190.193') continue
          addr = fields[0]
          slot = fields[1]
          time = new Date(today+sec(slot)*1000)
          freq = 1*fields[2]
          elev = 200
          if(addr=='75.139.193.15') {
            freq += 1*(params.offset||0)
            elev -= 100
          }
          // if (time/15%2 != 0) continue
          call = fields[fields.length-2]
          decodes.push({addr,slot,time,freq,elev,call})
        }
        console.log('decodes',decodes)
        offsetter()
        done['rawcopy'] = true
        if (done['rawlog']) report()
      }

      let prev = null
      function sec(slot) {
        let m = slot.match(/(..)(..)(..)/)
        let now = 3600*m[1]+60*m[2]+1*m[3]
        if (prev && now < prev) {
          now += 24*60*60
        }
        return prev = now
      }


// C A L I B R A T I O N

      function offsetter () {
        matches = {}
        for (let d of decodes) {
          let slots = matches[d.slot] = matches[d.slot] || {}
          let calls = slots[d.call] = slots[d.call] || {count:0}
          calls.count += 1
          calls[d.addr=='73.157.190.193' ? 'me' : 'him'] = d.freq
        }
        let sum = n = 0
        for (let k of Object.keys(matches).sort()) {
          let slots = matches[k]
          for (let j of Object.keys(slots).sort()) {
            let call = slots[j]
            if (call.count == 2 && call.him && call.me) {
              sum += (call.me - call.him)
              n++
            }
          }
        }
        let stats = [`${decodes.length} decodes`]
        if (n!=0) {
          stats.push(`${n} callsign matches`)
          stats.push(`${Math.floor(sum/n)} Hz additional offset`)
        }
        output.innerHTML = stats.join("<br>")
      }


// R E P O R T

      function report() {

        var margin = {top: 30, right: 30, bottom: 30, left: 60},
            width = (params.width||1200) - margin.left - margin.right,
            height = (params.height||6000) - margin.top - margin.bottom;

        var svg = d3.select("#scene")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // https://stackoverflow.com/questions/35953892/d3-scale-linear-vs-d3-scalelinear
        // https://stackoverflow.com/questions/46510876/what-is-the-alternative-of-orient-in-the-new-d3-api

        // Add X axis
        var x = d3.scaleLinear()
          .domain([0, 3500])
          .range([ 0, width ]);
        svg.append("g")
          .call(d3.axisTop(x));
        svg.append("g")
          .attr("class", "grid")
          .call(d3.axisTop(x)
            .tickSize(-height)
            .tickFormat("")
          )

        // Add Y axis
        var y = d3.scaleTime()
          .domain([decodes[0].time, decodes[decodes.length-1].time])
          .range([ height, 0]);
        svg.append("g")
          .call(d3.axisLeft(y));
        svg.append("g")
          .attr("class", "grid")
          .call(d3.axisLeft(y)
            .ticks(40)
            .tickSize(-width)
            .tickFormat("")
          )

        function color(d) {
          if(d.addr != '73.157.190.193')
            return "#8f8"
          else if(logged[d.call])
            return "#f80"
          else
            return "#08f"
        }

        let xw = x(1050)-x(1000)
        let yh = y(decodes[0].time)-y(new Date(decodes[0].time.getTime()+15000))

        let waterfall = svg.append('g')
          .selectAll("decode")
          .data(decodes)
          .enter()
          .append("rect")
            .attr("x", function (d) { return x(d.freq); } )
            .attr("y", function (d) { return y(d.time); } )
            .attr("width", xw)
            .attr("height", yh)
            .style("fill", color)
            .style("fill-opacity", 0.5)


// A N I M A T E

        let pos = [
          {x:-10,y:0}, {x:-10,y:10}, {x:0,y:10}, {x:10,y:10}, {x:10,y:0}, {x:0,y:0}, {x:0,y:0},
          {x:10,y:0}, {x:10,y:10}, {x:0,y:10}, {x:-10,y:10}, {x:-10,y:0}, {x:0,y:0}, {x:0,y:0}]
        let t = 0
        let interval = null

        waterfall
          .on("mouseover", over)
          .on("mouseout", out)

        // readout = svg.append("g")
        //   .append("text")
        //     .attr("x",100)
        //     .attr("y",100)
        //     .text("Hello World")

        function out(d) {
          interval = setInterval(animate,1500);
        }

        function over(d) {
          clearInterval(interval)
          // readout.select("text")
          //   .attr("x", d.x)
          //   .attr("y", d.y)
          //   .text(d.call)
          output.innerHTML = `
            ${d.call}<br>
            ${d.freq} Hz<br>
            ${d.addr}
        }

        function animate() {
          let p = pos[t++%pos.length]
          waterfall.transition().duration(1500)
            .attr("x", function (d) { return x(d.freq) + d.elev*p.x/100; } )
            .attr("y", function (d) { return y(d.time) + d.elev*p.y/100; } )
        }

        return
      }


    </script>
  </body>
</html>      