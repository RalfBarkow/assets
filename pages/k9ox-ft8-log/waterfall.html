<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.14.2/d3.js"></script>
  </head>
  <body style="font-family:sans-serif;">
    <p>
      We simulate in 2d a visualization we intend to produce in 3d table-top augmented reality.<br>
      Signals from multiple radios are plotted by frequency and time and layered vertically.<br>
      The viewpoint sequences through six positions including looking straight down.
    </p>
    <div id="scene"></div>
    <script>


// P A R A M S
  
      function hashed(hash, assign) {
        op=assign.split(/=/)
        if (op[1]) hash[op[0]]=op[1]
        return hash
      }

      let query = window.location.href.split(/\?/)[1]||''
      let args = query.split(/&/)
      let params = args.reduce(hashed,{})
      let log = params.log || 'http://found.ward.bay.wiki.org/assets/pages/k9ox-ft8-log/wsjtx_log.adi'
      let copy = params.copy || 'http://ward.asia.wiki.org/plugin/wsjt/copy'
      // also offset, width & height below


// D A T A

      logged = {}
      decodes = []
      done = {}

      fetch(log)
        .then(res=>res.text())
        .then(text=>rawlog(text.split(/\r?\n/)))

      fetch(copy)
        .then(res=>res.text())
        .then(text=>rawcopy(text.split(/\r?\n/)))

      // http://ward.asia.wiki.org/plugin/wsjt/copy?last=500


      function rawlog(lines) {
        for (let line of lines) {
          if (!line.match(/^</)) continue 
          let field = /<(\w+):\d+>([^<]*)/g
          let r = {}
          while (m = field.exec(line)) {
            r[m[1]] = m[2].trim()
          }

          // r.qso_date
          // r.time_on
          // r.call
          // r.gridsquare
          // r.rst_sent
          // r.rst_rcvd

          logged[r.call] = true
        }
        console.log('logged', logged)
        done['rawlog'] = true
        if (done['rawcopy']) report()
      }

      function rawcopy(lines) {
        let today = Date.now()-Date.now()%86400000
        for (let line of lines) {
          if (!line.length) continue
          let fields = line.split(' ')
          // if (fields[0] != '73.157.190.193') continue
          addr = fields[0]
          slot = fields[1]
          time = new Date(today+sec(slot)*1000)
          freq = 1*fields[2]
          elev = 200
          if(addr=='75.139.193.15') {
            freq += 1*(params.offset||0)
            elev -= 100
          }
          // if (time/15%2 != 0) continue
          call = fields[fields.length-2]
          decodes.push({addr,slot,time,freq,elev,call})
        }
        console.log('decodes',decodes)
        done['rawcopy'] = true
        if (done['rawlog']) report()
      }

      function sec(slot) {
        m = slot.match(/(..)(..)(..)/)
        return 3600*m[1]+60*m[2]+1*m[3]
      }


// R E P O R T

      function report() {
        // set the dimensions and margins of the graph
        var margin = {top: 30, right: 30, bottom: 30, left: 60},
            width = (params.width||1200) - margin.left - margin.right,
            height = (params.height||6000) - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#scene")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");

        // Add X axis
        // https://stackoverflow.com/questions/35953892/d3-scale-linear-vs-d3-scalelinear
        // https://stackoverflow.com/questions/46510876/what-is-the-alternative-of-orient-in-the-new-d3-api
        var x = d3.scaleLinear()
          .domain([0, 3500])
          .range([ 0, width ]);
        svg.append("g")
          .call(d3.axisTop(x));

        // Add Y axis
        var y = d3.scaleTime()
          .domain([decodes[0].time, decodes[decodes.length-1].time])
          .range([ height, 0]);
        svg.append("g")
          .call(d3.axisLeft(y));

        // function make_y_gridlines() {   
        //   let d = y.domain()
        //   let t = d[1]-d[0]
        //   let n = t/60
        //   return d3.axisLeft(y)
        //     .ticks(n)
        // }

        // // add the Y gridlines
        // svg.append("g")     
        //   .attr("class", "grid")
        //   .call(make_y_gridlines()
        //     .tickSize(-width)
        //     .tickFormat("")
        //   )        

        function color(d) {
          if(d.addr != '73.157.190.193')
            return "#888"
          else if(logged[d.call])
            return "#f80"
          else
            return "#08f"
        }

        let xw = x(1050)-x(1000)
        let yh = y(decodes[0].time)-y(new Date(decodes[0].time.getTime()+15000))

        let waterfall = svg.append('g')
          .selectAll("dot")
          .data(decodes)
          .enter()
          .append("rect")
            .attr("x", function (d) { return x(d.freq); } )
            .attr("y", function (d) { return y(d.time); } )
            .attr("width", xw)
            .attr("height", yh)
            .style("fill", color)
            .style("fill-opacity", 0.5)


// A N I M A T E

        let pos = [
          {x:-10,y:0}, {x:-10,y:10}, {x:0,y:10}, {x:10,y:10}, {x:10,y:0}, {x:0,y:0},
          {x:10,y:0}, {x:10,y:10}, {x:0,y:10}, {x:-10,y:10}, {x:-10,y:0}, {x:0,y:0}]
        let t = 0

        setInterval(animate,1500);

        function animate() {
          let p = pos[t++%pos.length]
          waterfall.transition().duration(1500)
            .attr("x", function (d) { return x(d.freq) + d.elev*p.x/100; } )
            .attr("y", function (d) { return y(d.time) + d.elev*p.y/100; } )
        }

        return
      }


    </script>
  </body>
</html>      