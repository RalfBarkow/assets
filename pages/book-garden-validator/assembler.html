<p>Print Assembler Under Construction</p>
<p>
  <button onclick=dorefresh(event)>refresh</button> after editing book pages<br>
  <button onclick=dopreview(event)>preview</button> for last minute summary<br>
  <button onclick=doprint(event)>print</button> to print assembly as html
</p>
<div id=report></div>
<style>
  button {width:80px;}
</style>
<script type=module>
  import * as frame from 'http://code.fed.wiki/assets/v1/frame.js'
  import * as index from 'http://code.fed.wiki/assets/v1/index.js'
  import {prolog, render} from './render.js'
  const uniq = (value, index, self) => self.indexOf(value) === index
  const report = msg => window.report.innerHTML += msg + "<br>"
  
  let domain = `book.reimage.fed.wiki`
  let site
  let stories


  // B U T T O N S

  window.dorefresh  = async event => {
    window.report.innerText = ''
    report(`refreshed at ${new Date().toLocaleTimeString()}`)
    site = await index.site(domain)
    report(`${site.sitemap.length} pages in book sitemap`)
    const context = await frame.context()
    stories = index.links(index.folds(context.page.story).stories)
    report(`${stories.length} stories linked from here`)
  }

  dorefresh(null)

  window.dopreview = async event => {
    const preview = [{type:'paragraph',text:`Assembled elements for html print. Here we stop short of reading the actual pages.`}]
    const title = 'Book Assembly Preview'
    const html = []
    await assemble(feature => html.push(`
      <details>
        <summary>${summary(feature)}</summary>
        ${details(feature)}
      </details>
    `))
    preview.push({type:'html',text:html.join("\n")})
    frame.open({title,story:preview},event.shiftKey)

    function summary(feature) {
      const html = `${feature.type} ${feature.title ? `[[${feature.title}]]` : ''}`
      return feature.type=='slug' ? `<font color=brown>${html}</font>` : html
    }

    function details(feature) {
      return feature.html || feature.synopsis || 'unavailable at this time'
    }

  }

  window.doprint = async event => {
    const html = [prolog]
    await assemble(feature => html.push(feature.html || `<pre>${JSON.stringify(feature,null,2)}</pre>`))
    frame.download(html.join("\n"),'book-assembly.html','text/html')
  }


  // A S S E M B L E R S

  async function assemble(emit) {
    const works = await getworks()
    emit({type:'preface',synopsis:'Preface will go here.'})
    emit({type:'index',html:`<h3>Index</h3><ul>${index()}</ul>`})
    works.forEach(work => {
      const html = render(domain,work.page).join("\n")
      emit({type:'work', title:work.author, html})
      work.titles.forEach(title => {
        const info = site.info(title)
        const type = info ? 'story' : 'slug'
        emit({type, title, synopsis:info?.synopsis || 'not available'})
      })
    })

    function index () {
      return [...stories,'Garden']
        .map(title => `<li> ${title}`)
        .join("\n")
    }
  }


  // A G G R E G A T I O N S

  async function getworks() {
    const pages = await Promise.all(stories.map(title => site.page(title)))
    return pages.map(page => ({
      page,
      author:page.title,
      titles:page.story
        .filter(item => item.type=='reference')
        .map(item => item.title)
    }))
  }


</script>