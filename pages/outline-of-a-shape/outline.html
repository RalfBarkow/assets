
<html>

    <!--

         Outline of a Shape

         The implementation draws the outline of a shape by following a trajectory
         and computing the minimum distance between each pixel and the trajectory.
         The resulting distances are used as arguments to a filtering pen function,
         which returns the opacity values used to
         paint the pixels in the destination buffer.
         The algorithm uses floating-point arithmetic
         and alpha-blends the shape color over the destination buffer. -- ChatGPT

    -->

<head>
  <meta charset="UTF-8">
</head>

<body style="background-color:white;">
  <div id="chart" onclick=doopen(event)></div>
  <div id="output">waiting</div>

  <script>

   let outline = {}
   let history = {}
   let drawing = false

   // from apl, https://aplwiki.com/wiki/Index_Generator
   // in js, https://stackoverflow.com/questions/3746725/how-to-create-an-array-containing-1-n
   const iota = n => [...new Array(n).keys()]


   // S I M U L A T I O N

   const delay = time => new Promise(res => setTimeout(res,time));
   const norm = mean => mean*(Math.random() + Math.random());

   // replace generateGrid generateGrid by drawOutline
   const drawOutline = (destination, trajectory, penOuterDiameter, filteringPen) => {
       const width = destination.width;
       const height = destination.height;
       const distanceBuffer = [];
       for (let i = 0; i < width * height; i++) {
           distanceBuffer[i] = Number.POSITIVE_INFINITY;
       }

       for (let i = 0; i < trajectory.length - 1; i++) {
           const start = trajectory[i];
           const end = trajectory[i + 1];
           const step = (end - start) / 4;
           let current = start;
           while (current <= end) {
               const x = Math.round(current.x);
               const y = Math.round(current.y);
               const r = penOuterDiameter / 2;
               for (let i = Math.max(0, x - r); i <= Math.min(width - 1, x + r); i++) {
                   for (let j = Math.max(0, y - r); j <= Math.min(height - 1, y + r); j++) {
                       const distance = Math.sqrt((i - x) ** 2 + (j - y) ** 2);
                       if (distance < distanceBuffer[i + j * width]) {
                           distanceBuffer[i + j * width] = distance;
                       }
                   }
               }
               current = current.add(step);
           }
           for (let i = 0; i < width * height; i++) {
               const x = i % width;
               const y = Math.floor(i / width);
               const opacity = filteringPen(distanceBuffer[i]);
               const index = (x + y * width) * 4;
               destination.data[index + 3] = opacity * 255;
           }
       }
   }

       stream();

       async function stream () {
       while (true) {
           outline = drawOutline(destination, trajectory, penOuterDiameter, filteringPen);
           history = Date.now();
           refresh();
           await delay(norm(1200));
       };
   };


   // V I S U A L I Z A T I O N

   function refresh() {
       let text = JSON.stringify({grid, history}).replace(/"/g,'').replace(/},/g,"},\n")
       output.innerHTML = `<pre>${text}</pre>`
       chart.innerHTML = `
           <svg version="1.1" width="300" height="300" xmlns="http://www.w3.org/2000/svg">
               ${svg()}
           </svg>
       `
   }

   function svg() {
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started
        // return `
        //    <rect width="100%" height="100%" fill="red" />
        //    <circle cx="150" cy="100" r="80" fill="green" />
        //    <text x="150" y="125" font-size="60" text-anchor="middle" fill="white">SVG</text>
        // `

        const scale = 300/15
        const colors = ['silver','gray','maroon','red','purple','fuchsia','green','lime','olive','yellow','navy','blue','teal','aqua']
        const svg = []
        for (const {pos} of grid) {
            const color = colors[Math.floor(Math.random()*colors.length)]
            svg.push(`<circle info="${pos}"
                cx="${pos[0]*scale}" cy="${pos[1]*scale}"
                r="8" fill="${color}" />`)
        }
        return svg.join("\n")
   }

   function doopen(event) {
        const info = event.target.getAttribute('info')
        const color = event.target.getAttribute('fill')
        if(!info || !color) return
        console.log({info,color})
        const title = `${color?.toUpperCase()} Item Clicked`
        const story = [
            {type:'paragraph',text:`Click arrived at ${new Date().toLocaleTimeString()}`},
            {type:'code',text:`pos: [${info}]`}
        ]
        open({title,story},event.shiftKey)
   }

   // http://code.fed.wiki/frame-integration-promises.html
   function open(page, keepLineup=false, forks=[]) {
      const asCopy = obj => JSON.parse(JSON.stringify(obj))
      let date = Date.now()
      for (let item of page.story) item.id ||= (Math.random()*10**20).toFixed(0)
      page.journal ||= [{type:'create', date, item:asCopy(page)}, ...forks.map(site => ({type:'fork',date,site}))]
      let message = {action: "showResult", page, keepLineup}
      window.parent.postMessage(message, "*")
    }


  </script>
</body>
</html>
