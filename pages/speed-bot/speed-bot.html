<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speed Bot</title>
    <style>
        /* Define grid layout */
        body {
            display: grid;
            grid-template-columns: 1fr; /* Initially, one column taking up all available space */
            grid-template-rows: auto; /* Auto-sized rows */
            grid-gap: 10px; /* Gap between grid cells */
        }

        /* Style individual elements */
        .paragraph-select-wrapper {
            margin-bottom: 10px;
        }

        /* Additional styling for other elements as needed */
    </style>
</head>

<body>
    <p>
        <label for="indexEntries">Page:</label><select id="indexEntries"></select> 
        <button id="startButton" onclick=dostart(event) type="submit">start</button>
        <span id=startat></span>
        <br>
        <div class="paragraph-select-wrapper">
            <label for="paragraphEntries">Paragraph:</label>
            <select id="paragraphEntries"></select>
        </div>
    </p>
    <pre id="result"></pre>
    <script type="module">

        // Import necessary modules and classes
        //import { Graph } from 'https://wardcunningham.github.io/graph/graph.js';
        import { Graph } from './src/graph/graph.js';
        import { visit, getfrom, sitemaps } from '../story-telling/telling.js';
        //import { open, context } from 'http://code.fed.wiki/assets/v1/frame.js';
        import { open, context } from './src/frame.js';

        // Define a module for the application
        const SpeedBotApp = (() => {
            // Private variables and functions
            let graph;
            let all;
            let reference;
            let pick;
            let seen = new Set(); // Initialize seen as an empty set
            let dot;
            let hue;
            let color;
            let nodeShape;
            let done;

            // Initialize the application
            async function init() {
                graph = new Graph();
                nodeShape = "ellipse"; // Use ellipse for the first title node, box for others
                color = {};
                dot = [];
                hue = 0.5001;
                done = Date.now() + 10000;

                all = [await getfrom('a', ['wiki.ralfbarkow.ch'])]
                reference = (await context()).page.story.find(item => item.type == 'reference')
                if (reference) {
                    all = [await getfrom(reference.slug, [reference.site])]
                }

                window.startat.innerText = all[0].page.title;
            }

            function setStartEntry() {
                const select = document.getElementById('indexEntries');
                const selectedEntry = select.value;
                console.log('Selected Entry:', selectedEntry);

                // Find the selected entry in the `seen` Set
                for (let entry of seen) {
                    if (entry === selectedEntry) {
                        // Update the start entry and display it
                        window.startat.innerText = entry;
                        console.log('Start Entry:', entry);
                        enableStartButton();
                        return entry;
                    }
                }
            }

            function populateIndexEntries(seen) {
                let indexEntries = seen
                let select = document.getElementById('indexEntries')

                // Clear existing options
                select.innerHTML = '';

                indexEntries.forEach(entry => {
                    let option = document.createElement('option')
                    option.text = entry
                    select.add(option)
                })
            }

            // Private function to add page title to graphviz
            function addPageTitleToGraphviz(pick) {
                console.log("addPageTitleToGraphviz reached")

                let title = pick.page.title
                let site = pick.site
                let sites = pick.sites
                const hsv = hue => `"${(hue % 1).toFixed(3)} 0.2 1.0"`
                color[site] ||= hsv(hue += 0.111)

                dot.push(addTitleDot(title, site, sites, color));
                /*
                   Ward is introducing page titles to Graphviz.
                   This is where he associates a color
                   to be used where ever he mentions that title.
                 */
            }

            function nodeTitleIndex(title) {
                console.log("nodeIndex reached");

                // Check if the node already exists in the graph
                const nodeId = graph.nodes.findIndex(node => node.type === title);
                console.log(`nodeTitleIndex: "${title}" (${nodeId})`);
                return nodeId;
            }

            function quote(title) {
                // const quote = title => `"${title.replace(/ +/g,'\\n')}"`
                return `"${title.replace(/ +/g, '\\n')}"`;
                /*
                   See http://gd.fed.wiki/view/dump-a-structure-into-graphviz
                 */
            }

            function addTitleDot(title, site, sites, color) {
                let nodeShape_ = nodeShape;

                const nodeProperties = {
                    tooltip: `${site}\n\n${sites.join("\n")}`,
                    fillcolor: color[site],
                    shape: `${nodeShape_}`
                };

                addTitle(title, nodeProperties);

                // Modify nodeShape for subsequent nodes
                nodeShape = "box";

                // Construct the DOT node string with the extracted color
                return `${quote(title)} [ tooltip="${site}\n\n${sites.join("\n")}" fillcolor=${color[site]} shape=${nodeShape_}]`;
            }

            function joinTitlesDot(pick, next) {
                joinTitles(pick, next);
                return `${quote(pick.page.title)} -> ${quote(next.page.title)}`
                /*
                   See http://gd.fed.wiki/view/dump-a-structure-into-graphviz
                 */
            }

            function joinTitles(pick, next) {
                console.log("joinTitles reached");

                const fromIndex = graph.nodes.findIndex(node => node.type === pick.page.title);
                const toIndex = addTitle(next.page.title, {}); // Add next page title if it doesn't exist and get its index
                if (toIndex !== -1) {
                    graph.addRel('fromPickToNext', fromIndex, toIndex, {});
                    console.log(`fromPickToNext: Relation added from "${pick.page.title}" (${fromIndex}) -> to "${next.page.title}" (${toIndex})`);
                    serializeGraphAsJSONL(graph);
                }
            }

            function filterParagraphs(page) {
                console.log("filterParagraphs reached")

                let paragraphs = page.story.filter(item => item.type === 'paragraph');
                populateParagraphEntries(paragraphs, page.title)
                return paragraphs;
            }

            function addNode(node, nodeProperties){
              console.log("addNode reached");

              // Add the node to the graph
                const newNodeId = graph.addNode(node, 0, 0, nodeProperties);
                console.log(`Node "${node}" (${newNodeId}) added`);
                serializeGraphAsJSONL(graph);
                return newNodeId;
            }

            function addTitle(title, nodeProperties) {
                console.log("addTitle reached");

                // Check if the node already exists
                const foundNodeTitleId = nodeTitleIndex(title);

                if (foundNodeTitleId !== -1) {
                    console.log(`Node with title "${title}" (${foundNodeTitleId}) already exists`);
                    return foundNodeTitleId;
                }

                // Add the node to the graph
                const newNodeId = addNode(title, nodeProperties);

                return newNodeId;
            }

            function relIndex(id, pageId) {
                console.log("relIndex reached");

                // Check if the rel already exists in the graph
                const relId = graph.rels.findIndex(rel => rel.type === 'fromParaToPage' && rel.from === id && rel.to === pageId);
                return relId;
            }

            function nodeParaIndex(id){
                console.log("nodeParaIndex reached");

                const nodeId = graph.nodes.findIndex(node => node.type === id);
                console.log(`nodeParaIndex: nodeId ${nodeId}`);
                return nodeId;
            }

            function populateParagraphEntries(paragraphs, title) {
                console.log("populateParagraphEntries reached");

                let select = document.getElementById('paragraphEntries');

                // Clear existing options
                select.innerHTML = '';

                // Get the id of a node named title
                const pageId = nodeTitleIndex(title);

                paragraphs.forEach(paragraph => {

                    // Check the id of the paragraph node
                    const foundParaNodeId = nodeParaIndex(paragraph.id);

                    // Check if the relation exists
                    const foundRelId = relIndex(foundParaNodeId, pageId);
                    console.log(`foundRelId: ${foundRelId} (for paragraph ${paragraph.id})`);
                    if (foundRelId !== -1) {
                        // Relation already exists
                        console.log(`fromParaToPage: Relation (${foundRelId}) between paragraph ${paragraph.id} and title "${title}" (${pageId}) already exists.`);
                    } else {

                        // Relation does not exist, so add it
                        const paraId =
                            graph.addNode(paragraph.id, { text: paragraph.text });
                        graph.addRel('fromParaToPage', paraId, pageId, paragraph.id, title, {});
                        console.log(`fromParaToPage: Relation between paragraph ${paragraph.id} (${paraId}) and title "${title}" (${pageId}) added to the graph.`);

                        broadcastParagraph(paragraph)
                        serializeGraphAsJSONL(graph)
                    }

                    // Create an option for the paragraph entry in the dropdown list
                    let optgroup = document.createElement('optgroup');
                    optgroup.label = paragraph.id;

                    let option = document.createElement('option')
                    option.value = paragraph.id;
                    option.text = paragraph.text

                    //select.add(option)
                    optgroup.appendChild(option);
                    select.appendChild(optgroup);
                })
            }

            window.doview = function (event) {
                let [site, title] = event.target.innerText.split(' — ')
                window.parent.postMessage({
                    action: "doInternalLink",
                    title,
                    site,
                    keepLineup: event.shiftKey
                }, "*")
            }

            async function handleParagraphs(paragraphs, pick, remain) {
                for (let paragraph of paragraphs) {
                    let links = new Set(visit(pick.page).filter(title => !seen.has(title))); // Convert to Set to eliminate duplicates

                    if (!all.length) break; // Check if there are remaining pages to explore

                    links = Array.from(links); // Convert back to array if needed

                    if (links.length) {
                        let link = any(links);
                        seen.add(link);
                        populateIndexEntries(seen);
                        let next = await getfrom(asSlug(link), pick.sites);

                        if (next && next.page) {
                            addPageTitleToGraphviz(next);
                            dot.push(joinTitlesDot(pick, next));
                            all.push(next);
                            window.result.innerHTML += `${remain} <span onclick=doview(event)>${next.site} — ${link}</span>\n`;
                            pick = next;
                        } else {
                            window.result.innerHTML += `  <span style="color:gray;">fail ${link}</span>\n`;
                        }
                    } else {
                        all = all.filter(place => !(place.site == pick.site && place.page.title == pick.page.title));
                        window.result.innerHTML += `  <span style="color:gray;">done ${pick.page.title}</span>\n`;
                        pick = any(all); // Randomly select a page from the remaining pages
                    }
                }
            }

            window.dostart = async function(event) {
                done = Date.now() + 10000;
                // Clear the result area
                window.result.innerHTML = '';
                
                nodeShape = "ellipse"; // Use ellipse for the first title node, box for others

                // Check if a start entry is selected
                const selectedStartEntry = document.getElementById('indexEntries').value;
                if (selectedStartEntry) {
                    // Set the start entry based on the selected entry
                    pick = all.find(entry => entry.page.title === selectedStartEntry);
                } else {
                    // Find the default start entry based on the seen set
                    pick = all.find(entry => seen.has(entry.page.title)) || all[0];
                }

                if (pick) {
                    addPageTitleToGraphviz(pick);
                    console.log('Start: pick.page', pick.page);

                    try {
                        while (Date.now() < done) {
                            let remain = Math.ceil((done - Date.now()) / 1000);
                            let paragraphs = filterParagraphs(pick.page);
                            await handleParagraphs(paragraphs, pick, remain);
                        }
                    } catch (err) {
                        window.result.innerHTML += `${err.message}\n${err.stack}`;
                    }
                    displayResultSummary();
                } else {
                    console.log("End of the journey reached");

                    // Deactivate the Start Button
                    document.getElementById('startButton').disabled = true;

                    // Display an error message in the UI
                    const errorMessage = 'Select another Page: entry to continue';
                    window.result.innerHTML += `${errorMessage}\n`;
                }
            };

            function enableStartButton() {
                const startButton = document.getElementById('startButton');
                if (startButton) {
                    startButton.removeAttribute('disabled');
                }
            }


            function displayResultSummary(event) {
                window.result.innerHTML += "\n\n" + Object.entries(sitemaps).map(([site, infos]) => `${infos.length} — ${site}`).join("\n");
                const dotText = `digraph {\nnode [shape=box style=filled fillcolor=white]\n${dot.join("\n")}\n}`;
                const story = [
                    { type: 'paragraph', text: `Random journey rooted from ${reference.title} and proceeding for ${all.length} pages travelling through ${Object.keys(color).length} sites.` },
                    { type: 'graphviz', text: dotText }
                ];
                openSpeedBotJourneyGhostPage(story, event && event.shiftKey); // Check if event is defined before accessing shiftKey
            }

            function any(array) {
                // const any = list => list[Math.floor(Math.random()*list.length)]
                return array[Math.floor(Math.random() * array.length)];
            }

            function asSlug(title) {
                // const asSlug = (title) => title.replace(/\s/g, '-').replace(/[^A-Za-z0-9-]/g, '').toLowerCase()
                return title.replace(/\s/g, '-').replace(/[^A-Za-z0-9-]/g, '').toLowerCase();
            }

            function openSpeedBotJourneyGhostPage(story, shiftKey) {
                console.log("openSpeedBotJourneyGhostPage reached")

                open({ title: "Speed Bot Journey", story }, shiftKey, Object.keys(color));
            }

            // Serialize the entire Graph object as one JSON line in a JSONL stream
            function serializeGraphAsJSONL(graph) {
                console.log("serializeGraphAsJSONL reached");

                broadcastGraph(JSON.stringify(graph) + '\n'); // outgoing broadcast
            }

            function broadcastGraph(jsonl) {
                console.log("broadcastGraph reached");

                const targetOrigin = "*" // "*" indicates that the message can be received from any origin

                // Post a message to the parent window
                window.parent.postMessage(
                    // message
                    // See https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
                    {
                        action: "publishSourceData",
                        name: "graph", // graphStream
                        sourceData: { jsonl }
                    },
                    targetOrigin // optional
                );
                graphStream(jsonl); // outgoing broadcast
            }

            function broadcastParagraph(paragraph) {
                console.log("broadcastParagraph reached")

                const targetOrigin = "*" // "*" indicates that the message can be received from any origin

                // Post a message to the parent window
                window.parent.postMessage(
                    // message
                    // See https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
                    {
                        action: "publishSourceData",
                        name: "paragraph", // paragraphStream
                        sourceData: { paragraph }
                    },
                    targetOrigin // optional
                );
            }

            function graphStreamIncoming(message){ // message.graph
                console.log("graphStreamIncoming reached");

                return Graph.load(message);
            }

            // Compare the incoming broadcast of a graph with the outgoing broadcast
            async function graphStream(jsonl) {
                console.log("graphStream reached");

                const json = JSON.parse(jsonl.trim());

                const outgoingGraph = new Graph(json.nodes, json.rels);
                console.log("outgoingGraph: ", outgoingGraph);

                const incomingGraph = await graphStreamIncoming(outgoingGraph);
                console.log("incomingGraph: ", incomingGraph);
            }

            // Add event listener for message
            window.addEventListener('message', function (event) {
                console.log('Message event received:', event);

                const message = event.data;

                // Handle message event here
                if (message.action === 'graphStream') {
                    graphStream(message.jsonl);
                }
            });

            // Public method to start the application
            function start() {
                init();

                // Attach setStartEntry function to the change event of the select element
                document.getElementById('indexEntries').addEventListener('change', setStartEntry);
                document.getElementById('paragraphEntries').addEventListener('change', setStartEntry);
            }

            // Public API
            return {
                start
            };
        })();

        // Initialize and start the application
        SpeedBotApp.start();

    </script>
</body>

</html>
