<html>
<head>
  <meta charset="UTF-8">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚗️</text></svg>">
  <script src="https://unpkg.com/@hpcc-js/wasm/dist/index.min.js"></script>
  <script> var hpccWasm = window["@hpcc-js/wasm"]; </script>
</head>
<body>
<table>
  <tr style="height:30%">
    <td style="width:25%">
      <div id=beam onclick=dochoose(event)>Work in Progress</div></td>
    <td style="width:75%" rowspan=3>
      <div id=target ondrop="drop(event)" ondragover="over(event)" ondragenter="over(event)">System for Action</div>
  </tr><tr>
    <td>
      <div id=create></div>
  </tr><tr>
    <td>
      <div id="chat">
        <div id="textOut"></div>
        <input id="textIn" type="text" onkeydown="event.keyCode == 13 && sendButton.onclick()"/>
        <input id="sendButton" type="button" value = "Send" />
      </div>
    </td>
  </tr>

</table>

<style>
  table {height:100%; width:100%; border-collapse:collapse;}
  td, th {border:1px solid gray; padding:8px;}
  div {height: 100%; background-color:white;}
</style>

<script src="https://unpkg.com/@croquet/croquet"></script>
<script type=module>

  import {Graph} from 'https://wardcunningham.github.io/graph/graph.js'
  import {drop} from './drop.js'
  import {composite} from './composite.js'
  import {dotify} from './dotify.js'
  import {create} from './create.js'

  const names = ['beauty','diagram','gamma','instantiation','life','modeler','morning','thing']
  const graphs = await Promise.all(names
    .map(n => Graph.fetch(`http://ward.dojo.fed.wiki/assets/pages/daily-haiku-graph/${n}.graph.json`)))
  window.beam.innerHTML = `${names.map((n,i) => `<input type=checkbox value=${i}>${n}`).join("<br>")}`
  const created = {name:'empty', graph:new Graph()}
  create(window.create, graph => {
    Object.assign(created, {name:graph.nodes[0]?.props?.name||'void', graph});
    refresh()
  })

  window.over = function (event) {
    event.preventDefault()
  }

  window.drop = async function (event) {
    event.preventDefault();
    const concepts = await drop(event)
    display(concepts)
  }

  window.dochoose = refresh

  function refresh() {
    const checked = [...window.beam.querySelectorAll('input[type=checkbox]:checked')]
    const chosen = checked.map(e => ({name:names[e.value], graph:graphs[e.value]}))
    display([...chosen,created])
  }

  function display(chosen) {
    const complex = composite(chosen)
    hpccWasm.graphviz.layout(dotify(complex), "svg", "dot").then(svg => {
      target.innerHTML = svg;
    })
  }


  class BeamModel extends Croquet.Model {

    init() {
      this.views = new Map();
      this.participants = 0;
      this.history = []; // { viewId, html } items
      this.lastPostTime = null;
      this.inactivity_timeout_ms = 60 * 1000 * 20; // constant
      this.subscribe(this.sessionId, "view-join", this.viewJoin);
      this.subscribe(this.sessionId, "view-exit", this.viewExit);
      this.subscribe("input", "newPost", this.newPost);
      this.subscribe("input", "reset", this.resetHistory);
    }

    viewJoin(viewId) {
      const existing = this.views.get(viewId);
      if (!existing) {
        const nickname = this.randomName();
        this.views.set(viewId, nickname);
      }
      this.participants++;
      this.publish("viewInfo", "refresh");
    }

    viewExit(viewId) {
      this.participants--;
      this.views.delete(viewId);
      this.publish("viewInfo", "refresh");
    }

    newPost(post) {
      const postingView = post.viewId;
      const nickname = this.views.get(postingView);
      const chatLine = `<b>${nickname}:</b> ${this.escape(post.text)}`;
      this.addToHistory({ viewId: postingView, html: chatLine });
      this.lastPostTime = this.now();
      this.future(this.inactivity_timeout_ms).resetIfInactive();
    }

    addToHistory(item){
      this.history.push(item);
      if (this.history.length > 100) this.history.shift();
      this.publish("history", "refresh");
    }

    resetIfInactive() {
      if (this.lastPostTime !== this.now() - this.inactivity_timeout_ms) return;

      this.resetHistory("due to inactivity");
    }

    resetHistory(reason) {
      this.history = [{ html: `<i>chat reset ${reason}</i>` }];
      this.lastPostTime = null;
      this.publish("history", "refresh");
    }

    escape(text) { // Clean up text to remove html formatting characters
      return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");
    }

    randomName() {
      return (Math.random()*1000000).toFixed(0)
    }

  }

  BeamModel.register("BeamModel");

  class BeamView extends Croquet.View {

    constructor(model) {
      super(model);
      this.model = model;
      sendButton.onclick = () => this.send();
      this.subscribe("history", "refresh", this.refreshHistory);
      this.subscribe("viewInfo", "refresh", this.refreshViewInfo);
      this.refreshHistory();
      this.refreshViewInfo();
      if (model.participants === 1 &&
        !model.history.find(item => item.viewId === this.viewId)) {
        this.publish("input", "reset", "for new participants");
      }
    }

    send() {
      const text = textIn.value;
      textIn.value = "";
      if (text === "/reset") {
        this.publish("input", "reset", "at user request");
      } else {
        this.publish("input", "newPost", {viewId: this.viewId, text});
      }
    }

    refreshViewInfo() {
      console.log({
        name:this.model.views.get(this.viewId),
        users:this.model.participants
      })
    }

    refreshHistory() {
      textOut.innerHTML = "Super Collaborator Connected<br><br>" +
        this.model.history.map(item => item.html).join("<br>");
      textOut.scrollTop = Math.max(10000, textOut.scrollHeight);
    }
  }

  Croquet.Session.join({
    apiKey: '1MNinyGopbyxFzgx3HupBoCAryFb6yNOIihx6Omx9',
    appId: 'com.gmail.ward.cunningham.collaborator',
    name: "unnamed",
    password: "secret",
    model: BeamModel,
    view: BeamView
  })



</script>
</body>
</html>
