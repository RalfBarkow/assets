"use strict";
(globalThis["webpackChunk_croquet_microverse"] = globalThis["webpackChunk_croquet_microverse"] || []).push([["src_card_js"],{

/***/ "./src/DynamicTexture.js":
/*!*******************************!*\
  !*** ./src/DynamicTexture.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DynamicTexture": () => (/* binding */ DynamicTexture)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-three */ "./node_modules/@croquet/worldcore-three/index.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io

// DynamicTexture is used to define and interact with an offscreen canvas that updates a texture object. In particular,
// it is used as the text editing object.
// Despite its name, it isn't a TObject.


class DynamicTexture{
  //'initialize',{
    // width and height are in pixels, to be used to create the canvas
    // width, height, options.fillStyle, options.clearStyle
    constructor(width, height, fillStyle, clearStyle){
        if (width>2048 || height>2048) console.warn("large texture: "+width+"x"+height); // @@ DEBUG
        var nearestPowerOfTwo = value=>2**(Math.round( Math.log( value ) / Math.LN2 ) );

        var twoWidth = nearestPowerOfTwo(width), twoHeight = nearestPowerOfTwo(height);
        var needsAdjustment = twoWidth!==width || twoHeight!==height; // || (canvas && (twoWidth!==canvas.width || twoHeight!==canvas.height));
        if (needsAdjustment) console.log("TDynamicTexture: " + width + "x" + height + " becomes " + twoWidth + "x" + twoHeight);

        this.canvas = document.createElement("canvas");
        this.canvas.width = this.width = twoWidth;
        this.canvas.height = this.height = twoHeight;

        this.context = this.canvas.getContext("2d");
        this.texture = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_0__.THREE.CanvasTexture(this.canvas);
        this.extractMipmapLevel = 3;

        this.fontName = 'Arial';
        this.fontHeight = 32;
        this.fillStyle = fillStyle || 'black';
        this.clearStyle = clearStyle;
        this.setFont("normal 32px Arial"); // default
        this.align = 'left';
        this.scale = 1;
    }

//  'interface',{
    asMaterial(){
        return new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_0__.THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 1,
            emissive: 0x333333,
            map: this.texture,
            transparent: false,
        });
    }

    getTexture(){return this.texture}

    getMiniTexture(){
        if (this.miniTexture) return this.miniTexture;

        let texture = this.texture;
        let level = this.extractMipmapLevel, multiple = 2**level;
        let miniWidth = this.width/multiple, miniHeight = this.height/multiple;

        let renderer = this.service("ThreeRenderManager").renderer,
            gl = renderer.getContext(),
            glTexture = gl.createTexture();

        // following https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
        const loadLevel = 0;
        const internalFormat = gl.RGBA;
        const srcFormat = gl.RGBA;
        const srcType = gl.UNSIGNED_BYTE;

        gl.bindTexture(gl.TEXTURE_2D, glTexture);

        let utils = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLUtils(gl);
        // these lines from uploadTexture() in three.js; we might need more (e.g., anisotropy)
        gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
        gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
        gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

        // note: we might be able to do this more efficiently; see discussion of texStorage2D
        // in "Creating a complete texture" in https://www.khronos.org/opengl/wiki/Common_Mistakes
        gl.texImage2D(gl.TEXTURE_2D, loadLevel, internalFormat, srcFormat, srcType, this.canvas);
        gl.generateMipmap(gl.TEXTURE_2D);

        // Create a framebuffer backed by the desired level of the texture
        let framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        // NB: following (with non-zero level parameter) requires webgl2
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, level);
        let data;
        let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER), ok = status===gl.FRAMEBUFFER_COMPLETE;
        if (ok) {
            // Read the contents of the framebuffer
            data = new Uint8Array(miniWidth * miniHeight * 4);
            gl.readPixels(0, 0, miniWidth, miniHeight, gl.RGBA, gl.UNSIGNED_BYTE, data);
        } else console.log("frame buffer not ready; status="+status);
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(glTexture);
        if (!ok) return null; // better luck next time

        // Create a mini canvas to store the result
        let miniCanvas = document.createElement("canvas"), context = miniCanvas.getContext("2d");
        miniCanvas.width = miniWidth;
        miniCanvas.height = miniHeight;

        // Copy the pixels to the mini canvas
        let imageData = context.createImageData(miniWidth, miniHeight);
        imageData.data.set(data);
        context.putImageData(imageData, 0, 0);

        this.miniTexture = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_0__.THREE.CanvasTexture(miniCanvas);
        this.miniTexture.flipY = false;
        return this.miniTexture;
    }

    discardMiniTexture() { delete this.miniTexture; }

    // parsing the font spec seems to be pretty heavy - so if we're using the same font
    // many times, we don't want to keep re-assigning this.context.font.
    // however... because the context's font setting is lost during a restore(), for example
    // as used to remove the clip() setting after drawing a cell region of a TDataTable texture,
    // in such cases we'll only end up skipping repeated font setting if the texture's default
    // font (set as this.font) is also the font used for the cells.
    setFont(font){ this.context.font = this.font = this.lastContextFont = font; }
    // called internally, so we can skip the setting if it's the same as last time
    setContextFont(font) {
        if (font!==this.lastContextFont) this.context.font = this.lastContextFont = font;
    }

    setFillStyle(fillStyle){this.fillStyle = fillStyle;}

    setAlign(align){this.align = align;}

    doWithClip(x, y, width, height, fn){
        let context = this.context;
        context.save();
        context.beginPath();
        context.rect(x,y,width,height);
        context.clip();

        fn();

        context.restore();
        this.lastContextFont = this.font; // @@ assume (somewhat riskily) that we're returning to the base state
    }

    fill(fillStyle){
        this.context.save();
        this.context.scale(1/this.scale, 1/this.scale);
        this.fillRect(0, 0, this.canvas.width, this.canvas.height, fillStyle);
        this.context.restore();
    }

    clear(){
        this.context.save();
        this.context.scale(1/this.scale, 1/this.scale);
        this.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.texture.needsUpdate = true;
        this.context.restore();
    }

    fillRect(x, y, width, height, fillStyle){
        this.context.fillStyle = fillStyle || this.fillStyle;
        this.context.fillRect(x, y, width, height);
        this.texture.needsUpdate = true;
    }

    clearRect(x, y, width, height){
        if( this.clearStyle !== undefined ){
            this.context.fillStyle = this.clearStyle;
            this.context.fillRect(x, y, width, height);
        }else{
            this.context.clearRect(x, y, width, height);
        }
        this.texture.needsUpdate = true;
    }

    drawImage(...args){
        // execute the drawImage on the internal context
        // the arguments are the same the official context2d.drawImage so we just pass it through
        this.context.drawImage(...args);
        this.texture.needsUpdate = true;
    }

    drawText(text, x, y, fillStyle, contextFont, suppressShadow){
        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        if(!isNumber(x)) return this.drawTextCentered(text, y, fillStyle, contextFont, suppressShadow);
        this.setContextFont(contextFont||this.font);
        let context = this.context;
        context.textAlign = this.align;

        // draw a black version to sharpen the text's outline
        // ael: add suppressShadow argument to allow caller to disable this
        if (!suppressShadow) {
            context.fillStyle = 'black';
            context.fillText(text, x+1, y+1);
        }
        context.fillStyle = fillStyle||this.fillStyle;
        context.fillText(text, x, y);
        this.texture.needsUpdate = true;
    }

    drawTextCentered(text, y, fillStyle, contextFont, suppressShadow){
        this.setContextFont(contextFont||this.font);
        var w = this.context.measureText(text).width;
        var h = this.fontHeight;
        var x = (this.canvas.width-w)/2;
        if (typeof y!=="number") y = (this.canvas.height+h)/2 -2;
        if (!suppressShadow) {
            this.context.fillStyle = 'black';
            this.context.fillText(text, x+1, y+1);
        }
        this.context.fillStyle = fillStyle||this.fillStyle;
        this.context.fillText(text, x, y);
        this.texture.needsUpdate = true;
    }

    drawTextRight(text, y, fillStyle, contextFont, suppressShadow){
        this.setContextFont(contextFont||this.font);
        var w = this.context.measureText(text).width+2;
        var h = this.fontHeight;
        var x = this.canvas.width-w;
        if (typeof y!=="number") y = (this.canvas.height+h)/2 -2;
        if (!suppressShadow) {
            this.context.fillStyle = 'black';
            this.context.fillText(text, x+1, y+1);
        }
        this.context.fillStyle = fillStyle||this.fillStyle;
        this.context.fillText(text, x, y);
        this.texture.needsUpdate = true;
    }

    drawTextLeft(text, y, fillStyle, contextFont){
        this.setContextFont(contextFont||this.font);
        //var w = this.context.measureText(text).width+2;
        var h = this.fontHeight;
        var x = 2, y = y || (this.canvas.height+h)/2 -2;
        this.context.fillStyle = 'black';
        this.context.fillText(text, x+1, y+1);
        this.context.fillStyle = fillStyle||this.fillStyle;
        this.context.fillText(text, x, y);
        this.texture.needsUpdate = true;
    }

    drawRect(x, y, width, height, style, lineWidth){
        // Green rectangle
        this.context.beginPath();
        this.context.lineWidth=lineWidth||"4";
        this.context.strokeStyle= style||"green";
        this.context.rect(x,y,width,height);
        this.context.stroke();
        this.texture.needsUpdate = true;
    }

    drawLine(fromX,fromY, toX,toY, style, lineWidth){
        this.context.lineWidth=lineWidth||"1";
        this.context.strokeStyle= style||"white";
        this.context.beginPath();
        this.context.moveTo(fromX,fromY);
        this.context.lineTo(toX,toY);
        this.context.stroke();
        this.texture.needsUpdate = true;
    }

    // poly is an array with x,y,x,y,x,y,.. format
    drawPoly(poly, style, lineWidth){
        this.context.lineWidth=lineWidth||"1";
        this.context.strokeStyle= style||"white";
        this.context.beginPath();
        this.context.moveTo(poly[0], poly[1]);
        for(let i=2; i<poly.length; i+=2){
            this.context.lineTo(poly[i], poly[i+1]);
        }
        this.context.stroke();
        this.texture.needsUpdate = true;
    }

    // path is a Path2D object (SVG path)
    // let path = new Path2D('M 100,100 h 50 v 50 h 50');
    // dynamic.drawPath(path);
    drawPath( path ){
        this.context.stroke(path);
        this.texture.needsUpdate = true;
    }

    // image is an HTMLImageElement
    // let img = new Image();
    // img.src = "./assets/svg/CroquetSymbol_CMYK_NoShadow.svg";
    // dynamic.drawImage(10,10, img);
    drawImage(  image, x, y, width, height ){
        this.context.drawImage( image, x, y, width, height );
        this.texture.needsUpdate = true;
    }

    changed(){this.texture.needsUpdate = true; this.mipmapTexture.dispose(); this.mipmapTexture = null;}

    setScale(scale){this.scale = scale; this.context.scale(scale, scale);}
}


/***/ }),

/***/ "./src/Pointer.js":
/*!************************!*\
  !*** ./src/Pointer.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AM_PointerTarget": () => (/* binding */ AM_PointerTarget),
/* harmony export */   "PM_Pointer": () => (/* binding */ PM_Pointer),
/* harmony export */   "PM_PointerTarget": () => (/* binding */ PM_PointerTarget)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io



//------------------------------------------------------------------------------------------
//-- AM_PointerTarget ----------------------------------------------------------------------
//------------------------------------------------------------------------------------------

// Copied from the implementaion in Worldcore, but heavily modified to support event listener style dynamic manipulation of event listeners.

// eventListeners:Map<eventName:EventName, Array<{moduleName:string, behaviorName:string, eventName:string, listener:string}>>

const AM_PointerTarget = superclass => class extends superclass {
    init(options) {
        super.init(options);
        this.eventListeners = new Map();
        this.listen("dispatchEvent", this.dispatchEvent);
    }

    // When an actor-side event listener for a pointer event is added,
    // the pawn automatically sends the pointer event over the
    // dispatchEvent Croquet event.  If the lister registered has
    // moduleName and behaviorName, it invokes the behavior method.
    // Otherwise, it looks up the method from the base object and
    // invokes it.
    dispatchEvent(data) {
        // console.log("dispatchEvent", data);
        let {eventName, evt} = data;
        let array = this.eventListeners.get(eventName);
        if (!array) {return;}

        array.forEach((obj) => {
            let {moduleName, behaviorName, listener} = obj;
            if (moduleName && behaviorName) {
                this.call(`${moduleName}$${behaviorName}`, listener, evt);
            } else {
                this[listener](evt);
            }
        });
    }

    addEventListener(eventName, listener) {
        // console.log("addEventListener", eventName, listener);
        let origListener = listener;
        if (typeof listener === "function") {
            listener = listener.name;
        }

        let behaviorName;
        let moduleName;

        let dollar = listener.indexOf("$");

        if (dollar >= 1) {
            moduleName = listener.slice(0, dollar);
            listener = listener.slice(dollar + 1);
        }

        let dot = listener.indexOf(".");
        if (dot >= 1) {
            behaviorName = listener.slice(0, dot);
            listener = listener.slice(dot + 1);
        }

        let behavior = this._behavior;

        if (!moduleName && behavior) {
            moduleName = behavior.module.externalName;
        }

        if (!behaviorName && behavior) {
            behaviorName = behavior.$behaviorName;
        }

        let array = this.eventListeners.get(eventName);
        if (!array) {
            array = [];
            this.eventListeners.set(eventName, array);
        }
        if (array.findIndex((obj) => {
            return obj.eventName === eventName &&
                obj.listener === listener &&
                obj.moduleName === moduleName &&
                obj.behaviorName === behaviorName
        }) >= 0) {
            this.removeEventListener(eventName, origListener, true);
            // console.log("multiple registration of the same function");
        }
        array.push({moduleName, behaviorName, eventName, listener});

        this.say("registerEventListener", {eventName, listener});
    }

    removeEventListener(eventName, listener, noDelete) {
        // console.log("removeEventListener", eventName, listener);
        if (typeof listener === "function") {
            listener = listener.name;
        }

        /*

        if (listener.indexOf(".") >= 1) {
            let split = listener.split(".");
            behavior = split[0];
            listener = split[1];
        }

        */

        let behaviorName = this._behavior.$behaviorName;
        let moduleName = this._behavior.module.externalName;

        let array = this.eventListeners.get(eventName);
        if (!array) {
            // console.log("try to remove non-existent listener");
            return;
        }
        let ind = array.findIndex((obj) => obj.behaviorName === behaviorName && obj.moduleName === moduleName && obj.listener === listener);
        if (ind < 0) {
            // console.log("try to remove non-existent listener");
            return;
        }
        array.splice(ind, 1);
        if (array.length === 0) {
            if (!noDelete) {
                this.eventListeners.delete(eventName);
            }
            this.say("unregisterEventListener", {eventName, listener});
        }
    }
}
;(0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.RegisterMixin)(AM_PointerTarget);

//------------------------------------------------------------------------------------------
//-- PM_PointerTarget ----------------------------------------------------------------------
//------------------------------------------------------------------------------------------

// Copied from the implementaion in Worldcore, but heavily modified to support event listener style dynamic manipulation of event listeners.

// eventListeners:Map<eventName:EventName, Array<{name:string, eventName:string, listener:function}>>
// This manages the event listeners added to the pawn side.

// modelListeners:Map<eventName:EventName, func:function
// When an event listener for a pointer event is added to the actor side, the pawn was notified so that it should send a dispatchEvent when the specified pointerEvent type occurs on the pawn side.

const PM_PointerTarget = superclass => class extends superclass {
    constructor(actor) {
        super(actor);
        this.eventListeners = new Map();
        this.modelListeners = new Map();

        this.listen("registerEventListener", "registerEventListener");
        this.listen("unregisterEventListener", "unregisterEventListener");

        // if (this.onKeyDown) this.listen("keyDown", this.onKeyDown);
        // if (this.onKeyUp) this.listen("keyUp", this.onKeyUp);

        this.registerAllEventListeners();
    }

    destroy() {
        let avatar = this.actor.service("PlayerManager").players.get(this.viewId);
        const avatarPawn = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.GetPawn)(avatar.id);
        if (avatarPawn) {
            if (avatarPawn.hoverPawn === this) {
                avatarPawn.hoverPawn = null;
            }
            if (avatarPawn.focusPawn === this) {
                avatarPawn.focusPawn = null;
            }
        }
        super.destroy();
    }

    addEventListener(eventName, listener, name) {
        let origListener = listener;
        if (typeof listener === "string") {
            name = listener;
            listener = (evt) => this[name](evt);
        } else {
            if (!name) {
                name = listener.name;
            }
        }
        let array = this.eventListeners.get(eventName);
        if (!array) {
            array = [];
            this.eventListeners.set(eventName, array);
        }
        if (array.find((obj) => {
            return obj.name === name &&
                obj.eventName === eventName;
        })) {
            this.removeEventListener(eventName, origListener, name);
            // console.log("multiple registration of the same function");
        }
        array.push({name, eventName, listener});
    }

    removeEventListener(eventName, listener, name) {
        if (typeof listener === "string") {
            name = listener;
            // listener = (evt) => this[listener](evt);
        } else {
            if (!name) {
                name = listener.name;
            }
        }
        let array = this.eventListeners.get(eventName);
        if (!array) {
            // console.log("try to remove non-existent listener");
            return;
        }
        let ind = array.findIndex((obj) => {
            return obj.name === name &&
                obj.eventName === eventName;
        });
        if (ind < 0) {
            // console.log("try to remove non-existent listener");
            return;
        }
        array.splice(ind, 1);
    }

    registerEventListener(data) {
        // console.log("registerEventLIstener", data);
        let {eventName} = data;
        let func = (evt) => this.say("dispatchEvent", {eventName, evt});
        this.modelListeners.set(eventName, func);
        this.addEventListener(eventName, func, `dispatch_${eventName}`);
    }

    unregisterEventListener(data) {
        let {eventName, _listener} = data;
        let func = this.modelListeners.get(eventName);
        if (!func) {return;}
        this.removeEventListener(eventName, func, `dispatch_${eventName}`);
    }

    // this is called only upon the initialization time. If the actor
    // already has some entries in the eventListeners, the pawn sets
    // up the disptchEvent link for them.

    registerAllEventListeners() {
        if (!this.actor.eventListeners) {return;}
        for (let eventName of this.actor.eventListeners.keys()) {
            this.registerEventListener({eventName});
        }
    }
}

//------------------------------------------------------------------------------------------
//-- PM_Pointer ----------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

// Copied from the implementaion in Worldcore, but heavily modified to support event listener style dynamic manipulation of event listeners.

// This mixin is used by the avatar to implement the event routing.

const PM_Pointer = superclass => class extends superclass {
    constructor(actor) {
        super(actor);
        if (!this.isMyPlayerPawn) {return;}

        /* Microverse uses InputManager from Worldcore */

        this.subscribe("input", "pointerDown", this.doPointerDown);
        this.subscribe("input", "pointerUp", this.doPointerUp);
        this.subscribe("input", "pointerMove", this.doPointerMove);
        this.subscribe("input", "click", this.doPointerClick);
        this.subscribe("input", "wheel", this.doPointerWheel);
        this.subscribe("input", "doubleDown", this.doPointerDoubleDown);
        this.subscribe("input", "tap", this.doPointerTap);
        this.subscribe("input", "keyDown", this.doKeyDown);
        this.subscribe("input", "keyUp", this.doKeyUp);

        this.firstResponders = new Map();
        this.lastResponders = new Map();
        // {eventType -> [{eventMask, pawn}]} // eventMask should be exclusive
    }

    modifierEqual(e1, e2) {
        return !!e1.altKey === !!e2.altKey && !!e1.ctrlKey === !!e2.ctrlKey && !!e1.metaKey === !!e2.metaKey && !!e1.shiftKey === !!e2.shiftKey;
    }

    addResponder(responders, eventType, eventMask, pawn) {
        if (pawn._target) {pawn = pawn._target;}
        let ms = ["altKey", "shiftKey", "ctrlKey", "metaKey"];
        let array = responders.get(eventType);
        if (!array) {
            array = [];
            responders.set(eventType, array);
        }

        function has() {
            for (let i = 0; i < array.length; i++) {
                let obj = array[i];
                let all = true;

                for (let i = 0; i < ms.length; i++) {
                    all = all && obj.eventMask[ms[i]] === eventMask[ms[i]]
                }
                if (obj.pawn === pawn && all) {return true;}
            }
            return false;
        }

        if (has()) {return;}

        array.forEach((obj) => {
            for (let i = 0; i < ms.length; i++) {
                if (obj.eventMask[ms[i]] && eventMask[ms[i]]) {
                    throw new Error(`${ms[i]} is already handled for ${eventType}`);
                }
            }
        });
        array.unshift({eventMask, pawn});
    }

    removeResponder(responders, eventType, eventMask, pawn) {
        if (pawn._target) {pawn = pawn._target;}
        let array = responders.get(eventType);
        if (!array) {return;}
        let responderIndex = array.findIndex((obj) => {
            let ms = ["altKey", "shiftKey", "ctrlKey", "metaKey"];
            let all = true;
            for (let i = 0; i < ms.length; i++) {
                if (obj.eventMask[ms[i]]) {
                    all = all && eventMask[ms[i]];
                }
            }
            return all;
        });

        if (responderIndex >= 0 && array[responderIndex].pawn === pawn) {
            array.splice(responderIndex, 1);
        }
    }

    findResponder(responders, e, eventType, requireModefier) {
        let array = responders.get(eventType);
        if (!array) {return null;}
        let responderIndex = array.findIndex((obj) => {
            let ms = ["altKey", "shiftKey", "ctrlKey", "metaKey"];
            let all = true;
            let any = false;
            for (let i = 0; i < ms.length; i++) {
                if (e[ms[i]]) {
                    any = true;
                    all = all && obj.eventMask[ms[i]];
                }
            }

            if (requireModefier && (Object.keys(obj.eventMask).length === 0 && !any)) {
                return true;
            }
            if (requireModefier && !any) {return false;}
            return all;
        });

        if (responderIndex >= 0) {
            return array[responderIndex].pawn;
        }
        return null;
    }

    addFirstResponder(eventType, eventMask, pawn) {
        return this.addResponder(this.firstResponders, eventType, eventMask, pawn);
    }

    removeFirstResponder(eventType, eventMask, pawn) {
        return this.removeResponder(this.firstResponders, eventType, eventMask, pawn);
    }

    findFirstResponder(e, eventType) {
        return this.findResponder(this.firstResponders, e, eventType, true);
    }

    addLastResponder(eventType, eventMask, pawn) {
        return this.addResponder(this.lastResponders, eventType, eventMask, pawn);
    }

    removeLastResponder(eventType, eventMask, pawn) {
        return this.removeResponder(this.lastResponders, eventType, eventMask, pawn);
    }

    findLastResponder(e, eventType) {
        return this.findResponder(this.lastResponders, e, eventType, false);
    }

    destroy() {
        super.destroy();
    }

    getTargets(type, optWalk) {
        const render = this.service("ThreeRenderManager");
        let objects = optWalk ? render.threeLayerUnion('pointer', 'walk') : render.threeLayer("pointer");
        return objects.filter((obj) => {
            let array = obj.wcPawn.eventListeners.get(type);
            return array && array.length !== 0;
        });
    }

    invokeListeners(type, target, rc, wcEvent) {
        let array = target.eventListeners.get(type);
        let event;
        if (!rc) {
            event = wcEvent;
        } else {
            event = this.pointerEvent(rc, wcEvent);
        }
        if (array) {
            array.forEach((n) => n.listener.call(target, event));
        }
    }

    pointerCapture(toPawn) {
        this.focusPawn = toPawn;
    }

    doPointerDown(e) {
        let eventType = "pointerDown";
        const rc = this.pointerRaycast(e.xy, this.getTargets(eventType));

        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, rc, e);
        }

        if (e.button === 0) {
            this.isPointerDown = true;
            if (this.focusPawn !== rc.pawn) {
                this.focusPawn = rc.pawn;
            }
        }
        if (this.focusPawn) {
            this.invokeListeners(eventType, this.focusPawn, rc, e);
        } else {
            let lastResponder = this.findLastResponder(e, eventType);
            if (lastResponder) {
                return this.invokeListeners(eventType, lastResponder, rc, e);
            }
        }
    }

    doPointerUp(e) {
        let eventType = "pointerUp";
        const rc = this.pointerRaycast(e.xy, this.getTargets(eventType));

        this.isPointerDown = false;
        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, rc, e);
        }

        if (this.focusPawn) {
            this.invokeListeners(eventType, this.focusPawn, rc, e);
        }

        // this is dubious but we clear the editPawn anyway.
        let lastResponder = this.findLastResponder(e, eventType);
        if (lastResponder) {
            return this.invokeListeners(eventType, lastResponder, rc, e);
        }
        // this.focusPawn = null;
    }

    doPointerMove(e) {
        let eventType = "pointerMove";
        const rc = this.pointerRaycast(e.xy, this.getTargets(eventType));

        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, rc, e);
        }

        if (this.hoverPawn !== rc.pawn) {
            if (this.hoverPawn) {
                this.invokeListeners("pointerLeave", this.hoverPawn, rc, e);
            }
            this.hoverPawn = rc.pawn;
            if (this.hoverPawn) {
                this.invokeListeners("pointerEnter", this.hoverPawn, rc, e);
            }
        }

        if (this.isPointerDown && this.focusPawn && this.focusPawn === rc.pawn) { // dubious check
            this.invokeListeners(eventType, this.focusPawn, rc, e);
        } else {
            let lastResponder = this.findLastResponder(e, eventType);
            if (lastResponder) {
                return this.invokeListeners(eventType, lastResponder, rc, e);
            }
        }
    }

    doPointerClick(e) {
        let eventType = "click";
        const rc = this.pointerRaycast(e.xy, this.getTargets(eventType));

        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, rc, e);
        }

        if (rc.pawn) {
            this.invokeListeners(eventType, rc.pawn, rc, e);
        } else {
            let lastResponder = this.findLastResponder(e, eventType);
            if (lastResponder) {
                return this.invokeListeners(eventType, lastResponder, rc, e);
            }
        }
    }

    doPointerDoubleDown(e) {
        let eventType = "pointerDoubleDown";
        const rc = this.pointerRaycast(e.xy, this.getTargets(eventType, true), true);

        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, rc, e);
        }

        if (rc.pawn) {
            this.invokeListeners(eventType, rc.pawn, rc, e);
        }
    }

    doPointerWheel(e) {
        let eventType = "pointerWheel";
        const rc = this.pointerRaycast(e.xy, this.getTargets(eventType, true), true);

        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, rc, e);
        }

        if (rc.pawn) {
            this.invokeListeners(eventType, rc.pawn, rc, e);
        } else {
            let lastResponder = this.findLastResponder(e, eventType);
            if (lastResponder) {
                return this.invokeListeners(eventType, lastResponder, rc, e);
            }
        }
    }

    doPointerTap(e) {
        let eventType = "pointerTap";
        const rc = this.pointerRaycast(e.xy, this.getTargets(eventType));

        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, rc, e);
        }

        if (rc.pawn) {
            this.invokeListeners(eventType, rc.pawn, rc, e);
        } else {
            let lastResponder = this.findLastResponder(e, eventType);
            if (lastResponder) {
                return this.invokeListeners(eventType, lastResponder, rc, e);
            }
        }
    }

    doKeyDown(e) {
        let eventType = "keyDown";
        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, null, e);
        }

        if (this.focusPawn) {
            this.invokeListeners(eventType, this.focusPawn, null, e);
        } else {
            let lastResponder = this.findLastResponder(e, eventType);
            if (lastResponder) {
                return this.invokeListeners(eventType, lastResponder, null, e);
            }
        }
    }

    doKeyUp(e) {
        let eventType = "keyUp";
        let firstResponder = this.findFirstResponder(e, eventType);
        if (firstResponder) {
            return this.invokeListeners(eventType, firstResponder, null, e);
        }

        if (this.focusPawn) {
            this.invokeListeners(eventType, this.focusPawn, null, e);
        }

        // this falling through part is also a hack, but we want to clear the wasd key bits in avatar.
        let lastResponder = this.findLastResponder(e, eventType);
        if (lastResponder) {
            return this.invokeListeners(eventType, lastResponder, null, e);
        }
    }

    pointerEvent(rc, wcEvent) {
        const pe = {avatarId: this.actor.id}
        if (rc.pawn) {
            pe.targetId = rc.pawn.actor.id;
            pe.xyz = rc.xyz;
            pe.uv = rc.uv;
            pe.normal = rc.normal;
            pe.distance = rc.distance;
        }
        pe.ctrlKey = wcEvent.ctrlKey;
        pe.altKey = wcEvent.altKey;
        pe.shiftKey = wcEvent.shiftKey;
        pe.metaKey = wcEvent.metaKey;
        pe.xy = wcEvent.xy;
        pe.id = wcEvent.id;
        pe.button = wcEvent.button;
        pe.buttons = wcEvent.buttons;
        if (wcEvent.deltaY !== undefined) {
            pe.deltaY = wcEvent.deltaY;
        }
        return pe;
    }
}


/***/ }),

/***/ "./src/assetManager.js":
/*!*****************************!*\
  !*** ./src/assetManager.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssetManager": () => (/* binding */ AssetManager),
/* harmony export */   "Loader": () => (/* binding */ Loader),
/* harmony export */   "addEnvMap": () => (/* binding */ addEnvMap),
/* harmony export */   "addShadows": () => (/* binding */ addShadows),
/* harmony export */   "addTexture": () => (/* binding */ addTexture),
/* harmony export */   "normalizeSVG": () => (/* binding */ normalizeSVG)
/* harmony export */ });
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io
/* globals JSZip */

const MAX_IMPORT_MB = 100; // aggregate

let THREE;

function isZip(buffer) {
    return buffer[0] === 0x50 && buffer[1] === 0x4b &&
        buffer[2] === 0x03 && buffer[3] === 0x04;
}

class ImportChecker {
    constructor() {
        this.totalSize = 0;
    }

    addItem(spec) {
        if (!this.withinLimits) return false;

        this.totalSize += spec.buffer.byteLength;
        return this.withinLimits;
    }

    get withinLimits() {
        return this.totalSize <= 1048576 * MAX_IMPORT_MB;
    }

    get totalBytes() {
        return this.totalSize;
    }
}

class AssetManager {
    constructor() {
        this.assetCache = {}; // {[dataId]: {buffer, dataURL, blob, userIds: [id]}}
        this.objectURLs = {}; // {[viewId]: [dataIds]}
        this.supportedFileTypes = new Set(["zip", "glb", "obj", "fbx", "svg", "png", "jpeg", "jpg", "gif", "exr", "pdf", "vrse"]);
    }

    fetchFile(item) {
        const file = item.getAsFile(); // getAsFile() is a method of DataTransferItem
        const type = this.getFileType(file.name);

        if (file && type) {
            return this.fetchSpecForDroppedFile(file, type).then((spec) => {
                if (!this.supportedFileTypes.has(type)) {
                    throw new Error("unsupported file type");
                }

                return {type, buffer: spec.buffer};
            });
        }
        throw new Error("could not read a file");
    }

    async handlePasteText(items) {
        for (const item of items) {
            if (item.kind === "string" && item.type === "text/plain") {
                return new Promise(resolve => item.getAsString(resolve));
            }
        }
    }

    async handleFiles(items) {
        const importSizeChecker = new ImportChecker();

        if (items.length > 1) {
            console.warn("multiple files or dirs dropped");
        }

        const item = items[0];

        const entry = item.getAsEntry ? item.getAsEntry()
            : (item.webkitGetAsEntry ? item.webkitGetAsEntry() : null);
        if (entry && entry.isDirectory) {
            try {
                return this.analyzeDirectory(entry, importSizeChecker);
                // returns {zip, type}
            } catch(_err) {
                throw Error("directory could not be zipped");
            }
        }

        let obj = await this.fetchFile(item);
        if (entry) obj.fileName = entry.fullPath;
        return obj;
    }

    async analyzeDirectory(dirEntry, importSizeChecker) {
        // recursively examine the directory contents, adding files to zip and figure out type
        const todo = [{path: dirEntry.fullPath, entry: dirEntry, depth: 0}];

        let zip = new JSZip();

        let maybeType;

        const processEntries = () => {
            const { path, entry, depth } = todo.pop();
            if (entry.isDirectory) {
                return new Promise((resolve, _reject) => {
                    entry.createReader().readEntries(entries => {
                        for (const entryInDir of entries) {
                            todo.push({ path: entryInDir.fullPath, entry: entryInDir, depth: depth + 1 });
                        }
                        resolve(true);
                    });
                })
            } else {
                // file() is a method of FileSystemFileEntry
                return new Promise((resolve, reject) => {
                    entry.file(async file => {
                        const fileType = this.getFileType(file.name);
                        const spec = await this.fetchSpecForDroppedFile(file, fileType);
                        if (spec.type === "obj") {
                            maybeType = "obj";
                        }
                        spec.path = path;
                        spec.depth = depth;
                        importSizeChecker.addItem(spec);
                        if (importSizeChecker.withinLimits) {
                            zip.file(path, spec.buffer);
                        } else {
                            throw new Error("directory too large");
                        }
                        resolve(true);
                    }, (err) => {
                        reject(err);
                    });
                });
            }
        };

        return new Promise(async (resolve, _reject) => {
            while (todo.length > 0) {
                await processEntries();
            }
            resolve(true);
        }).then(() => ({zip, type: maybeType}));
    }

    getFileType(fileName) {
        let index = fileName.lastIndexOf(".");
        if (index >= 0) {
            return fileName.slice(index + 1).toLowerCase();
        }
        return null;
    }


    async fetchSpecForDroppedFile(file, fileType) {
        const reader = new FileReader();

        return new Promise((resolve, reject) => {
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        }).then((buffer) => {
            return { name: file.name, type: fileType, blob: file, buffer };
        }).catch((e) => {
            console.error(e);
            throw new Error("reading a file failed");
        });
    }

    async drop(data) {
        let hasFiles = [...data.types].includes("Files");
        if (hasFiles) {
            let {zip, buffer, type, fileName} = await this.handleFiles(data.items);
            if (zip) return zip.generateAsync({type: "uint8array"});
            return { fileName, type, buffer };
        } else {
            let buffer = await this.handlePasteText(data.items);
            if (buffer) return { type: "pastedtext", buffer };
        }
        return null;
    }

    setupHandlersOn(dom, callback) {
        const handleData = async (data) => {
            let obj = await this.drop(data);
            if (!obj) {
                console.log("not a file");
                return;
            }
            let {buffer, fileName, type} = obj;
            if (callback) {
                callback(buffer, fileName, type);
            };
        };
        dom.ondragover = (evt) => evt.preventDefault();
        dom.ondrop = (evt) => {
            evt.preventDefault();
            handleData(evt.dataTransfer);
        }
        dom.onpaste = (evt) => {
            evt.preventDefault();
            handleData(evt.clipboardData || window.clipboardData);
        };
    }

    use(dataId, userId) {
        let obj = this.assetCache[dataId];
        if (!obj) {return null;}
        let {buffer, objectURL, blob, userIds} = obj;
        if (userIds.indexOf(userId) < 0) {
            userIds.push(userId);
        }
        if (!blob && buffer) {
            obj.blob = new Blob([buffer], { type: 'application/octet-stream'});
            obj.buffer = null;
        }
        if (!objectURL) {
            obj.objectURL = URL.createObjectURL(blob);
        }
        return obj.objectURL;
    }

    revoke(dataId, userId) {
        let obj = this.assetCache[dataId];
        if (!obj) {return null;}
        let {_buffer, objectURL, _blob, userIds} = obj;
        let ind = userIds.indexOf(userId);
        if (ind >= 0) {
            userIds.splice(ind, 1);
        }

        if (userIds.length === 0 && objectURL) {
            URL.revokeObjectURL(objectURL);
            obj.objectURL = null;
        }

        delete this.assetCache[dataId];
    }

    async load(buffer, type, THREE, options) {
        // here is a bit of checks to do. The file dropped might have been a directory,
        // and then we zipped it. But the file dropped might have been a zip file,
        // The dropped file might have been named like
        // abc.glb.zip, but it might have been abc.zip
        let types = {
            "glb": "importGLB",
            "obj": "importOBJ",
            "fbx": "importFBX",
            "svg": "importSVG",
            "png": "importIMG",
            "jpg": "importIMG",
            "jpeg": "importIMG",
            "gigf": "importIMG",
            "exr": "importEXR"
        };

        if (isZip(buffer)) {
            let zipFile = new JSZip();
            let zip = await zipFile.loadAsync(buffer);
            let files = Object.keys(zip.files);

            for (let file in types) {
                if (files.find((name) => name.endsWith(`.${file}`))) {
                    let loader = new Loader();
                    return loader[types[file]](buffer, options, THREE);
                }
            }

            throw new Error("unknown file type");
        }

        for (let file in types) {
            if (type === file) {
                let loader = new Loader();
                return loader[types[file]](buffer, options, THREE);
            }
        }
        throw new Error("unknown file type");
    }
}

class Loader {
    localName(str) {
        // str can be  [blob:]https://.../... or /.../... such.
        // It just take the last part after the last /
        let index = str.lastIndexOf("/");
        if (index >= 0) {
            return str.slice(index + 1);
        }
        return str;
    }

    imgType(name) {
        // returns a MIME-subtype string or null
        if (name.endsWith(".png")) {
            return "png";
        }
        if (name.endsWith(".jpeg") || name.endsWith(".jpg")) {
            return "jpeg";
        }
        return null;
    };

    async setupFilesInZip(buffer, required) {
        // required: {[name]: dataType}
        // returns {[type]: blob, ...imgContents}
        let zipFile = new JSZip();
        let zip = await zipFile.loadAsync(buffer);
        let imgContents = {}; // {[name after slash]: dataURL}

        let files = Object.keys(zip.files);

        let promises = Object.keys(required).map((req) => {
            let dataType = required[req];
            let file = files.find((name) => name.endsWith(`.${req}`));
            return zip.file(file).async(dataType).then((content) => {
                return {type: req, blob: URL.createObjectURL(new Blob([content]))};
            });
        });

        let result = {};
        await Promise.all(promises).then((pairs) => {
            pairs.forEach((pair) => {
                result[pair.type] = pair.blob;
            });
        });

        let imgFiles = files.map((n) => ({name: n, type: this.imgType(n)})).filter((o) => o.type);

        let imgPromises = imgFiles.map((obj) => {
            let {name, type} = obj;
            let localName = this.localName(name);
            return zip.file(name).async("uint8array").then((content) => {
                let blob = new Blob([content], {type: `image/${type}`});
                let reader = new FileReader();
                return new Promise((resolve, _reject) => {
                    reader.addEventListener("load", () => {
                        imgContents[localName] = reader.result;
                        resolve(reader.result);
                    });
                    return reader.readAsDataURL(blob);
                });
            });
        });

        await Promise.all(imgPromises);

        return {...result, imgContents};
    };

    setURLModifierFor(manager, imgContents) {
        if (!imgContents) {return;}
        manager.setURLModifier(urlStr => {
            // console.log(`handling request for ${urlStr}`);

            if (this.imgType(urlStr)) {
                // console.log(`returning imgUrl`);
                let localName = this.localName(urlStr);
                return imgContents[localName] || ""; // it may not have the file
            }
            // console.log(`returning ${urlStr}`);
            return urlStr;
        });
    }

    async importOBJ(buffer, options, THREE) {
        let mtl;

        const setupFiles = async () => {
            if (!isZip(buffer)) {
                let c = {"obj": URL.createObjectURL(new Blob([buffer]))};
                return Promise.resolve(c);
            }

            return this.setupFilesInZip(buffer, {"obj": "string", "mtl": "string"});
        };

        let contents = await setupFiles();
        const manager = new THREE.LoadingManager();
        this.setURLModifierFor(manager, contents.imgContents);

        if (contents.mtl) {
            const mtlLoader = new THREE.MTLLoader(manager);
            mtl = await new Promise((resolve, reject) => {
                mtlLoader.load(contents.mtl, resolve, null, reject);
            });//.catch((err) => console.log("laoding material failed"));
        }

        const objLoader = new THREE.OBJLoader(manager);
        let obj = await new Promise((resolve, reject) => {
            if (mtl) {
                objLoader.setMaterials(mtl);
            }
            objLoader.load(contents.obj, resolve, null, reject);
        });//.catch((err) => console.log("laoding material failed"));

        Object.keys(contents).forEach((k) => {
            if (contents[k] && k !== "imgContents") {
                URL.revokeObjectURL(contents[k]);
            }
        });
        return obj;
    }

    async importFBX(buffer, options, THREE) {
        const setupFiles = async () => {
            if (!isZip(buffer)) {
                let c = {"fbx": URL.createObjectURL(new Blob([buffer]))};
                return Promise.resolve(c);
            }

            return this.setupFilesInZip(buffer, {"fbx": "ArrayBuffer"});
        };

        let contents = await setupFiles();

        const manager = new THREE.LoadingManager();
        this.setURLModifierFor(manager, contents.imgContents);

        const fbxLoader = new THREE.FBXLoader(manager);
        let obj = await new Promise((resolve, reject) => {
            return fbxLoader.load(contents.fbx, resolve, null, reject);
        }).then((object) => {
            if (object.animations.length > 0) {
                const mixer = new THREE.AnimationMixer(object);
                mixer.clipAction(object.animations[0]).play();
                object._croquetAnimation = {
                    lastTime: 0,
                    mixer
                };
            }
            return object;
        });

        Object.keys(contents).forEach((k) => {
            if (contents[k] && k !== "imgContents") {
                URL.revokeObjectURL(contents[k]);
            }
        });
        return obj;
    }

    async importGLB(buffer, options, THREE) {
        const getBuffer = async () => {
            if (isZip(buffer)) {
                let zipFile = new JSZip();
                let zip = await zipFile.loadAsync(buffer);
                let files = Object.keys(zip.files);
                let glbFile = files.find((name) => name.endsWith(".glb"));
                return zip.files[glbFile].async("ArrayBuffer");
            } else {
                return Promise.resolve(buffer.buffer);
            }
        };

        return getBuffer().then((data) => {
            let loader = new THREE.GLTFLoader();
            return new Promise((resolve, _reject) => {
                let draco = new THREE.DRACOLoader();
                draco.setDecoderConfig({type: 'wasm'});
                draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                loader.setDRACOLoader(draco);
                return loader.parse(data, null, (obj) => resolve(obj));
            }).then((loaded) => {
                let {scene, animations} = loaded;
                if (animations.length > 0) {
                    const mixer = new THREE.AnimationMixer(scene);
                    mixer.clipAction(animations[0]).play();
                    scene._croquetAnimation = {
                        lastTime: 0,
                        mixer
                    };
                }
                return scene;
            })
        });
    }

    async importSVG(buffer, options, THREE) {
        this.THREE = THREE;
        const setupFiles = async () => {
            let c = {"svg": URL.createObjectURL(new Blob([buffer]))};
            return Promise.resolve(c);
        };

        let contents = await setupFiles();

        let svg = await new Promise((resolve, _reject) => {
            const {fullBright, color, frameColor, depth, _shadow, _singleSided} = options;
            const M = fullBright ? THREE.MeshBasicMaterial : THREE.MeshStandardMaterial;
            const loader = new THREE.SVGLoader();
            let offset = 0;
            loader.load(contents.svg, (data) => {
                const paths = data.paths;
                const group = new THREE.Group();
                for ( let i = 0; i < paths.length; i ++) {
                    const path = paths[ i ];
                    const fillColor = path.userData.style.fill;
                    if ( fillColor !== undefined && fillColor !== 'none' ) {
                        let material = new M( {
                            color: new THREE.Color().setStyle( fillColor ),
                            opacity: path.userData.style.fillOpacity,
                            side: (depth ? THREE.FrontSide : THREE.DoubleSide),
                        } );
                        if(color)material.color = new THREE.Color(color);
                        if(depth)material = [material, new THREE.MeshStandardMaterial({color:frameColor, metalness:1.0})];
                        const shapes = THREE.SVGLoader.createShapes( path );
                        for ( let j = 0; j < shapes.length; j ++ ) {
                            const shape = shapes[ j ];
                            let geometry;
                            if (depth) {
                                geometry = new THREE.ExtrudeGeometry( shape, {depth: 1 + offset, bevelEnabled:false})
                            } else {
                                geometry = new THREE.ShapeGeometry( shape );
                            }
                            const mesh = new THREE.Mesh( geometry, material );
                            mesh.position.z += depth;
                            offset += 0.002;
                            group.add( mesh );
                        }
                    }
                    const strokeColor = path.userData.style.stroke;
                    if ( strokeColor !== undefined && strokeColor !== 'none' ) {
                        const material = new M( {
                            color: new THREE.Color().setStyle( strokeColor ),
                            opacity: path.userData.style.strokeOpacity,
                            //transparent: true,
                            side: THREE.DoubleSide,
                            //depthWrite: false,
                        } );

                        for ( let j = 0, jl = path.subPaths.length; j < jl; j ++ ) {
                            const subPath = path.subPaths[ j ];
                            const geometry = THREE.SVGLoader.pointsToStroke( subPath.getPoints(), path.userData.style );
                            if ( geometry ) {
                                const mesh = new THREE.Mesh( geometry, material );
                                group.add( mesh );
                            }
                        }
                    }
                }
                resolve(group);
	    });
        });

        Object.keys(contents).forEach((k) => {
            if (contents[k] && k !== "imgContents") {
                URL.revokeObjectURL(contents[k]);
            }
        });
        return svg;
    }

    async importIMG(buffer, options, THREE) {
        let objectURL = URL.createObjectURL(new Blob([buffer]));
        let loader = new THREE.TextureLoader();
        let texture = new Promise((resolve, reject) => {
            loader.load(objectURL, (texture) => {
                texture.width = texture.image.width;
                texture.height = texture.image.height;
                resolve(texture);
            }, null, reject);
        });

        return texture.then(() => {
            URL.revokeObjectURL(objectURL);
            return texture;
        })
    }

    async importEXR(buffer, options, THREE) {
        const setupFiles = async () => {
            if (!isZip(buffer)) {
                let c = {"exr": URL.createObjectURL(new Blob([buffer]))};
                return Promise.resolve(c);
            }

            return this.setupFilesInZip(buffer, {"exr": "ArrayBuffer"});
        };

        let contents = await setupFiles();

        let obj = new Promise((resolve, reject) => {
            new THREE.EXRLoader().load(contents.exr, resolve, null, reject);
        });

        Object.keys(contents).forEach((k) => {
            if (contents[k] && k !== "imgContents") {
                URL.revokeObjectURL(contents[k]);
            }
        });
        return obj;
    }
}

function addShadows(obj3d, shadow, singleSide, THREE) {
    obj3d.traverse(n => {
        if(n.material) {
            if (singleSide) {
                n.material.side = THREE.FrontSide; //only render front side
            }
            n.material.format = THREE.RGBAFormat; // fixes a bug in GLTF import
            if(shadow){
                n.castShadow = true;
                n.receiveShadow = true;
            }
        }
    });
}

function normalizeSVG(svgGroup, depth, shadow, three) {
    THREE = three;
    let bb = boundingBox(svgGroup);
    let ext = extent3D(svgGroup, bb);
    let cen = center3D(svgGroup, bb);
    svgGroup.scale.y *= -1;
    cen.y *= -1;
    let mx = Math.max(ext.x, ext.y);
    // scale SVG object to 1 along largest axis
    if (mx > 0) {
        // need svgGroup.aspect for positioning in jump to card
        if (ext.y) svgGroup.aspect = ext.x / ext.y;
        svgGroup.position.set(-cen.x, -cen.y, -cen.z);
        let sc = 1 / mx;
        svgGroup.position.multiplyScalar(sc);
        let sg = svgGroup.scale;
        if (depth) {
            svgGroup.scale.set(sg.x * sc, sg.y * sc, depth);
        } else {
            svgGroup.scale.multiplyScale(sc);
        }
    }

    svgGroup.traverse(obj => {
        if (obj.material) {
            normalizeUV(obj.geometry.attributes.uv.array, obj.geometry.attributes.normal.array, bb);
            if (shadow) {
                obj.castShadow = true;
                obj.receiveShadow = true;
            }
        }
    });
}

function normalizeUV(uvArray, uvNormal, bb) {
    let s = [bb.max.x - bb.min.x, bb.max.y - bb.min.y];
    s[0] = s[0] > 0 ? 1 / s[0] : 1;
    s[1] = s[1] > 0 ? 1 / s[1] : 1;
    let o = [bb.min.x, bb.min.y];
    let index = 0;
    let count = 0;
    for(let i = 0; i < uvArray.length;i++) {
        count += index;
        if(!uvNormal[count * 3] + 2) { // if z is 0, then do nothing
            uvArray[i] = (uvArray[i] - o[index]) * s[index];
            if (index) uvArray[i] = 1 - uvArray[i];
        }
        index = index === 0 ? 1 : 0;
    }
}

function boundingBox(obj, bigBox, depth) {
    // this needs to recursively merge the bounding box of all of the objects it contains.
    // computes the boundingBox in LOCAL coordinates.  if there's a parent, temporarily
    // remove from the parent and reset position and orientation.
    // the boundingBox reflects the extent after application of the current scale setting.

    if (!bigBox) {
        bigBox = new THREE.Box3();
        depth = 0;
    }
    if (obj.geometry) { //means it is a visible thing
        if (!obj.geometry.boundingBox)obj.geometry.computeBoundingBox();
        const box = obj.geometry.boundingBox.clone();
        box.applyMatrix4(obj.matrixWorld);
        bigBox.union(box);
    }
    if (obj.children) {
        obj.children.forEach(child => boundingBox(child, bigBox, depth + 1));
    }
    return bigBox;
}

function extent3D(obj, bb) {
    let rVec = new THREE.Vector3();
    if (!bb) bb = boundingBox(obj);

    if (bb) {
        rVec.copy(bb.max);
        rVec.sub(bb.min);
    }
    return rVec;
}

function center3D(obj, bb) {
    let rVec = new THREE.Vector3();
    if (!bb) bb = boundingBox(obj);
    if (bb) {
        rVec.copy(bb.max);
        rVec.add(bb.min);
        rVec.multiplyScalar(0.5);
    }
    return rVec;
}

function addTexture(group, texture) {
    //const texture = new THREE.TextureLoader().load(url);
    group.traverse((child) => {
        if (child.material) {
            if(Array.isArray(child.material)) {
                child.material[0].map = texture;
                //child.material[2].map = texture;
            } else {
                child.material.map = texture;
            }
        }
    });
}

function addEnvMap(group, envMap){
    group.traverse((child) => {
        if (child.material) {
            if (Array.isArray(child.material)) {
                child.material[0].envMap = envMap;
                child.material[1].envMap = envMap;
            } else {
                child.material.envMap = envMap;
            }
        }
    });
}


/***/ }),

/***/ "./src/card.js":
/*!*********************!*\
  !*** ./src/card.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardActor": () => (/* binding */ CardActor),
/* harmony export */   "CardPawn": () => (/* binding */ CardPawn),
/* harmony export */   "MicroverseAppManager": () => (/* binding */ MicroverseAppManager),
/* harmony export */   "VideoManager": () => (/* binding */ VideoManager),
/* harmony export */   "intrinsicProperties": () => (/* binding */ intrinsicProperties)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
/* harmony import */ var _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @croquet/worldcore-three */ "./node_modules/@croquet/worldcore-three/index.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pointer.js */ "./src/Pointer.js");
/* harmony import */ var _assetManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assetManager.js */ "./src/assetManager.js");
/* harmony import */ var _text_text_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./text/text.js */ "./src/text/text.js");
/* harmony import */ var _DynamicTexture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DynamicTexture.js */ "./src/DynamicTexture.js");
/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./code.js */ "./src/code.js");
/* harmony import */ var _worldSaver_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./worldSaver.js */ "./src/worldSaver.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io
//
// Collaborative Card Object










// import { forEach } from 'jszip';

const { MeshBVH, /*MeshBVHVisualizer*/ } = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE_MESH_BVH;

const intrinsicProperties = ["translation", "scale", "rotation", "layers", "parent", "behaviorModules", "multiuser", "name", "noSave"];


//------------------------------------------------------------------------------------------
//-- CardActor ------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

class CardActor extends (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.mix)(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Actor).with(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.AM_Smoothed, _Pointer_js__WEBPACK_IMPORTED_MODULE_2__.AM_PointerTarget, _code_js__WEBPACK_IMPORTED_MODULE_6__.AM_Code) {
    // this should be in AM_SPATIAL but that would require changing Worldcore mixins
    static okayToIgnore() { return [ "$local", "$global", "$rigidBody" ]; }

    init(options) {
        let {cardOptions, cardData} = this.separateOptions(options);

        if (!cardOptions.layers) {
            cardOptions.layers = ["pointer"];
        }

        // coming from different mixins, but still used by listen.
        this.scriptListeners = new Map();
        super.init(cardOptions);
        this._cardData = cardData;
        this.noSave = options.noSave;
        this.createShape(cardData);
        this.listen("selectEdit", this.saySelectEdit);
        this.listen("unselectEdit", this.sayUnselectEdit);
        this.listen("showControls", this.showControls);
        this.listen("setCardData", this.setCardData);

        this.listen("dataScaleComputed", this.dataScaleComputed);
    }

    separateOptions(options) {
        let cardOptions = {};
        let cardData = {};

        Object.keys(options).forEach((k) => {
            if (intrinsicProperties.indexOf(k) >= 0) {
                cardOptions[k] = options[k];
            } else {
                cardData[k] = options[k];
            }
        });
        return {cardOptions, cardData};
    }

    updateOptions(options) {
        let {cardOptions, cardData} = this.separateOptions(options);
        this.updateBehaviors(options);
        this.set({...cardOptions});
        this.set({cardData: cardData});
        this.say("updateShape", options);
    }

    addBehaviorModule(moduleName) {
        let behaviorModules;
        if (!this._behaviorModules) {
            behaviorModules = [moduleName];
        } else if (this._behaviorModules.includes(moduleName)) {
            return;
        } else {
            behaviorModules = [...this._behaviorModules, moduleName];
        }
        this.updateBehaviors({behaviorModules});
    }

    removeBehaviorModule(moduleName) {
        let behaviorModules;
        if (!this._behaviorModules) {return;}
        let index = this._behaviorModules.indexOf(moduleName);
        if (index < 0) {return;}
        behaviorModules = [...this._behaviorModules];
        behaviorModules.splice(index, 1);
        this.updateBehaviors({behaviorModules});
    }

    updateBehaviors(options) {
        if (!options.behaviorModules) {return;}
        let behaviorManager = this.behaviorManager;

        let allNewActorBehaviors = [];
        let allNewPawnBehaviors = [];

        options.behaviorModules.forEach((moduleName) => {
            let module = behaviorManager.modules.get(moduleName);
            if (!module) {
                console.error(`unknown module ${moduleName} is specified for update`);
                return;
            }
            if (module.actorBehaviors) {
                allNewActorBehaviors.push(...module.actorBehaviors.values());
            }
            if (module.pawnBehaviors) {
                allNewPawnBehaviors.push(...module.pawnBehaviors.values());
            }
        });

        let allOldActorBehaviors = [];
        let allOldPawnBehaviors = [];

        let oldSystemModules = [];
        if (this._behaviorModules) {
            this._behaviorModules.forEach((oldModuleName) => {
                let oldModule = behaviorManager.modules.get(oldModuleName);
                if (oldModule.actorBehaviors) {
                    allOldActorBehaviors.push(...oldModule.actorBehaviors.values());
                }
                if (oldModule.pawnBehaviors) {
                    allOldPawnBehaviors.push(...oldModule.pawnBehaviors.values());
                }
                if (oldModule.systemModule) {
                    oldSystemModules.push(oldModule.externalName);
                    if (oldModule.actorBehaviors) {
                        allNewActorBehaviors.push(...oldModule.actorBehaviors.values());
                    }
                    if (oldModule.pawnBehaviors) {
                        allNewPawnBehaviors.push(...oldModule.pawnBehaviors.values());
                    }
                }
            });
        }

        allOldActorBehaviors.forEach((oldBehavior) => {
            if (!allNewActorBehaviors.includes(oldBehavior)) {
                behaviorManager.modelUnuse(this, oldBehavior);
            }
        });
        allOldPawnBehaviors.forEach((oldBehavior) => {
            if (!allNewPawnBehaviors.includes(oldBehavior)) {
                behaviorManager.viewUnuse(this, oldBehavior);
            }
        });

        allNewActorBehaviors.forEach((newBehavior) => {
            if (!allOldActorBehaviors.includes(newBehavior)) {
                behaviorManager.modelUse(this, newBehavior);
            }
        });
        allNewPawnBehaviors.forEach((newBehavior) => {
            if (!allOldPawnBehaviors.includes(newBehavior)) {
                behaviorManager.viewUse(this, newBehavior);
            }
        });

        this._behaviorModules = [...oldSystemModules, ...options.behaviorModules];
    }

    addLayer(newLayerName) {
        if (this._layers.includes(newLayerName)) {return;}
        this.set({layers: [...this._layers, newLayerName]});
    }

    removeLayer(layerName) {
        if (!this._layers.includes(layerName)) {return;}
        this._layers = this._layers.filter((layer) => layer !== layerName);
    }

    setCardData(options) {
        let newOptions = {...this._cardData, ...options};
        this.set({cardData: newOptions});
    }

    createShape(options) {
        let type = options.type;
        if (type === "text") {
            this.subscribe(this.id, "changed", "textChanged");
        } else if (type === "3d") {
            this.creationTime = this.now();
        } else if (type === "2d" || type === "2D" ) {
        } else if (type === "lighting") {
        } else if (type === "object") {
        } else if (type === "code") {
            this.subscribe(this.id, "changed", "textChanged");
            // this is a weird inter mixins dependency but not sure how to write it
            this.subscribe(this.id, "text", "codeAccepted");
        } else {
            console.log("unknown type for a card: ", options.type);
        }
    }

    get pawn() { return CardPawn; }
    get layers() { return this._layers; }
    get isCard() {return true;}
    get name() {return this._name || 'Card'}
    get color() {return this._color || 0xffffff}

    uv2xy(uv) {
        return [this._cardData.textureWidth * uv[0], this._cardData.textureHeight * (1 - uv[1])];
    }

    dataScaleComputed(s) {
        if (s === undefined) {
            delete this._cardData.dataScale;
        } else {
            this._cardData.dataScale = s;
        }
    }

    textChanged() {
        this._cardData.runs = this.content.runs;
        this.publish(this.sessionId, "triggerPersist");
    }

    sayDeck(message, data) {
        if (this._parent) {
            return this.publish(this._parent.id, message, data);
        }
        this.publish(this.id, message, data);
    }

    listenDeck(message, method) {
        if (this._parent) {
            return this.subscribe(this._parent.id, message, method);
        }
        this.subscribe(this.id, message, method);
    }

    nop() {}

    duplicate() {
        let saver = new _worldSaver_js__WEBPACK_IMPORTED_MODULE_7__.WorldSaver(CardActor);
        let data = saver.collectCardData(this);
        delete data.parent;
        let t = this.translation;

        data.translation = [t[0] + 2, t[1], t[2]];
        this.createCard(data);
    }

    saveCard(data) {
        this.say("saveCard", data);
    }

    allChildrenMap(cards) {
        if (!cards) {cards = new Map();}
        if (!this.noSave) {
            cards.set(this.id, this);
        }
        if (this.children) {
            this.children.forEach(c => c.allChildrenMap(cards));
        }
        return cards;
    }

    showControls(toWhom) {
        let avatar = this.service("ActorManager").actors.get(toWhom.avatar);
        let distance = (toWhom.distance || 6);
        distance = Math.min(distance * 0.7, 4);
        if (avatar) {
            let pose = avatar.dropPose(distance, [1, 1, 0]);
            if (!this.behaviorManager.modules.get("PropertySheet")) {return;}
            let menu = this.createCard({
                name: "property panel",
                behaviorModules: ["PropertySheet"],
                translation: pose.translation,
                rotation: pose.rotation,
                type: "object",
                fullBright: true,
                color: 0xffffff,
                frameColor: 0x666666,
                width: 3,
                height: 3.2,
                cornerRadius: 0.02,
                depth: 0.02,
                noSave: true,
                target: this.id,
            });
            menu.call("PropertySheet$PropertySheetActor", "setObject", this);
        }
    }

    setBehaviors(selection) {
        let behaviorModules = [];

        selection.forEach((obj) => {
            let {label, selected} = obj;
            if (this.behaviorManager.modules.get(label)) {
                if (selected) {
                    behaviorModules.push(label);
                }
            }
        });
        this.updateBehaviors({behaviorModules});
    }

    intrinsicProperties() {return intrinsicProperties;}

    saySelectEdit() {
        this.say("doSelectEdit");
    }

    sayUnselectEdit() {
        this.say("doUnselectEdit");
    }

    collectCardData() {
        let saver = new _worldSaver_js__WEBPACK_IMPORTED_MODULE_7__.WorldSaver(CardActor);
        return saver.collectCardData(this, true);
    }

    static load(cards, world, version) {
        let array;
        let nameMap;
        if (Array.isArray(cards)) {
            array = cards;
        } else {
            array = cards.array;
            nameMap = cards.nameMap;
        }
        // it is supposed to load a JSONable structure from array, but a special case is made
        // for the parent property where you can give an actual object
        if (version === "1") {
            let appManager = world.service("MicroverseAppManager");
            let behaviorManager = world.service("BehaviorModelManager");
            let map = new Map();
            return array.map(({id, card}) => {
                let Cls;
                let options = {...card};
                let behavior;
                if (options.type === "code") {
                    if (options.behaviorModule) {
                        let [moduleName, behaviorName] = options.behaviorModule.split(".");
                        behavior = behaviorManager.lookup(moduleName, behaviorName);
                    }

                    let runs = [{text: behavior ? behavior.code : ""}];

                    options = {
                        backgroundColor: 0xcccccc,
                        textScale: options.textScale || 0.002,
                        ...options,
                        runs: runs,
                    };
                    Cls = _text_text_js__WEBPACK_IMPORTED_MODULE_4__.TextFieldActor;
                } else if (card.className) {
                    Cls = appManager.get(card.className);
                    delete options.className;
                } else {
                    Cls = CardActor;
                }
                if (card.parent) {
                    if (typeof card.parent !== "object") {
                        let parent = map.get(card.parent);
                        options.parent = parent;
                    }
                }

                if (Array.isArray(card.rotation) && card.rotation.length === 3) {
                    options.rotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(...card.rotation);
                }

                if (Array.isArray(card.dataRotation) && card.dataRotation.length === 3) {
                    options.dataRotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(...card.dataRotation);
                }

                // TODO: remove after alpha
                if (options.targetURL && !options.portalURL) {
                    options.portalURL = options.targetURL;
                    delete options.targetURL;
                }

                if (nameMap) {
                    if (options.behaviorModules) {
                        options.behaviorModules = options.behaviorModules.map((n) => nameMap.get(n) || n);
                    }
                }

                let actor = Cls.create(options);
                if (id) {
                    map.set(id, actor);
                }

                if (options.type === "code" && behavior) {
                    actor.subscribe(behavior.id, "setCode", "loadAndReset");
                }
                return actor;
            });
        }
        return [];
    }

    get rigidBody() {
        // return this.$rigidBody;
        return this.call("Rapier$RapierActor", "getRigidBody");
    }

    collisionEvent(rb1, rb2, started) {
        return this.call(this.collisionEventHandlerBehavior, this.collisionEventHandlerMethod, rb1, rb2, started);
    }
}
CardActor.register('CardActor');

//------------------------------------------------------------------------------------------
//-- CardPawn ------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------


class CardPawn extends (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.mix)(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Pawn).with(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.PM_Smoothed, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.PM_ThreeVisible, _Pointer_js__WEBPACK_IMPORTED_MODULE_2__.PM_PointerTarget, _code_js__WEBPACK_IMPORTED_MODULE_6__.PM_Code) {
    constructor(actor) {
        super(actor);
        this.addToLayers(...actor.layers);
        //this.addEventListener("pointerWheel", "onPointerWheel");
        this.addEventListener("pointerDoubleDown", "onPointerDoubleDown");
        this.listen("doSelectEdit", this.doSelectEdit);
        this.listen("doUnselectEdit", this.doUnselectEdit);
        this.listen("cardDataSet", this.cardDataUpdated);
        this.listen("updateShape", this.updateShape);
        this.listen("layersSet", this.updateLayers);

        this.listen("saveCard", this.saveCard);
        this.constructCard();
    }

    sayDeck(message, vars) {
        if (this.actor._parent !== undefined) this.publish(this.actor._parent.id, message, vars);
        else this.publish(this.actor.id, message, vars);
    }

    listenDeck(message, method) {
        if (this.actor._parent !== undefined) this.subscribe(this.actor._parent.id, message, method);
        else this.subscribe(this.actor.id, message, method);
    }

    constructCard() {
        this.shape = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Group()
        this.shape.name = this.actor.name;
        this.setRenderObject(this.shape);
        this.constructShape(this.actor._cardData);
    }

    constructShape(options) {
        let type = options.type;
        if (type === "3d" || type === "3D") {
            this.construct3D(options);
        } else if (type === "2d" || type === "2D") {
            this.isFlat = true;
            this.construct2D(options);
        }  else if (type === "text" || type === "code") {
            this.isFlat = true;
        } else if (type === "lighting") {
            // this.constructLighting(options);
        }
    }

    ensureColliderObject() {
        if (!this.colliderObject) {
            let collider = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Group();
            this.setColliderObject(collider);
            collider.collider = true;
        }
    }

    cleanupColliderObject() {
        if (this.colliderObject) {
            this.colliderObject.children.forEach((m) => {
                this.colliderObject.remove(m);
            });
            if (this.colliderObject.geometry) {
                this.colliderObject.geometry.dispose();
            }
            delete this.colliderObject;
        }
    }

    updateLayers() {
        let oldLayers = this.layers();
        let toRemove = [];
        oldLayers.forEach((layerName) => {
            if (!this.actor.layers.includes(layerName)) {
                toRemove.push(layerName);
            }
        });
        if (toRemove.length > 0) {
            this.removeFromLayers(...toRemove);
        }
        let origLayers = this.actor._layers;
        if (origLayers) {
            this.addToLayers(...origLayers);
        }
    }

    cleanupShape(_options) {
        this.updateLayers();
        delete this.isFlat;

        if (this.placeholder) {
            this.placeholder.children.forEach((m) => {
                m.geometry.dispose();
                m.material.dispose();
            });
            this.shape.remove(this.placeholder);
            delete this.placeholder;
        }

        delete this.video;
        if (this.texture) {
            this.texture.dispose();
            delete this.texture;
        }

        if (this.objectURL) {
            URL.revokeObjectURL(this.objectURL);
            delete this.objectURL;
        }

        if (this.material) {
            this.material.dispose();
        }

        delete this.name;
        delete this.properties2D;
        delete this.animationSpec;

        this.cleanupColliderObject();

        if (this.shape) {
            this.shape.traverse((m) => {
                // the idea here is that any data that should be disposed should be
                // already accounted for.
                if (m === this.shape) {return;}

                if (m.geometry) {
                    m.geometry.dispose();
                }
                if (m.material) {
                    if (m.material.dispose) {
                        m.material.dispose();
                    } else {
                        m.material.forEach((mm) => mm.dispose());
                    }
                }
            });
            this.shape.children.forEach((m) => this.shape.remove(m));
        }
    }

    updateShape(options) {
        this.cleanupShape(options);
        this.constructShape(this.actor._cardData);
    }

    construct3D(options) {
        let model3d = options.dataLocation;
        let modelType = options.modelType;

        /* this is really a hack to make it work with the current model. */
        if (options.placeholder) {
            let size = options.placeholderSize || [40, 1, 40];
            let color = options.placeholderColor || 0x808080;
            let offset = options.placeholderOffset || [0, -1.7, 0];

            const gridImage = './assets/images/grid.png';
            const texture = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.TextureLoader().load(gridImage);
            texture.wrapS = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.RepeatWrapping;
            texture.wrapT = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.RepeatWrapping;
            texture.repeat.set( size[0], size[2] );
            let pGeometry = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.BoxGeometry(...size);
            let pMaterial = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshStandardMaterial({map:texture, color: color, side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.FrontSide});

            let mesh = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(pGeometry, pMaterial);
            mesh.receiveShadow = true;
            this.placeholder = mesh;
            this.placeholder.position.set(...offset);
            this.placeholder.name = "placeholder";
            if (this.actor.layers.indexOf('walk') >= 0) {
                this.constructCollider(this.placeholder);
            }
            this.shape.add(this.placeholder);
        }

        let name = this.actor.name;
        let shadow = options.shadow !== undefined ? options.shadow : true;
        let singleSided = options.singleSided !== undefined ? options.singleSided : false;
        if (!model3d) {return;}
        let assetManager = this.service("AssetManager").assetManager;

        this.getBuffer(model3d).then((buffer) => {
            return assetManager.load(buffer, modelType, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE);
        }).then((obj) => {
            (0,_assetManager_js__WEBPACK_IMPORTED_MODULE_3__.addShadows)(obj, shadow, singleSided, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE);
            this.setupObj(obj, options);
            obj.updateMatrixWorld(true);
            if (obj._croquetAnimation) {
                const spec = obj._croquetAnimation;
                spec.startTime = this.actor.creationTime;
                this.animationSpec = spec;
                this.future(500).runAnimation();
            }

            if (options.placeholder) {
                console.log("delete collider for placeholder");
                this.cleanupColliderObject();
                this.shape.remove(this.placeholder);
            }

            if (this.actor.layers.indexOf('walk') >= 0) {
                this.constructCollider(obj);
            }

            // place this after collider construction
            // or collider incorporates shape transform
            this.shape.add(obj);

            if (name) {
                obj.name = name;
            }

            if (Array.isArray(obj.material)) {
                obj.material.dispose = arrayDispose;
            }

        });
    }

    construct2D(options) {
        let dataLocation = options.dataLocation;
        let textureLocation = options.textureLocation;
        let textureType = options.textureType;

        let texturePromise; // resolves to texture and width and height

        let depth = (options.depth !== undefined) ? options.depth : 0.05;
        let width = (options.width !== undefined) ? options.width : 1;
        let height = (options.height !== undefined) ? options.height : 1;
        let textureWidth = (options.textureWidth !== undefined) ? options.textureWidth : 512;
        let textureHeight = (options.textureHeight !== undefined) ? options.textureHeight : 512;

        let name = options.name || this.id;
        let color = options.color; // if color is undefined, use SVG colors
        let frameColor = options.frameColor || 0x666666;
        let fullBright = options.fullBright !== undefined ? options.fullBright : false;
        let shadow = options.shadow !== undefined ? options.shadow : true;
        let cornerRadius = options.cornerRadius !== undefined ? options.cornerRadius : 0;

        this.properties2D = {depth, width, height, textureWidth, textureHeight, name, color, frameColor, fullBright, shadow, cornerRadius};

        // You might want to parallelize the texture data loading and svg data loading by arranging
        // promises cleverly, but this.texture should be set quite early
        // (that is before returning from this method) to have apps like multiblaster function

        if (textureType === "video") {
            this.video = document.createElement('video');
            this.video.autoplay = true;
            this.video.muted = true;
            this.video.loop = true;
            this.video.width = textureWidth;
            this.video.height = textureHeight;

            this.getBuffer(textureLocation).then((buffer) => {
                let objectURL = URL.createObjectURL(new Blob([buffer], {type: "video/mp4"}));
                this.video.src = objectURL;
                this.objectURL = objectURL;
                // need to be revoked when destroyed
            });
            this.video.loop = true;
            let videoService = this.service("VideoManager");
            videoService.add(this.video);
            this.texture = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.VideoTexture(this.video);
            texturePromise = Promise.resolve({
                width: this.video.width,
                height: this.video.height,
                texture: this.texture
            });
        } else if (textureType === "image") {
            texturePromise = this.getBuffer(textureLocation).then((buffer) => {
                let objectURL = URL.createObjectURL(new Blob([buffer]));
                this.objectURL = objectURL;
                return new Promise((resolve, reject) => {
                    this.texture = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.TextureLoader().load(
                        objectURL,
                        (texture) => {
                            resolve({width: texture.image.width, height: texture.image.height, texture})
                        }, null, reject);
                });
            });
        } else if (textureType === "canvas") {
            this.canvas = document.createElement("canvas");
            this.canvas.id = name;
            this.canvas.width = textureWidth;
            this.canvas.height = textureHeight;
            this.texture = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.CanvasTexture(this.canvas);
            texturePromise = Promise.resolve({width: textureWidth, height: textureHeight, texture: this.texture});
        } else if (textureType === "dynamic") {
            this.dynamic = new _DynamicTexture_js__WEBPACK_IMPORTED_MODULE_5__.DynamicTexture(textureWidth, textureHeight, options.fillStyle, options.clearStyle);
            this.texture = this.dynamic.texture;
            texturePromise = Promise.resolve({width: textureWidth, height: textureHeight, texture: this.texture});
        }

        if (!texturePromise) {texturePromise = Promise.resolve(undefined);}

        let loadOptions = {
            texture: this.texture,
            color,
            frameColor,
            fullBright,
            shadow,
            depth,
        };

        let assetManager = this.service("AssetManager").assetManager;

        if (dataLocation) {
            return this.getBuffer(dataLocation).then((buffer) => {
                return assetManager.load(buffer, "svg", _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE, loadOptions);
            }).then((obj) => {
                (0,_assetManager_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSVG)(obj, depth, shadow, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE);
                return obj;
            }).then((obj) => {
                if (this.texture) {
                    (0,_assetManager_js__WEBPACK_IMPORTED_MODULE_3__.addTexture)(obj, this.texture);
                }
                if (options.dataTranslation) {
                    obj.position.set(...options.dataTranslation);
                }
                obj.name = "2d";
                if (Array.isArray(obj.material)) {
                    obj.material.dispose = arrayDispose;
                }
                this.objectCreated(obj);
                this.shape.add(obj);
            });
        } else {
            return texturePromise.then((textureObj) => {
                if (textureObj && textureObj.texture) {
                    textureWidth = textureObj.width;
                    textureHeight = textureObj.height;
                    let max = Math.max(textureWidth, textureHeight);
                    let scale = 1 / max;
                    width = textureWidth * scale;
                    height = textureHeight * scale;

                    this.properties2D = {...this.properties2D, width, height, textureWidth, textureHeight};
                }

                let geometry = this.roundedCornerGeometry(width, height, depth, cornerRadius);
                let material = this.makePlaneMaterial(depth, color || 0xffffff, frameColor, fullBright);

                if (this.texture) {
                    material[0].map = this.texture;
                }

                this.material = material;
                let obj = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(geometry, material);
                obj.castShadow = shadow;
                obj.name = "2d";
                this.objectCreated(obj);
                this.shape.add(obj);
            });
        }
    }

    constructCollider(obj) {
        let geometries = [];
        this.ensureColliderObject();

        obj.traverse(c =>{
            if(c.geometry){
                let cloned = c.geometry.clone();
                cloned.applyMatrix4( c.matrixWorld );
                for( const key in cloned.attributes) {
                    if (key !== "position") {
                        cloned.deleteAttribute(key);
                    }
                }
                geometries.push( cloned );
            }
        });

        let BufferGeometryUtils = window.THREE.BufferGeometryUtils;
        const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries( geometries, false);
        mergedGeometry.boundsTree = new MeshBVH( mergedGeometry, { lazyGeneration: false } );
        let collider = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh( mergedGeometry );
        collider.material.wireframe = true;
        collider.material.opacity = 0.5;
        //collider.material.transparent = true;
        collider.matrixWorld = obj.matrixWorld.clone();
        collider.updateMatrixWorld(true);
        collider.visible = false;
        this.colliderObject.add(collider);

        /*
          let visualizer = new MeshBVHVisualizer( collider, 10 );
          visualizer.visible = true;

          this.shape.parent.add(visualizer)
        */
    }

    /*
    constructLighting(options) {
        console.log( "constructLighting", options.dataLocation );
        let assetManager = this.service("AssetManager").assetManager;
        if (options.dataLocation) {
            let dataType = options.dataLocation.split('.').pop().toLowerCase();
            options.dataType = dataType;
            return this.getBuffer(options.dataLocation).then((buffer) => {
                return assetManager.load(buffer, dataType, THREE, options).then((texture) => {
                    let TRM = this.service("ThreeRenderManager");
                    let renderer = TRM.renderer;
                    let scene = TRM.scene;
                    let pmremGenerator = new THREE.PMREMGenerator(renderer);
                    pmremGenerator.compileEquirectangularShader();

                    let exrCubeRenderTarget = pmremGenerator.fromEquirectangular(texture);
                    let exrBackground = exrCubeRenderTarget.texture;


                    let bg = scene.background;
                    let e = scene.environment;
                    scene.background = exrBackground;
                    scene.environment = exrBackground;
                    if(e !== bg) if(bg) bg.dispose();
                    if(e) e.dispose();
                    texture.dispose();
                });
            });
        }
    }
    */

    setupObj(obj, options) {
        if (options.dataScale) {
            obj.scale.set(...options.dataScale);
        } else {
            let size = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, 0, 0);
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Box3().setFromObject(obj).getSize(size);
            let max = Math.max(size.x, size.y, size.z);
            let s = 4 / max;
            obj.scale.set(s, s, s);
            // this is sent by all views at this moment
            this.say("dataScaleComputed", [s, s, s]);
        }
        if (options.dataTranslation) {
            obj.position.set(...options.dataTranslation);
        }
        if (options.dataRotation) {
            let d = (options.dataRotation.length === 3) ? (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(...options.dataRotation) : options.dataRotation;
            obj.quaternion.set(...d);
        }
    }

    objectCreated() {
    }

    roundedCornerGeometry(width, height, depth, cornerRadius) {
        let x = height / 2;
        let y = width / 2;
        let z = depth / 2;
        let radius = cornerRadius === undefined ? 0 : cornerRadius;

        let shape = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Shape();
        shape.moveTo(-x, -y + radius);
        shape.lineTo(-x,  y - radius);
        shape.quadraticCurveTo(-x, y, -x + radius, y);
        shape.lineTo(x - radius, y);
        shape.quadraticCurveTo(x, y, x, y - radius);
        shape.lineTo(x, -y + radius);
        shape.quadraticCurveTo(x, -y, x - radius, -y);
        shape.lineTo(-x + radius, -y);
        shape.quadraticCurveTo( -x, -y, -x, -y + radius);

        let extrudePath = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.LineCurve3(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, 0, z), new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, 0, -z));
        extrudePath.arcLengthDivisions = 3;
        let geometry = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.ExtrudeGeometry(shape, {extrudePath});

        geometry.parameters.width = width;
        geometry.parameters.height = height;
        geometry.parameters.depth = depth;

        let normalizeUV = (uvArray, bb) => {
            let w = bb.max.x - bb.min.x;
            let h = bb.max.y - bb.min.y;
            if (w && h) {
                let wScale = 1;
                let hScale = 1;
                if (h > w) hScale = h / w;
                else if (w > h) wScale = w / h;
                for (let i = 0; i < uvArray.length; i += 2) {
                    uvArray[i  ] = uvArray[i  ] * wScale + 0.5;
                    uvArray[i+1] = uvArray[i+1] * hScale + 0.5;
                }
            }
        };

        let boundingBox = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Box3(
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(-x, -y, -z),
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3( x,  y,  z));

        let uv = geometry.getAttribute('uv');
        normalizeUV(uv.array, boundingBox);
        return geometry;
    }

    makePlaneMaterial(depth, color, frameColor, fullBright) {
        if (this.material) {
            this.material.dispose();
        }
        let material;
        if (!fullBright) {
            material = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshPhongMaterial({color:color, side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.FrontSide});
        } else {
            material = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshBasicMaterial({color:color, side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.FrontSide, toneMapped: false});
        }

        if (depth > 0) {
            let second;
            second = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshPhongMaterial({color: frameColor, side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.FrontSide});
            material = [material, second ];
        }

        this.material = material;
        if (Array.isArray(this.material)) {
            this.material.dispose = arrayDispose;
        }
        return material;
    }

    isDataId(name) {
        return !(name.startsWith("http://") ||
                 name.startsWith("https://") ||
                 name.startsWith(".") ||
                 name.startsWith("/"));
    }

    getBuffer(name) {
        if (!this.isDataId(name)) {
            return fetch(name)
                .then((resp) => resp.arrayBuffer())
                .then((arrayBuffer) => new Uint8Array(arrayBuffer));
        } else {
            let handle = _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Data.fromId(name);
            return _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Data.fetch(this.sessionId, handle);
        }
    }

    cardDataUpdated(data) {
        // it might be independently implemented in a behavior, and independently subscribed

        if (this.didPropertyChange(data, ["type", "dataLocation", "dataRotation", "dataScale"])) return this.updateShape();

        if (data.v.type !== "2d") {return;}
        let obj = this.shape.children.find((o) => o.name === "2d");
        if (!obj || !obj.children || obj.children.length === 0) {return;}
        obj = obj.children[0];
        if (this.didPropertyChange(data, ["depth", "width", "height", "color", "frameColor", "cornerRadius", "fullBright"])) {
            let {depth, width, height, color, frameColor, cornerRadius, fullBright} = data.v;

            depth = (depth !== undefined) ? depth : 0.05;
            width = (width !== undefined) ? width : 1;
            height = (height !== undefined) ? height : 1;
            color = color || 0xFFFFFF;
            frameColor = frameColor || 0x666666;
            cornerRadius = cornerRadius !== undefined ? cornerRadius : 0;
            fullBright = fullBright !== undefined ? fullBright : false;

            let material = this.makePlaneMaterial(depth, color, frameColor, fullBright);

            if (this.didPropertyChange(data, ["depth", "width", "height", "cornerRadius"])) {
                let geometry = this.roundedCornerGeometry(width, height, depth, cornerRadius)
                obj.geometry = geometry;
            }
            obj.material = material;
        }
    }

    // TODO: move this to utility function in Worldcore (kernel/src/Utilities.js)
    didPropertyChange({ o, v }, propertyName) {
        if (Array.isArray(propertyName)) {
            return propertyName.some((name) => o[name] !== v[name]);
        } else {
            return o[propertyName] !== v[propertyName];
        }
    }

    uv2xy(uv) {
        return this.actor.uv2xy(uv);
    }

    /*
    onPointerWheel(e) {
        let wheel = e.deltaY;
        let s = this.scale;
        let w = wheel < 0 ? -0.1 : 0.1;
        if (s[0] + w > 0.3) {
            this.scaleTo([s[0] + w, s[1] + w, s[2] + w], 100);
        }
    }
    */

    onPointerDoubleDown(pe) {
        if (!pe.targetId) {return;}
        let pose = this.getJumpToPose ? this.getJumpToPose() : null;
        if (pose) {
            pe.xyz = pose[0]; // world coordinates
            pe.offset = pose[1]; // distance from target
            pe.look = true;
        } else {
            // pe.offset = Constants.EYE_HEIGHT; // filled in by the receiving side
        }
        this.publish(pe.avatarId, "goThere", pe);
    }

    showControls(actorInfo) {
        this.say("showControls", actorInfo);
    }

    // compute and return the position and distance the avatar should jump to to see the card full screen
    getJumpToPose() {
        if(!this.isFlat) return null;
        let current = this.renderObject.localToWorld(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3()).toArray(); // this is where the card is
        let renderer = this.service("ThreeRenderManager");
        let camera = renderer.camera;
        let caspect = camera.aspect;
        let cWidth = renderer.canvas.width;
        let cHeight = renderer.canvas.height;

        let base = (cHeight / 2) * Math.sqrt(3); // when fov is 60 deg; subject to change

        let temp = this.renderObject.matrix;
        let size = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, 0, 0);
        try {
            let scale = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, 0, 0);
            scale.setFromMatrixScale(temp);
            let mat4 = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Matrix4();
            mat4.makeScale(scale.x, scale.y, scale.z);
            this.renderObject.matrix = mat4;
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Box3().setFromObject(this.renderObject).getSize(size);
        } finally {
            this.renderObject.matrix = temp;
        }
        let taspect = size.x / size.y;

        let d = taspect < caspect ? (size.y * base) / cHeight : (size.x * base) / cWidth;
        return [current, d * 1.1];
    }

    verticalNorm(norm){
        let normal = [...norm];
        normal[1] = 0;

        let nsq = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sqrMag)(normal);
        if(nsq < 0.001){
            normal[0] = 0;
            normal[1] = norm[1];
            normal[2] = 0;
        }
        return (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_normalize)(normal);
    }

    dragPlane(rayCaster, p3e){
        // XYZZY the flamingo does not follow the cursor when dragging in the plane.
        if(!this._plane) {
            let normal = p3e.normal || p3e.lookNormal; // normal may not exist
            normal = this.verticalNorm( normal );

            let offset = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_dot)(p3e.xyz, normal);
            this._plane = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(...normal), -offset);
            this.lastDrag = p3e.xyz;
            this._startTranslation = this._translation;
        }
        let p = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3();
        rayCaster.ray.intersectPlane(this._plane, p);
        let here = p.toArray();
        let delta = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sub)(this.lastDrag, here);
        this.set({translation: (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sub)(this._startTranslation, delta)});
    }

    rotatePlane(rayCaster, p3e){
        if(!this._plane) {
            // first
            let normal = [...p3e.lookNormal];
            normal[1] = 0;
            // let nsq = v3_sqrMag(normal);
            normal = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_normalize)(normal);
            let offset = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_dot)(p3e.xyz, normal);
            this._plane = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(...normal), -offset);
            this.startDrag = p3e.xyz;
            this.baseRotation = this._rotation;
            this.rotAngle = 0;
        }
        let p = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3();
        rayCaster.ray.intersectPlane(this._plane, p);
        let here = p.toArray();
        let delta = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sub)(this.startDrag, here);
        delta[1] = 0;
        let angle = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_magnitude)(delta);
        let sign = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_cross)(p3e.lookNormal, delta)[1];
        if(sign < 0)angle = -angle;
        let qAngle = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0,angle,0);
        this.set({rotation: (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_multiply)(this.baseRotation, qAngle)});
    }

    runAnimation() {
        const spec = this.animationSpec;
        if (!spec) return;

        const { mixer, startTime, lastTime } = spec;
        const now = this.now();
        const newTime = (now - startTime) / 1000, delta = newTime - lastTime;
        mixer.update(delta);
        spec.lastTime = newTime;

        this.future(1000 / 20).runAnimation();
    }

    selectEdit() {
        this.say('selectEdit');
    }

    unselectEdit() {
        this.say('unselectEdit')
        delete this._plane;
    }

    doSelectEdit() {
        console.log("doSelectEdit")
        if (this.renderObject) {
            this.addWire(this.renderObject);
        }
    }

    doUnselectEdit() {
        console.log("doUnselectEdit")
        if (this.renderObject) {
            this.removeWire(this.renderObject);
        }
    }

    nop() {}

    addWire(obj3d) {
        let parts = [];
        let lines = [];

        obj3d.traverse((obj)=>{
            if(obj.geometry){
                let edges = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.EdgesGeometry(obj.geometry);
                let line = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.LineSegments( edges, new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.LineBasicMaterial( { color: 0x44ff44} ));
                line.raycast = function(){};
                lines.push(line);
                let m = obj.material;
                let mat;
                if(Array.isArray(m))mat = m;
                else mat = [m];

                mat.forEach(m=>{
                    let c = m.color;
                    if(c && !m._oldColor) { // check for reused color
                        m._oldColor = c;
                        let gray = (c.r * 0.299 + c.g * 0.587 + c.b * 0.114) * 0.50;
                        m.color = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Color(gray, gray, gray);
                    }
                })
                parts.push( obj );
            }
        });
        for(let i = 0; i < lines.length; i++){
            let line = lines[i];
            line.type = '_lineHighlight';
            parts[i].add(line);
        }
    }

    removeWire(obj3d) {
        let lines = [];
        let mat;
        obj3d.traverse((obj)=>{
            if(obj.type === '_lineHighlight') {
                lines.push(obj);
            } else if(obj.geometry) {
                mat = (Array.isArray(obj.material)) ? obj.material : [obj.material];
                mat.dispose = arrayDispose;
                //console.log("removeWire, material",mat);
                mat.forEach(m=>{
                    if(m._oldColor) {
                        m.color = m._oldColor;
                        delete m._oldColor;
                    }
                });
            }
        });
        for(let i = 0; i < lines.length;i++) {
            let line = lines[i];
            line.removeFromParent();
            line.geometry.dispose();
            line.material.dispose();
        }
    }

    saveCard(data) {
        if (data.viewId !== this.viewId) {return;}

        let cardsMap = this.actor.allChildrenMap();
        let saver = new _worldSaver_js__WEBPACK_IMPORTED_MODULE_7__.WorldSaver(CardActor);
        let json = {};
        let cards = saver.collectData(cardsMap);
        delete cards[0].card.parent;
        json.cards = cards;

        let allModules = [];

        cards.forEach((spec) => {
            if (spec.card.behaviorModules) {
                allModules.push(...spec.card.behaviorModules);
            }
        });

        let modules = this.actor.behaviorManager.save(allModules)
        json.behaviorModules = modules;

        if (_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.UserRapier) {
            json.useRapier = true;
        }

        let string = saver.stringify(json);
        let name = this.actor._name || "card";
        let result = {name, version: "1", data: JSON.parse(string)};

        let div = document.createElement("a");
        let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(result, null, 4));
        div.setAttribute("href", dataStr);
        div.setAttribute("download", `${name}.vrse`);
        div.click();
    }
}

class MicroverseAppManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ModelService {
    init(_options) {
        super.init("MicroverseAppManager");
        // this.$apps = options.registry; // new Map() {[name]: cls}
    }

    add(_cls) {
        // this.set(cls.name, cls);
    }
    set(_name, _cls) {
        // this.$apps.set(name, cls);
    }
    get(name) {
        // return this.$apps.get(name);
        try {
            return this.constructor.classFromID(name);
        } catch (e) {}
        return null;
    }
    delete(_name) {
        // return this.$apps.delete(name);
    }
}

MicroverseAppManager.register("MicroverseAppManager");

class VideoManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ViewService {
    constructor(name) {
        super(name || "VideoManager");
        this.videos = [];
        this.handler = () => this.videoStart();
        document.addEventListener("click", this.handler);
    }

    add(video) {
        if (this.videos.indexOf(video) < 0) {
            this.videos.push(video);
        }
    }

    videoStart() {
        this.videos.forEach((v)=>v.play());
        if (this.handler) {
            document.removeEventListener('click', this.handler);
            delete this.handler;
        }
    }
}

function arrayDispose() {
    if (Array.isArray(this)) {
        this.forEach((e) => e.dispose());
    } else {
        this.dispose();
    }
}



/***/ }),

/***/ "./src/text/text-commands.js":
/*!***********************************!*\
  !*** ./src/text/text-commands.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "canonicalizeKeyboardEvent": () => (/* binding */ canonicalizeKeyboardEvent),
/* harmony export */   "defaultCommands": () => (/* binding */ defaultCommands),
/* harmony export */   "defaultKeyBindings": () => (/* binding */ defaultKeyBindings),
/* harmony export */   "lookup": () => (/* binding */ lookup)
/* harmony export */ });
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// helper

function maybeSelectCommentOrLine(morph) {
  // Dan's famous selection behvior! Here it goes...
  /*   If you click to the right of '//' in the following...
  'wrong' // 'try this'.slice(4)  //should print 'this'
  'http://zork'.slice(7)          //should print 'zork'
  */
  // If click is in comment, just select that part
  var sel = morph.selection,
      {row, column} = sel.lead,
      text = morph.selectionOrLineString();

  if (!sel.isEmpty()) return;

  // text now equals the text of the current line, now look for JS comment
  var idx = text.indexOf('//');
  if (idx === -1                          // Didn't find '//' comment
      || column < idx                 // the click was before the comment
      || (idx>0 && (':"'+"'").indexOf(text[idx-1]) >=0)    // weird cases
      ) { morph.selectLine(row); return }

  // Select and return the text between the comment slashes and end of method
  sel.range = {start: {row, column: idx + 2}, end: {row, column: text.length}};
}

function doEval(morph, range, additionalOpts, code) {
  if (!range)
    range = morph.selection.isEmpty() ? morph.lineRange() : morph.selection.range;
  if (!code)
    code = morph.textInRange(range)
  // eval code here
}


// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// commands

let textCommands = {
    "clipboard copy": {
        doc: "placeholder for native copy",
        exec: text => false
    },

    "clipboard cut": {
        doc: "placeholder for native cut",
        exec: text => false
    },

    "clipboard paste": {
        doc: "placeholder for native paste",
        exec: text => false
    },
};

let jsEditorCommands = {
    "doit": {
        doc: "Evaluates the selected code or the current line and report the result",
        exec: async (text, opts, count = 1) => {
            maybeSelectCommentOrLine(text);
            let result, err;
            try {
                opts = Object.assign({}, opts, {inspect: true, inspectDepth: count});
                result = await doEval(text, undefined, opts);
                err = result.isError ? result.value : null;
            } catch (e) { err = e; }
            if (err) console.log('**' + err);
            return result;
        }
    },

    "printit": {
        doc: "Evaluates selected code or the current line and inserts the result in a printed representation",
        exec: async (text, opts) => {
            // opts = {targetModule}
            maybeSelectCommentOrLine(text);
            let result, err;
            try {
                opts = Object.assign({}, opts, {asString: true});
                result = await doEval(text, undefined, opts);
                err = result.isError ? result.value : null;
            } catch (e) { err = e; }
            text.selection.collapseToEnd();
            text.insertTextAndSelect(err ?
                                     String(err) + (err.stack ? "\n" + err.stack : "") :
                                     String(result.value));
            return result;
        }
    },
};

const defaultCommands = Object.assign({}, textCommands, jsEditorCommands);

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// keybindings

const defaultKeyBindings = [
  {keys: {mac: 'Meta-C', win: 'Ctrl-C'}, command: "clipboard copy"},
  {keys: {mac: 'Meta-X', win: 'Ctrl-X'}, command: "clipboard cut"},
  {keys: {mac: 'Meta-V', win: 'Ctrl-V'}, command: "clipboard paste"},

  {keys: {mac: 'Meta-Z', win: 'Ctrl-Z'}, command: "text undo"},
  //{keys: {mac: 'Meta-Shift-Z', win: 'Ctrl-Shift-Z'}, command: "text redo"},

  {keys: {mac: 'Meta-D', win:  'Ctrl-D'}, command: "doit"},
  {keys: {mac: 'Meta-P', win: 'Ctrl-P'}, command: "printit"},
  {keys: {mac: 'Meta-S', win: 'Ctrl-S'}, command: "save"},
];

function lookup(evt, bindings) {
    for (let i = 0; i < bindings.length; i++) {
        let b = bindings[i];
        let keys = b.keys;
        // use bowser for real
        for (let k in keys) {
            if (keys[k] === evt.keyCombo) {
                return b.command;
            }
        }
    }
    return null;
}

let keyMods = [
    [""],
    ["shift"],
    ["alt"],
    ["alt", "shift"],
    ["ctrl"],
    ["ctrl", "shift"],
    ["ctrl", "alt"],
    ["ctrl", "alt", "shift"],
    ["meta"],
    ["meta", "shift"],
    ["meta", "alt"],
    ["meta", "alt", "shift"],
    ["meta", "ctrl"],
    ["meta", "ctrl", "shift"],
    ["meta", "ctrl", "alt"],
    ["meta", "shift", "alt", "shift"]];

let modMap = {"shift": 1,
              "alt":2, "option":2,
              "control":4, "ctrl": 4,
              "super":8,"win":8,"meta":8,"command":8,"cmd":8};

let isNumber = function (key) {
    return /^[0-9]+$/.test(key);
};

function isModifier(key) {
    if (isNumber(key)) return false;
    key = key.replace(/-$/, "").toLowerCase();
    return !!modMap[key];
}

function cap(str) {
    return str[0].toUpperCase() + str.slice(1);
}

function canonicalizeFunctionKey(key) {
    key = key.toLowerCase();
    switch (key) {
    case 'space':
        key = "space";
        break;
    case 'esc':
        key = "escape";
        break;
    case 'return':
        key = "enter";
        break;
    case 'arrowleft':
        key = "left";
        break;
    case 'arrowright':
        key = "right";
        break;
    case 'arrowup':
        key = "up";
        break;
    case 'arrowdown':
        key = "down";
        break;
    default:
        break;
    }

    let function_keys = [
        "backspace", "tab", "enter", "pause", "escape", " ", "pageup", "pagedown", "end", "home", "left", "up", "right", "down", "print", "insert", "delete", "numpad0", "numpad1", "numpad2", "numpad3", "numpad4", "numpad5", "numpad6", "numpad7", "numpad8", "numpad9", "numpadenter", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "numlock", "scrolllock"];

    if (function_keys.includes(key)) {
        return cap(key);
    }
    return "";
}

function decodeKeyIdentifier(identifier, keyCode) {
    // trying to find out what the String representation of the key pressed
    // in key event is.
    // Uses keyIdentifier which can be Unicode like "U+0021"

    let id = identifier,
        unicodeDecodeRe = /u\+?([\d\w]{4})/gi,
        unicodeReplacer = (match, grp) => {
            return String.fromCharCode(parseInt(grp, 16));
        },
    key = id && id.replace(unicodeDecodeRe, unicodeReplacer);

    if (key === 'Command' || key === 'Cmd') key = "Meta";
    if (key === ' ') key = "Space";
    if (keyCode === 8 /*KEY_BACKSPACE*/) key = "Backspace";
    return key;
}

function identifyKeyFromCode(evt) {
    let code = evt.code;

    // works on Chrome and Safari
    // https://developer.mozilla.org/en/docs/Web/API/KeyboardEvent/code
    // For certain inputs evt.key or keyCode will return the inserted char, not
    // the key pressed. For keybindings it is nicer to have the actual key,
    // however

    if (typeof code !== "string") return null;

    if (code.startsWith("Key")) return code.slice(3);
    if (code.startsWith("Numpad")) return code;
    if (code.startsWith("Digit")) return code.slice(5);
    if (code.startsWith("Arrow")) return code.slice(5);
    if (code.match(/^F[0-9]{1-2}$/)) return code;

    switch (code) {
    case "Insert":
    case "Home":
    case "PageUp":
    case "PageDown":
        return code;
    case 'Period':
        return ".";
    case 'Comma':
        return ",";
    case 'Help':
        return "Insert";
    case 'Equal':
        return "=";
    case 'Backslash':
    case 'IntlBackslash':
        return "\\";
    case "Minus":
        return "-";
    case "BracketRight":
        return "]";
    case "BracketLeft":
        return "[";
    case "Quote":
        return "'";
    case 'Backquote':
        return "`";
    case 'Semicolon':
        return ";";
    default:
        return null;
    }
}

function eventToKeyCombo(bitMask, onlyModifiers, evt) {
    let key = evt.key,
        keyIdentifier = evt.keyIdentifier;

    let arrows = ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"];
    let controls = [10, 13, 8, 46];

    if (arrows.indexOf(evt.key) >= 0) {
        return evt.key;
    }

    if (controls.indexOf(evt.keyCode) >= 0) {
        return evt.key;
    }

    if (bitMask === 0 || bitMask === 1) {return null;}

    // fallback to keyIdentifier for Safari...
    if (!key && keyIdentifier) {
        key = decodeKeyIdentifier(keyIdentifier, evt.which || evt.keyCode);
        evt.key = key = key[evt.shiftKey ? "toUpperCase" : "toLowerCase"]();
        if (isModifier(key)) {return cap(key[0]);}
    }

    let mods = keyMods[bitMask];

    if (evt.code) {
        key = identifyKeyFromCode(evt) || key;
    }

    let keyCombo = mods.map(cap).join('-');
    if (!onlyModifiers) {
        keyCombo += key ? "-" + key : "";
    }
    return keyCombo;
}

function canonicalizeKeyboardEvent(evt) {
    let bitMask = 0;
    let spec = {
        keyCombo: "",
        key: '',
        shiftKey: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        altGraphKey: false,
        isFunctionKey: false,
        isModified: false,
        onlyModifiers: false,
        onlyShiftModifier: null,
        type: evt.type,
        keyCode: evt.keyCode
    };

    Object.keys(modMap).forEach(k => {
        let key = k + "Key";
        if (evt[key]) {
            bitMask |= modMap[k];
            spec[key] = true;
        }
    });

    if (modMap[evt.key.toLowerCase()]) {
        spec.onlyModifiers = true;
    }

    let keyCombo = eventToKeyCombo(bitMask, spec.onlyModifiers, evt);

    if (!keyCombo) {return null;}

    if (bitMask === 0 || bitMask === 1) {
        // 2. Are any modifier keys pressed?
        spec.keyCombo = keyCombo;
        spec.key = evt.key;
        if (bitMask === 1) {
            spec.onlyShiftModifier = true;
            spec.isModified = true;
        }
        return spec;
    }

    if (bitMask > 1) {
        spec.isModified = true;
    }

    if (spec.onlyModifiers) {
        spec.keyCombo = keyCombo;
        spec.key = evt.key;
        spec.onlyModifiers = true;
        return spec;
    }

    // 3. determine the key code and key string of the event.
    let fnKey = canonicalizeFunctionKey(evt.key);
    if (fnKey) {
        spec.isFunctionKey = true;
        spec.key = fnKey;
    } else if (spec.isModified) {
        if (spec.onlyShiftModifier) {
            spec.key = evt.key;
        } else {
            spec.key = evt.key[0].toUpperCase() + evt.key.slice(1);
        }
    } else {
        return null;
        // spec.key = evt.key;
    }

    spec.keyCombo = keyCombo;
    return spec;
}


/***/ }),

/***/ "./src/text/text.js":
/*!**************************!*\
  !*** ./src/text/text.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

var _assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DismissButtonPawn": () => (/* binding */ DismissButtonPawn),
/* harmony export */   "FontModelManager": () => (/* binding */ FontModelManager),
/* harmony export */   "FontViewManager": () => (/* binding */ FontViewManager),
/* harmony export */   "KeyFocusManager": () => (/* binding */ KeyFocusManager),
/* harmony export */   "SyncedStateManager": () => (/* binding */ SyncedStateManager),
/* harmony export */   "TextFieldActor": () => (/* binding */ TextFieldActor),
/* harmony export */   "TextFieldPawn": () => (/* binding */ TextFieldPawn)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
/* harmony import */ var _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @croquet/worldcore-three */ "./node_modules/@croquet/worldcore-three/index.js");
/* harmony import */ var _croquet_hybrid_msdf_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @croquet/hybrid-msdf-text */ "./node_modules/@croquet/hybrid-msdf-text/index.js");
/* harmony import */ var _card_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../card.js */ "./src/card.js");
/* harmony import */ var load_bmfont__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! load-bmfont */ "./node_modules/load-bmfont/browser.js");
/* harmony import */ var load_bmfont__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(load_bmfont__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../assets/fonts/Roboto.json */ "./assets/fonts/Roboto.json");
/* harmony import */ var _warota_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./warota.js */ "./src/text/warota.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io











// "Text Scale" to reconcile the bitmap font size, which is typically in the range of 50 pixels, and the 3D geometry size, which we tend to think one unit equates to a meter.
const TS = 0.0025;

const defaultModelMeasurer = new ((0,_croquet_hybrid_msdf_text__WEBPACK_IMPORTED_MODULE_2__.getTextLayout)(_croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE))({font: /*#__PURE__*/ (_assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache || (_assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache = __webpack_require__.t(_assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5__, 2)))});

class KeyFocusManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ViewService {
    constructor(name) {
        super(name || "KeyFocusManager");
        this.setKeyboardInput(null);

        this.hiddenInput = document.querySelector("#hiddenInput");
        this.copyElement = document.querySelector("#copyElement");

        if (!this.hiddenInput) {
            this.hiddenInput = document.createElement("input");
            this.hiddenInput.id = "hiddenInput";
            this.hiddenInput.style.setProperty("position", "absolute");

            this.hiddenInput.style.setProperty("left", "-120px"); //-120px
            this.hiddenInput.style.setProperty("top", "-120px");  // -120px
            this.hiddenInput.style.setProperty("transform", "scale(0)"); // to make sure the user never sees a flashing caret, for example on iPad/Safari

            this.hiddenInput.style.setProperty("width", "100px");
            this.hiddenInput.style.setProperty("height", "100px");
            document.body.appendChild(this.hiddenInput);

            this.hiddenInput.addEventListener("input", evt => {
                evt.stopPropagation();
                if (!this.keyboardInput) {return;}
                this.keyboardInput.input(evt);
            }, true);

            this.hiddenInput.addEventListener("keydown", evt => {
                evt.stopPropagation();
                if (!this.keyboardInput) {return;}
                this.keyboardInput.keyDown(evt);
            }, true);

            this.hiddenInput.addEventListener("copy", evt => {
                if (!this.keyboardInput) {return;}
                this.keyboardInput.copy(evt);
            });

            this.hiddenInput.addEventListener("paste", evt => {
                if (!this.keyboardInput) {return;}
                this.keyboardInput.paste(evt);
            });
        }

        if (!this.copyElement) {
            this.copyElement = document.createElement("input");
            this.copyElement.id = "copyElement";
            this.copyElement.style.setProperty("position", "absolute");

            this.copyElement.style.setProperty("left", "-120px"); //-120px
            this.copyElement.style.setProperty("top", "-120px");  // -120px
            this.copyElement.style.setProperty("transform", "scale(0)"); // to make sure the user never sees a flashing caret, for example on iPad/Safari

            this.copyElement.style.setProperty("width", "100px");
            this.copyElement.style.setProperty("height", "100px");
            document.body.appendChild(this.copyElement);
        }
    }

    setKeyboardInput(obj) {
        if (this.hiddenInput && !obj) {
            this.hiddenInput.blur();
        }
        this.keyboardInput = obj;
        if (obj) {
            this.hiddenInput.focus();
        }
    }

    destroy() {
        this.keyboardInput = null;

        this.hiddenInput = document.querySelector("#hiddenInput");

        if (this.hiddenInput) {
            this.hiddenInput.remove();
        }
        super.destroy();
    }
}

class SyncedStateManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ViewService {
    constructor(name) {
        super(name || "SyncedStateManager");
        this.isSynced = false;
        this.subscribe(this.viewId, "synced", "synced");
    }

    synced(value) {
        console.log("synced manager", value);
        this.isSynced = value;
        // If a view object can handle synced, they can do it directly
        // so there is no need to indirect it from here.
        // this.publish(this.id, "synced", value);
    }
}

class FontModelManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ModelService {
    static defaultFont() {return "Roboto";}
    init(name) {
        super.init(name || "FontModelManager");
        this.fonts = new Map();

        let {chars, common, info, kernings, pages} = /*#__PURE__*/ (_assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache || (_assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5___namespace_cache = __webpack_require__.t(_assets_fonts_Roboto_json__WEBPACK_IMPORTED_MODULE_5__, 2)));
        this.askFont({name: info.face, font: {chars, common, info, kernings, pages}});
        this.subscribe(this.id, "askFont", this.askFont);

        this.loading = new Map();

        this.subscribe(this.id, "fontLoadStart", "fontLoadStart");
        this.subscribe(this.id, "fontLoadOne", "fontLoadOne");
        this.subscribe(this.id, "fontLoadDone", "fontLoadDone");

    }

    get(name) {
        return this.fonts.get(name);
    }

    keys() {
        return this.fonts.keys();
    }

    askFont(data) {
        if (data.font) {
            this.fonts.set(data.name, data.font);
        }
        this.publish(this.id, "fontAsked", data.name);
    }

    fontLoadStart({key, name}) {
        this.loading.set(key, {name, array: []});
    }

    fontLoadOne({key, buf}) {
        let data = this.loading.get(key);
        if (!data) {
            console.log("inconsistent message");
            return;
        }

        data.array.push(buf);
    }

    fontLoadDone(key) {
        let data = this.loading.get(key);
        if (!data) {
            console.log("inconsistent message");
            return;
        }

        let ary = data.array;

        let len = ary.reduce((acc, cur) => acc + cur.length, 0);

        let all = new Uint8Array(len);

        let ind = 0;

        for (let i = 0; i < ary.length; i++) {
            all.set(ary[i], ind);
            ind += ary[i].length;
        }

        let result = new TextDecoder("utf-8").decode(all);
        let font = JSON.parse(result);
        this.askFont({name: data.name, font});
        this.loading.delete(key);
    }
}

FontModelManager.register("FontModelManager");

class FontViewManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ViewService {
    constructor(options, name) {
        super(name || "FontViewManager");
        this.fonts = new Map(); // {texture, _material}
        this.isLoading = {};
        this.fudgeFactors = new Map();
        this.fudgeFactors.set("Roboto", {yoffset: 30});
    }

    setModel(model) {
        this.model = model;
        for (let [name, font] of this.model.fonts.entries()) {
            this.askFont(name, font);
        }
    }

    get(name) {
        return this.fonts.get(name);
    }

    askFont(name, optFont) {
        if (this.fonts.get(name)) {return Promise.resolve(this.fonts.get(name));}
        if (this.isLoading[name]) {return this.isLoading[name];}

        let path = "./assets/fonts";
        let image = `${path}/${name}.png`;

        if (optFont) {
            this.isLoading[name] = Promise.resolve(optFont);
        } else {
            this.isLoading[name] = new Promise((resolve, reject) => {
                load_bmfont__WEBPACK_IMPORTED_MODULE_4___default()(`${path}/${name}.json`, (err, font) => {
                    if (err) reject(err);
                    resolve(font);
                })
            });
        }

        this.isLoading[name] = this.isLoading[name].then((font) => {
            let loader = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.TextureLoader();
            return new Promise((resolve, reject) => {
                loader.load(
                    image,
                    (tex) => {
                        let preprocessor = new _croquet_hybrid_msdf_text__WEBPACK_IMPORTED_MODULE_2__.MSDFFontPreprocessor();
                        let cWidth = font.common ? font.common.scaleW : font.atlas.width;
                        let cHeight = font.common ? font.common.scaleH : font.atlas.height;
                        let img = new Image(cWidth, cHeight);
                        let canvas = document.createElement("canvas");
                        canvas.width = cWidth;
                        canvas.height = cHeight;
                        let ctx = canvas.getContext("2d");
                        ctx.drawImage(tex.image, 0, 0);
                        let inBitmap = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        let outImage = preprocessor.process(font, inBitmap.data);
                        ctx.putImageData(outImage, 0, 0);

                        let processedTexture = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Texture(outImage);
                        processedTexture.minFilter = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.LinearMipMapLinearFilter;
                        processedTexture.magFilter = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.LinearFilter;
                        processedTexture.generateMipmaps = true;
                        processedTexture.anisotropy = 1; // maxAni

                        img.src = canvas.toDataURL("image/png");
                        img.onload = () => {
                            processedTexture.needsUpdate = true;
                        };

                        this.fonts.set(name, {font, texture: processedTexture});
                        delete this.isLoading[name];

                        let maybeFont = this.model.fonts.get(name) ? null : font;
                        if (maybeFont) {
                            this.sendLargeFont(name, font);
                        } else {
                            this.publish(this.model.id, "askFont", {name});
                        }
                        resolve(this.fonts.get(name));
                    },
                    null,
                    () => {
                        this.isLoading[name] = false;
                        reject(new Error(`failed to load font: ${name}`));
                    });
            });
        });
        return this.isLoading[name];
    }

    sendLargeFont(name, font) {
        let string = JSON.stringify(font);

        let array = new TextEncoder().encode(string);

        let ind = 0;

        let key = Math.random();

        this.publish(this.model.id, "fontLoadStart", {key, name});
        while (ind < array.length) {
            let buf = array.slice(ind, ind + 2880);
            this.publish(this.model.id, "fontLoadOne", {key, buf});
            ind += 2880;
        }

        this.publish(this.model.id, "fontLoadDone", key);
    }

    destroy() {
        this.fonts.forEach((v, _k) => {
            if (v.material) {
                v.material.dispose();
                v.material = null;
            }
        });
    }
}

class TextFieldActor extends _card_js__WEBPACK_IMPORTED_MODULE_3__.CardActor {
    init(options) {
        this.fonts = this.service("FontModelManager");
        this.doc = new _warota_js__WEBPACK_IMPORTED_MODULE_6__.Doc({defaultFont: this.fonts.constructor.defaultFont(), defaultSize: 10});
        this.doc.load(options.runs || []);
        // this.doc.load([
        // {text: "ab c ke eke ekeke ekek eke ek eke ke ek eke ek ek ee  ke kee ke", style: {size: 24}},
        // ]);

        this.content = {runs: [], selections: {}, undoStacks: {}, timezone: 0, queue: [], editable: true};

        if (!options.textScale) {
            options.textScale =  TS;
        }

        super.init(options);
        this.subscribe(this.id, "load", "loadAndReset");
        this.subscribe(this.id, "editEvents", "receiveEditEvents");
        this.subscribe(this.id, "accept", "publishAccept");
        this.subscribe(this.id, "undoRequest", "undoRequest");
        this.subscribe(this.id, "setExtent", "setExtent");
        this.subscribe(this.sessionId, "view-exit", "viewExit");

        this.listen("dismiss", "dismiss");

        // the height part of this is optional, in the sense that the view may do something else

        let textWidth = options.width / options.textScale;
        let textHeight = options.height / options.textScale;
        this.setExtent({width: textWidth, height: textHeight});

        this.depth = options.depth || 0;

        if (!options.noDismissButton) {
            // that means that a change in readOnly should trigger this
            this.setupDismissButton();
        }

        if (options.readOnly) {
            let margins = options.margins;
            let marginsLeft = margins && margins.left !== undefined ? margins.left : 0;
            let marginsRight = margins && margins.right !== undefined ? margins.right : 0;

            let hMargin = marginsLeft + marginsRight;

            let measurement = defaultModelMeasurer.measureText(this.value);
            this.measurement = {
                width: (measurement.width + hMargin) * options.textScale,
                height: measurement.height * options.textScale
            };
        }
    }

    get pawn() {return TextFieldPawn;}

    static types() {
        return {"Warota.Doc": _warota_js__WEBPACK_IMPORTED_MODULE_6__.Doc};
    }

    load(stringOrArray) {
        let runs;
        if (typeof stringOrArray === "string") {
            runs = [{text: stringOrArray}];
        } else {
            runs = stringOrArray;
        }
        this.doc.load(runs);
        this.publishChanged();
        this.needsUpdate();
    }

    save() {
        return {runs: this.doc.runs, defaultFont: this.doc.defaultFont, defaultSize: this.doc.defaultSize};
    }

    setExtent(ext) {
        this.extent = ext;
    }

    loadAndReset(stringOrArray) {
        let runs;
        if (typeof stringOrArray === "string") {
            runs = [{text: stringOrArray}];
        } else {
            runs = stringOrArray;
        }
        this.content = {runs: runs, selections: {}, undoStacks: {}, timezone: 0, queue: [], editable: true};
        this.doc.load(runs);
        this.publishAccept();
        this.needsUpdate();
    }

    receiveEditEvents(events) {
        let [_timezone, hasDone] = this.doc.receiveEditEvents(events, this.content, this.doc);
        if (hasDone) {
            this.publishChanged();
        }

        this.needsUpdate();
    }

    publishAccept() {
        this.publish(this.id, "text", {id: this.id, text: this.doc.plainText()});
    }

    publishChanged() {
        this.publish(this.id, "changed", {id: this.id});
    }

    viewExit(viewId) {
        // we might have to clear the events of Warota in the view?
        delete this.content.selections[viewId];
        this.needsUpdate();
    }

    needsUpdate() {
        this.say("screenUpdate", this.content.timezone);
    }

    undoRequest(user) {
        let event;
        let queue = this.content.queue;
        for (let i = queue.length - 1; i >= 0; i--) {
            let e = queue[i];
            if (e.user.id === user.id && (e.type !== "snapshot" && e.type !== "select")) {
                event = queue[i];
                break;
            }
        }
        if (!event) {return;}

        this.doc.undoEvent(event, this.content, this.doc);
        this.needsUpdate();
    }

    setDefault(font, size) {
        return this.doc.setDefault(font, size);
    }

    styleAt(index) {
        return this.doc.styleAt(index);
    }

    updateOptions(options) {
        super.updateOptions(options);
        let textWidth = options.width / options.textScale;
        let textHeight = options.height / options.textScale;
        this.setExtent({width: textWidth, height: textHeight});
        if (this.dismissButton) {
            this.dismissButton.destroy();
        }
        if (!options.noDismissButton) {
            this.setupDismissButton();
        }
    }

    get value() {
        return this.doc.plainText();
    }

    set value(text) {
        return this.load(text);
    }

    setupDismissButton() {
        this.dismissButton = DismissButtonActor.create({
            type: "object",
            backgroundColor: this._cardData.backgroundColor,
            parent: this,
            translation: this.dismissButtonPosition(),
            noSave: true,
            color: 0x222222});
        /*

        this.createCard({
            translation: this.dismissButtonPosition(),
            name: 'dismiss text',
            behaviorModules: ["PropertySheetDismiss"],
            parent: this,
            type: "object",
            noSave: true,
            backgroundColor: this._cardData.backgroundColor,
            color: 0x222222
        });
        */

        this.subscribe(this.dismissButton.id, "dismiss", "dismiss");
    }

    dismissButtonPosition() {
        return [this._cardData.width / 2 - (0.072), this._cardData.height / 2 - (0.072), 0.06];
    }

    dismiss() {
        this.destroy();
    }
}

TextFieldActor.register("TextFieldActor");

class TextFieldPawn extends _card_js__WEBPACK_IMPORTED_MODULE_3__.CardPawn {
    constructor(actor) {
        super(actor);

        this.addToLayers("pointer");

        this.widgets = {};
        this.setupEditor();
        this.setupMesh();

        this.fonts = this.service("FontViewManager");

        this.listen("fontAsked", "fontAsked");
        this.listen("screenUpdate", "screenUpdate");

        this.setupFonts();
        this.addEventListener("pointerDown", "onPointerDown");
        this.addEventListener("pointerMove", "onPointerMove");
        this.addEventListener("pointerUp", "onPointerUp");
        this.addEventListener("keyDown", "keyDown");

        this.listen("cardDataSet", "cardDataUpdated");
    }

    destroy() {
        ["geometry", "material", "textGeometry", "textMaterial"].forEach((n) => {
            if (this[n]) {
                this[n].dispose();
            }
            this[n] = null;
        });
        super.destroy();
    }

    textScale() {
        return this.actor._cardData.textScale;
    }

    test() {
        // this.warota.insert(user, [{text: cEvt.key}]);
    }

    needsUpdate() {
        this.screenUpdate(this.warota.timezone);
    }

    randomColor(viewId) {
        let h = Math.floor(parseInt(viewId, 36) / (36 ** 10 / 360));
        let s = "40%";
        let l = "40%";
        return `hsl(${h}, ${s}, ${l})`;
    }

    cardDataUpdated(data) {
        if (data.o.backgroundColor !== data.v.backgroundColor || data.o.frameColor !== data.v.frameColor || data.o.fullBright !== data.v.fullBright) {
            let {depth, backgroundColor, frameColor, fullBright} = data.v;
            this.material = this.makePlaneMaterial(depth, backgroundColor, frameColor, fullBright);
            this.plane.material = this.material;
        }
    }

    changeMaterial(name, makeNew) {
        // we may still able to share the same material for all text instances
        // when we revive onbeforerender.
        if (this.textMaterial) {
            this.textMaterial.dispose();
        }
        let textMesh;
        if (!this.fonts.get(name)) {return;}
        let texture = this.fonts.get(name).texture;
        this.textMaterial = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.RawShaderMaterial((0,_croquet_hybrid_msdf_text__WEBPACK_IMPORTED_MODULE_2__.HybridMSDFShader)({
            map: texture,
            textureSize: texture.image.width,
            side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DoubleSide,
            transparent: true,
        }, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE));

        if (makeNew) {
            textMesh = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(this.textGeometry, this.textMaterial);
            textMesh.name = "text";
        }
        return textMesh;
    }

    setupFonts() {
        let fontName = this.actor.doc.defaultFont;
        this.fontAsked(fontName).then(() => {
            let fonts = Array.from(this.actor.fonts.keys());
            let ps = fonts.map((v) => this.fonts.askFont(v));
            return Promise.all(ps);
        }).then(() => {
            this.warota.resetMeasurer();
            this.needsUpdate();
        });
    }

    setupTextMesh(name, font) {
        if (!this.textGeometry) {
            let TextGeometry = (0,_croquet_hybrid_msdf_text__WEBPACK_IMPORTED_MODULE_2__.getTextGeometry)(_croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE);
            this.textGeometry = new TextGeometry({});

            this.textMesh = this.changeMaterial(name, true);
            this.plane.add(this.textMesh);
        }

        let layout = _warota_js__WEBPACK_IMPORTED_MODULE_6__.fontRegistry.hasLayout(name);
        if (!layout) {
            let TextLayout = (0,_croquet_hybrid_msdf_text__WEBPACK_IMPORTED_MODULE_2__.getTextLayout)(_croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE);
            layout = new TextLayout({font});
            _warota_js__WEBPACK_IMPORTED_MODULE_6__.fontRegistry.addLayout(name, layout);
        }
    }

    setupScrollMesh() {
        let geom = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneGeometry(0.1, 5);
        let mat = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshBasicMaterial({color: 0xFF0000, side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DoubleSide});
        this.scrollMesh = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(geom, mat);
        this.scrollMesh.name = "scroll";
        this.scrollMesh.position.set(2.5, 0, 0.001);

        let knobGeom = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneGeometry(0.1, 0.1);
        let knobMat = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshBasicMaterial({color: 0x00FF00, side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DoubleSide});
        this.scrollKnobMesh = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(knobGeom, knobMat);
        this.scrollKnobMesh.name = "scrollKnob";

        this.scrollKnobMesh.position.set(0, 2.5, 0.001);
        this.scrollMesh.add(this.scrollKnobMesh);
        this.plane.add(this.scrollMesh);
    }

    updateMesh(stringInfo) {
        let {fontName, drawnStrings} = stringInfo;
        if (!this.fonts.get(fontName)) {return;}
        let font = this.fonts.get(fontName).font;

        let fudgeFactor = this.fonts.fudgeFactors.get(fontName);

        let layout = _warota_js__WEBPACK_IMPORTED_MODULE_6__.fontRegistry.hasLayout(fontName);
        if (!layout) {return;}

        let glyphs = layout.computeGlyphs({font, drawnStrings, fudgeFactor});

        this.textMesh.scale.x = this.textScale();
        this.textMesh.scale.y = -this.textScale();
        this.textGeometry.update({font, glyphs});
    }

    updateShape(options) {
        super.updateShape(options);
        ["geometry", "material", "textGeometry", "textMaterial"].forEach((n) => {
            if (this[n]) {
                this[n].dispose();
            }
            this[n] = null;
        });

        this.setupMesh();
        this.setupFonts();
    }

    setupMesh() {
        let depth = this.actor._cardData.depth || 0.01;
        let cornerRadius = this.actor._cardData.cornerRadius || 0.05;
        let {backgroundColor, frameColor, fullBright} = this.actor._cardData;

        if (!backgroundColor) {
            backgroundColor = 0xFFFFFF;
        }
        if (!frameColor) {
            frameColor = 0x666666;
        }
        if (fullBright === undefined) {
            fullBright = false;
        }
        if (depth === 0) {
            this.geometry = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneGeometry(0, 0);
        } else {
            this.geometry = this.roundedCornerGeometry(0, 0, depth, cornerRadius);
        }

        let material = this.makePlaneMaterial(depth, backgroundColor, frameColor, fullBright);
        this.material = material;
        this.plane = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(this.geometry, this.material);
        this.plane.castShadow = true;
        this.plane.name = this.actor.name;
        this.shape.add(this.plane);

        this.clippingPlanes = [
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, 1, 0),  0),
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, -1, 0), 0),
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(-1, 0, 0), 0),
            new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(1, 0, 0), 0)
        ];
    }

    setupEditor() {
        let font = this.actor.doc.defaultFont;
        let fontSize = this.actor.doc.defaultSize;
        let extent = this.actor.extent;
        let autoResize = this.actor._cardData.autoResize;
        let singleLine = this.actor._cardData.singleLine;
        let margins =  this.actor._cardData.margins;
        let options = {width: extent.width, height: extent.height, font, fontSize, autoResize, singleLine, margins};

        this.warota = new _warota_js__WEBPACK_IMPORTED_MODULE_6__.Warota(options, this.actor.doc);
        this.warota.width(extent.width);
        this.options = options;

        this.user = {id: this.viewId, color: this.randomColor(this.viewId)};
        this.selections = {}; // {user: {bar: mesh, boxes: [mesh]}}

        this.subscribe(this.viewId, "synced", "synced");
    }

    fontAsked(fontName) {
        return this.fonts.askFont(fontName).then((font) => {
            return this.setupTextMesh(fontName, font.font);
        }).then(() => {
            this.warota.resetMeasurer();
            return this.screenUpdate(this.warota.timezone);
        });
    }

    computeClippingPlanes(ary) {
        //let [top, bottom, right, left] = ary; this is the order
        let planes = [];
        let text = this.plane;
        if (Number.isNaN(text.matrixWorld.elements[0])) return [];
        for (let i = 0; i < 4; i++) {
            planes[i] = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane();
            planes[i].copy(this.clippingPlanes[i]);
            planes[i].constant = ary[i];
            planes[i].applyMatrix4(text.matrixWorld);
        }
        return planes;
    }

    setWidth(pixels) {
        this.publish(this.actor.id, "setWidth", pixels);
        this.width(pixels);
    }

    width(pixels) {
        this.warota.width(pixels);
        this.screenUpdate(this.warota.timezone);
    }

    synced(value) {
        this.isSynced = value;
        if (!this.isSynced) {return;}
        this.warota.resetMeasurer();
        this.screenUpdate(this.warota.timezone);
    }

    getSynced() {
        let sm = this.service("SyncedStateManager");
        if (sm) {
            return sm.isSynced;
        }

        return this.isSynced;
    }

    accept() {
        this.publish(this.actor.id, "accept");
    }

    cookEvent(evt) {
        if (!evt.xyz) {return;}
        let vec = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(...evt.xyz);
        let inv = this.renderObject.matrixWorld.clone().invert();
        let vec2 = vec.applyMatrix4(inv);

        let width = this.plane.geometry.parameters.width;
        let height = this.plane.geometry.parameters.height;

        let x = ((width / 2) + vec2.x) / this.textScale();
        let y = ((height / 2) - vec2.y) / this.textScale();

        return {x, y};
    }

    onPointerDown(evt) {
        if (this.actor._cardData.readOnly) {return;}
        let fm = this.service("KeyFocusManager");
        fm.setKeyboardInput(this);

        let cooked = this.cookEvent(evt);
        if (!cooked) {return;}
        this.warota.mouseDown(cooked.x, cooked.y, cooked.y, this.user);
    }

    onPointerMove(evt) {
        if (this.actor._cardData.readOnly) {return;}
        let cooked = this.cookEvent(evt);
        if (!cooked) {return;}
        this.warota.mouseMove(Math.max(cooked.x, 0), cooked.y, cooked.y, this.user);
        this.changed();
    }

    onPointerUp(evt) {
        if (this.actor._cardData.readOnly) {return;}
        let cooked = this.cookEvent(evt);
        if (!cooked) {return;}
        this.warota.mouseUp(cooked.x, cooked.y, cooked.y, this.user);
        this.changed();
    }

    newCanonicalizeEvent(evt) {
        if (evt.type === "input" && evt.inputType === "insertText" && !evt.isComposing) {
            let fm = this.service("KeyFocusManager");
            let key = fm.hiddenInput.value;
            fm.hiddenInput.value = "";
            let spec = {
                keyCombo: "",
                key: key,
                shiftKey: false,
                altKey: false,
                ctrlKey: false,
                metaKey: false,
                altGraphKey: false,
                isFunctionKey: false,
                isModified: false,
                onlyModifiers: false,
                onlyShiftModifier: null,
                type: evt.type,
                keyCode: evt.keyCode
            };
            return spec;
        }
        return null;
    }

    eventFromField() {
        let fm = this.service("KeyFocusManager");
        let key = fm.hiddenInput.value;
        fm.hiddenInput.value = "";
        let spec = {
            keyCombo: "",
            key: key,
            shiftKey: false,
            altKey: false,
            ctrlKey: false,
            metaKey: false,
            altGraphKey: false,
            isFunctionKey: false,
            isModified: false,
            onlyModifiers: false,
            onlyShiftModifier: null,
            type: "",
            keyCode: 0
        };
        return spec;
    }

    simpleInput(text, evt) {
        let user = this.user;
        let selection = this.actor.content.selections[this.viewId];
        let style = this.actor.styleAt(Math.max(selection ? selection.start - 1 : 0, 0));

        this.warota.insert(user, [{text, style}]);
        this.changed(true);
        evt.preventDefault();
        return true;
    }

    input(evt) {
        if (this.actor._cardData.readOnly) {return;}
        let cEvt = this.newCanonicalizeEvent(evt);
        if (!cEvt) {return false;}
        let user = this.user;
        let selection = this.actor.content.selections[this.viewId];
        let style = this.actor.styleAt(Math.max(selection ? selection.start - 1 : 0, 0));
        this.warota.insert(user, [{text: cEvt.key, style: style}]);
        this.changed(true);
        evt.preventDefault();
        return true;
    }

    keyDown(evt) {
        let cEvt;
        if (evt.key === "Enter") {
            let hiddenInput = this.service("KeyFocusManager").hiddenInput;
            if (hiddenInput.value !== "") {
                hiddenInput.value = "";
                cEvt = this.eventFromField();
            } else {
                cEvt = (0,_warota_js__WEBPACK_IMPORTED_MODULE_6__.canonicalizeKeyboardEvent)(evt);
            }
        } else {
            cEvt = (0,_warota_js__WEBPACK_IMPORTED_MODULE_6__.canonicalizeKeyboardEvent)(evt);
        }

        let user = this.user;
        if (!cEvt) {return true;}

        if (cEvt.onlyModifiers) {return true;}

        // what has to happen here is that the kinds of keycombo that browser need to pass
        // through, and the kinds that the editor handles are different.
        // We need to separated them, and for the latter, the text commands list has
        // to be tested here.
        if (cEvt.keyCombo === "Meta-S" || cEvt.keyCombo === "Ctrl-S") {
            this.accept();
            evt.preventDefault();
            return true;
        }

        if (cEvt.keyCombo === "Meta-Z" || cEvt.keyCombo === "Ctrl-Z") {
            this.undo();
            evt.preventDefault();
            return true;
        }

        if (cEvt.keyCombo === "Meta-C" || cEvt.keyCombo === "Ctrl-C") {
            this.copy();
            evt.preventDefault();
            return true;
        }

        if (cEvt.keyCombo === "Meta-X" || cEvt.keyCombo === "Ctrl-X") {
            this.cut();
            evt.preventDefault();
            return true;
        }

        if (cEvt.keyCombo === "Meta-V" || cEvt.keyCombo === "Ctrl-V") {
            this.paste();
            evt.preventDefault();
            return true;
        }

        if (cEvt.keyCode === 13) {
            if (this.actor["enterToAccept"]) {
                evt.preventDefault();
                this.accept();
                return true;
            }
            return this.simpleInput("\n", evt);
        }
        if (cEvt.keyCode === 32) {
            return this.simpleInput(" ", evt);
        }
        if (cEvt.keyCode === 9) {
            return this.simpleInput("\t", evt);
        }

        const handled = this.warota.handleKey(user, cEvt.keyCode, cEvt.shiftKey, cEvt.ctrlKey || cEvt.metaKey);

        if (!handled && !(cEvt.ctrlKey || cEvt.metaKey)) {
            this.warota.insert(user, [{text: cEvt.key}]);
            this.changed(true);
            evt.preventDefault();
            return true;
        }
        if (handled) {
            evt.preventDefault();
            this.changed(true);
        }
        return false;
    }

    copy(_evt) {
        let isiOSDevice = navigator.userAgent.match(/ipad|iphone/i);
        let text = this.warota.selectionText(this.user);

        let clipboardAPI = () => {
            if (navigator.clipboard) {
                return navigator.clipboard.writeText(text).then(() => true, () => false);
            }
            return Promise.resolve(false);
        };

        clipboardAPI().then((result) => {
            if (!result) {
                let { copyElement } = this.service("KeyFocusManager");

                if (!isiOSDevice) {
                    copyElement.value = text;
                    copyElement.select();
                    copyElement.setSelectionRange(0, 99999);
                    document.execCommand("copy");
                    return;
                }

                let range = document.createRange();
                range.selectNodeContents(copyElement);
                copyElement.textContent = text;

                let selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                copyElement.setSelectionRange(0, 100000);
                document.execCommand('copy');
            }
        });
    }

    cut(evt) {
        this.copy(evt);
        this.warota.insert(this.user, [{text: ""}]);//or something else to keep undo sane?
        this.changed(true);
        return true;
    }

    paste(_evt) {
        //let isiOSDevice = navigator.userAgent.match(/ipad|iphone/i);

        let clipboardAPI = () => {
            if (navigator.clipboard) {
                return navigator.clipboard.readText().then((text) => text, () => null);
            }
            return Promise.resolve(null);
        };

        return clipboardAPI().then((result) => {
            if (result === null) {
                let { copyElement } = this.service("KeyFocusManager");
                copyElement.focus();
                copyElement.textContent = "";
                document.execCommand("paste");
                return copyElement.textContent;
            }
            return result;
        }).then((text) => {
            this.warota.insert(this.user, [{text: text}]);
            // evtxo.preventDefault();
            this.changed(true);
        });
    }

    undo() {
        this.publish(this.actor.id, "undoRequest", this.user);
    }

    changed(toScroll) {
        let events = this.warota.events;
        this.warota.resetEvents();
        if (events.length > 0) {
            this.scrollNeeded = !this.singleLine && toScroll;
            this.publish(this.actor.id, "editEvents", events);
        }
    }

    screenUpdate(timezone) {
        this.warota.timezone = timezone;
        if (!this.getSynced()) {return;}
        this.warota.layout();
        this.showText();
        this.setExtent();
        this.showSelections();
        if (this.scrollNeeded) {
            this.scrollNeeded = false;
            this.scrollSelectionToView();
        }
    }

    showText() {
        let drawnStrings = [];
        for (let i = 0; i < this.warota.words.length - 1; i++) {
            let word = this.warota.words[i];
            let str = {
                x: word.left,
                y: word.top,
                string: word.text,
                style: word.style && word.style.color
            };
            drawnStrings.push(str);
        }

        let extent = this.actor.extent;

        this.updateMesh({fontName: this.warota.doc.defaultFont, extent, drawnStrings});
    }

    setStyle(style) {
        this.warota.setStyle(this.user, style, false);
        this.changed();
    }

    mergeStyle(style) {
        this.warota.setStyle(this.user, style, true);
        this.changed();
    }

    setExtent() {
        let extent = this.actor.extent;
        let depth = this.actor.depth;
        let cornerRadius = this.actor._cardData.cornerRadius || 0.05;
        let autoResize = this.actor._cardData.autoResize;
        if (!this.textMesh) {return;}
        let newWidth = (autoResize ? this.warota.newWidth : extent.width) * this.textScale();
        let newHeight = (autoResize ? this.warota.docHeight : extent.height) * this.textScale();
        if (newWidth !== this.plane.geometry.parameters.width ||
            newHeight !== this.plane.geometry.parameters.height ||
            depth !== this.plane.geometry.parameters.depth) {
            let geometry = depth === 0 ? new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneGeometry(newWidth, newHeight) : this.roundedCornerGeometry(newWidth, newHeight, depth, cornerRadius);
            this.plane.geometry = geometry;
            this.geometry.dispose();
            this.geometry = geometry;
        }

        this.textMesh.position.x = -newWidth / 2;
        this.textMesh.position.y = newHeight / 2;
        this.textMesh.position.z = depth + 0.005;

        let bounds = {left: 0, top: 0, bottom: newHeight / this.textScale(), right: newWidth / this.textScale()};
        this.textMesh.material.uniforms.corners.value = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector4(bounds.left, bounds.top, bounds.right, bounds.bottom);
    }

    ensureSelection(id) {
        let sel = this.selections[id];
        let modelSel = this.actor.content.selections[id];
        let color = modelSel.color;
        if (!color) {
            color = "blue";
        }
        if (!sel) {
            const bar = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneBufferGeometry(0.1, 0.1), new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshBasicMaterial({color}));

            bar.onBeforeRender = this.selectionBeforeRender.bind(this);

            bar.visible = false;
            this.plane.add(bar);
            bar.name = "caret";
            // plane.onBeforeRender = this.selectionBeforeRender.bind(this);

            let boxes = [];
            for (let i = 0; i < 3; i++) {
                let box = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneBufferGeometry(0, 0), new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshBasicMaterial({color}));
                box.onBeforeRender = this.selectionBeforeRender.bind(this);
                box.visible = false;
                box.name = `box${i}`;
                this.plane.add(box);
                boxes.push(box);
            }
            sel = {bar, boxes};
        }
        this.selections[id] = sel;
        return sel;
    }

    showSelections() {
        let depth = this.actor.depth || 0;
        let unused = {};
        for (let k in this.selections) {
            unused[k] = this.selections[k];
        }

        let ts = this.textScale();

        for (let k in this.actor.content.selections) {
            delete unused[k];
            let thisSelection = this.ensureSelection(k);
            thisSelection.boxes.forEach(box => box.visible = false);
            let selection = this.actor.content.selections[k];

            let width = this.plane.geometry.parameters.width;
            let height = this.plane.geometry.parameters.height;

            if (selection.end === selection.start) {
                let caret = thisSelection.bar;
                caret.visible = true;
                let caretRect = this.warota.barRect(selection);
                caretRect.width = ts <= 0.001 ? 5 : 2;
                let geom = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneBufferGeometry(caretRect.width * ts, caretRect.height * ts);
                let old = caret.geometry;
                caret.geometry = geom;
                if (old) {
                    old.dispose();
                }

                let left = (-width / 2) + (caretRect.left + 6) * ts; // ?
                let top = (height / 2) - (caretRect.top + caretRect.height / 2 + 4) * ts;
                caret.position.set(left, top, depth + 0.001);
            } else {
                let rects = this.warota.selectionRects(selection);
                let boxes = thisSelection.boxes;
                for (let i = 0; i < 3; i++) {
                    let box = boxes[i];
                    let rect = rects[i];
                    box.visible = false;

                    if (rect) {
                        let left = (-width / 2) + ((rect.width / 2) + rect.left + 8) * ts; // ?
                        let top = (height / 2) - (rect.top + rect.height / 2 + 4) * ts;
                        let rWidth = rect.width * ts; // ?
                        let rHeight = rect.height * ts;

                        let geom = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.PlaneBufferGeometry(rWidth, rHeight, 2, 2);
                        box.geometry = geom;
                        box.position.set(left, top, depth + 0.001);
                        box.visible = true;
                    }
                }
            }
        }
        for (let k in unused) {
            this.selections[k].bar.remove();
            this.selections[k].boxes.forEach(box => box.remove());
            delete this.selections[k];
        }
        this.publish(this.id, "selectionUpdated");
    }

    scrollSelectionToView() {
        /*
        let scrollTop = this.dom.scrollTop;
        let viewHeight = parseFloat(this.dom.style.getPropertyValue("height"));
        let selection = this.model.content.selections[this.viewId];
        if (!selection) {return;}
        if (selection.end !== selection.start) {return;}
        let caretRect = this.warota.barRect(selection);

        if (caretRect.top + caretRect.height > viewHeight + scrollTop) {
            this.dom.scrollTop = caretRect.top + caretRect.height - viewHeight;
        } else if (caretRect.top < scrollTop) {
            this.dom.scrollTop = caretRect.top;
        }
        */
    }

    selectionBeforeRender(renderer, scene, camera, geometry, material, _group) {
        /*
        let meterInPixel = this.model.extent.width / 0.01;
        let scrollT = this.warota.scrollTop;
        let docHeight = this.warota.docHeight;
        let docInMeter = docHeight * meterInPixel;
        let top = -scrollT * docHeight;
        let bottom = -(top - 0.01);
        let right = 0.01 * (1.0 - this.warota.relativeScrollBarWidth);
        let left = 0;
        */

        let left = 2.5;
        let right = 2.5;
        let bottom = 2.5;
        let top = 2.5;
        let planes = this.computeClippingPlanes([top, bottom, right, left]);
        material.clippingPlanes = planes;
    }

    addWidget(name, dom) {
        if (this.widgets[name]) {
            this.removeWidget(name, dom);
        }
        this.widgets[name] = dom;
        this.selectionPane.appendChild(dom);
    }

    removeWidget(name, dom) {
        delete this.widgets[name];
        dom.remove();
    }

    get hitNormal() {
        return [0, 0, 1];
    }
}

class DismissButtonActor extends _card_js__WEBPACK_IMPORTED_MODULE_3__.CardActor {
    init(options) {
        super.init({...options, multiusser: true});
    }

    get pawn() {return DismissButtonPawn;}
}

DismissButtonActor.register("DismissButtonActor");

class DismissButtonPawn extends _card_js__WEBPACK_IMPORTED_MODULE_3__.CardPawn {
    constructor(actor) {
        super(actor);
        this.addToLayers("pointer");

        if (this.back) {
            this.shape.remove(this.back);
            this.shape.children = [];
        }

        let backgroundColor = (this.actor._cardData.backgroundColor !== undefined)
            ? this.actor._cardData.backgroundColor
            : 0xcccccc;

        let color = (this.actor._cardData.color !== undefined)
            ? this.actor._cardData.color
            : 0x222222;

        let backGeometry = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.BoxGeometry(0.08, 0.08, 0.00001);
        let backMaterial = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshStandardMaterial({
            color: backgroundColor,
            side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DoubleSide
        });

        this.back = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(backGeometry, backMaterial);

        let dismissGeometry = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.BoxGeometry(0.07, 0.02, 0.001);
        let dismissMaterial = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.MeshStandardMaterial({
            color: color,
            side: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DoubleSide
        });

        let button = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Mesh(dismissGeometry, dismissMaterial);
        button.position.set(0, 0, 0.00001);

        this.back.add(button)

        this.shape.add(this.back);

        this.addEventListener("pointerDown", "dismiss");
    }

    dismiss(_evt) {
        this.publish(this.actor.id, "dismiss");
    }
}


/***/ }),

/***/ "./src/text/warota.js":
/*!****************************!*\
  !*** ./src/text/warota.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Doc": () => (/* binding */ Doc),
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "Measurer": () => (/* reexport safe */ _wrap_js__WEBPACK_IMPORTED_MODULE_0__.Measurer),
/* harmony export */   "Warota": () => (/* binding */ Warota),
/* harmony export */   "Wrap": () => (/* reexport safe */ _wrap_js__WEBPACK_IMPORTED_MODULE_0__.Wrap),
/* harmony export */   "canonicalizeKeyboardEvent": () => (/* reexport safe */ _text_commands_js__WEBPACK_IMPORTED_MODULE_1__.canonicalizeKeyboardEvent),
/* harmony export */   "eof": () => (/* reexport safe */ _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof),
/* harmony export */   "equalStyle": () => (/* reexport safe */ _wrap_js__WEBPACK_IMPORTED_MODULE_0__.equalStyle),
/* harmony export */   "fontRegistry": () => (/* reexport safe */ _wrap_js__WEBPACK_IMPORTED_MODULE_0__.fontRegistry),
/* harmony export */   "isNewline": () => (/* reexport safe */ _wrap_js__WEBPACK_IMPORTED_MODULE_0__.isNewline),
/* harmony export */   "setLastFontLoadedTime": () => (/* binding */ setLastFontLoadedTime)
/* harmony export */ });
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap.js */ "./src/text/wrap.js");
/* harmony import */ var _text_commands_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text-commands.js */ "./src/text/text-commands.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io






// import MockContext from "./MockContext.js";

let lastFontLoadedTime = 0;
function setLastFontLoadedTime(ms) {
    lastFontLoadedTime = ms;
}

function runLength(ary) {
    return ary.map(c => c.text).reduce((s, x) => x.length + s, 0);
}

class Doc {
    constructor(options) {
        this.runs = []; // [{text: str, (opt)style: {(opt)font: str, (opt)size: num, (opt)color: str, (opt)bold: boolean, (opt)italic: boolean}}]
        this.intervals = []; // [{start: num, end: num}]
        this.selections = {}; // {user: {start: num, end: num, isBol: boolean, color: string}}

        this.defaultFont = options.defaultFont || "Roboto";
        this.defaultSize = options.defaultSize || 10;
        // After the canonicalization step, the intervals and runs at least has one element
        // that denotes the end of file
    }

    load(runs) {
        // runs does not have start and end (human would not want to add them by hand).
        // The canonicalize method adds them. save() strip them out.
        this.canonicalize(runs);
    }

    setDefault(font, size) {
        this.defaultFont = font || this.defaultFont;
        this.defaultSize = size || this.defaultSize;
    }

    doEvent(evt) {
        if (evt.type === "insert") {
            this.doInsert(evt.user, evt.runs);
        } else if (evt.type === "delete") {
            this.doDelete(evt.user, evt.backspace);
        } else if (evt.type === "select") {
            this.doSelect(evt.user, evt.start, evt.end, evt.isBol);
        } else if (evt.type === "setStyle") {
            this.doSetStyle(evt.user, evt.style, evt.merge);
        }
    }

    doInsert(user, runs) {
        // runs: [{text: <string>, (opt)style: {}}]
        let selection = this.ensureSelection(user);
        let enter = runs.length > 0 && runs[runs.length - 1].text === "\n";
        if (selection.start === selection.end) {
            let [_run, runIndex] = this.findRun(selection.start);
            let interval = this.intervals[runIndex];
            if (interval.end !== selection.start && interval.start !== selection.start) {
                // that is, pos is within the run
                this.splitRunAt(runIndex, selection.start - interval.start);
                runIndex += 1;
            } else if (interval.end === selection.start) {
                runIndex += 1;
            }
            this.runs.splice(runIndex, 0, ...runs);
            this.canonicalize(this.runs, interval.start);
            this.updateSelectionsInsert(user, selection.start, runLength(runs), enter);
        } else {
            this.doDelete(user, true);
            this.doInsert(user, runs);
        }
    }

    doDelete(user, isBackspace) {
        let selection = this.ensureSelection(user);
        let start, end;
        let length = this.length();

        if (selection.start === selection.end) {
            if ((!isBackspace && selection.start === length)
               || (isBackspace && selection.start === 0)) {
                return;
            }

            if (isBackspace) {
                start = selection.start - 1;
                end = selection.end;
            } else {
                start = selection.start;
                end = selection.end + 1;
            }
        } else {
            start = selection.start;
            end = selection.end;
        }

        let [_run, runIndex] = this.findRun(start);
        let interval = this.intervals[runIndex];

        if (interval.end !== start) { // that is, pos is within the run
            this.splitRunAt(runIndex, start - interval.start);
            // here, previous run ends at pos. and next one starts at pos.
            runIndex += 1;
        }

        let [_endRun, endRunIndex] = this.findRun(end);
        let endRunInterval = this.intervals[endRunIndex];

        let reminder = end - endRunInterval.start;
        if (end !== endRunInterval.end && reminder !== 0) {
            this.splitRunAt(endRunIndex, reminder);
            endRunIndex += 1;
        } else if (end === endRunInterval.end) {
            endRunIndex += 1;
        }

        this.runs.splice(runIndex, endRunIndex - runIndex);
        this.canonicalize(this.runs);
        this.updateSelectionsDelete(user, start, end);
    }

    doSelect(user, start, end, isBol) {
        this.selections[user.id] = {start, end, isBol, color: user.color};
    }

    doSetStyle(user, style, merge) {
        let selection = this.selections[user.id];
        if (selection.start === selection.end) {return;}

        let start = selection.start;
        let end = selection.end;

        // first
        let [run, runIndex] = this.findRun(start);
        let interval = this.intervals[runIndex];

        if (interval.start !== start) {
            this.splitRunAt(runIndex, start - interval.start);
        }

        // end
        [run, runIndex] = this.findRun(end);
        interval = this.intervals[runIndex];
        if (interval.end !== end) {
            this.splitRunAt(runIndex, end - interval.start);
        }

        let s = start;
        let count = 0;
        while (s < end && count < 10000) {
            count++;
            [run, runIndex] = this.findRun(s);
            interval = this.intervals[runIndex];
            if (interval.end <= end) {
                let newStyle = merge ? {...run.style, ...style} : {...style};
                run.style = newStyle;
                s = interval.end;
            }
        }
        this.canonicalize(this.runs);
    }

    length() {
        // excludes eof
        return this.intervals[this.intervals.length - 1].end - 1;
    }

    copyRun(run) {
        if (!run) {return run;}
        let obj = {};
        obj.text = run.text;
        if (run.style) {
            obj.style = run.style;
        }
        return obj;
    }

    canonicalize(runs) {
        // there are two cases: whether the runs has eof or not
        let result = [];
        let newIntervals = [];

        let start = 0;

        let addEOF = () => {
            result.push({text: _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof});
            newIntervals.push({start: start, end: start + 1});
        };

        if (runs.length === 0) {
            addEOF();
            this.runs = result;
            this.intervals = newIntervals;
            return;
        }

        let lastRun = this.copyRun(runs[0]);

        let i = 1;
        let run = this.copyRun(runs[i]);
        while (run && run.text !== _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof) {
            if ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.equalStyle)(lastRun.style, run.style)) {
                lastRun.text += run.text;
            } else {
                let end = start + lastRun.text.length;
                let interval = {start, end};
                start = end;
                result.push(lastRun);
                newIntervals.push(interval);
                lastRun = run;
            }
            i++;
            run = this.copyRun(runs[i]);
        }
        let end = start + lastRun.text.length;
        let interval = {start, end};
        result.push(lastRun);
        newIntervals.push(interval);
        start = end;

        if (result[result.length - 1].text !== _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof) {
            addEOF();
        }
        this.runs = result;
        this.intervals = newIntervals;
    }

    styleAt(index) {
        let [startRun, _startRunIndex] = this.findRun(index);
        return startRun.style;
    }

    save(optStart, optEnd) {
        // intervals is dropped as an external form
        let runs = this.runs;
        let intervals = this.intervals;
        let start = optStart !== undefined ? optStart : 0;
        let end = optEnd !== undefined ? optEnd : this.length();
        let startRun, startRunIndex;
        let endRun, endRunIndex;
        let run, obj, interval;
        [startRun, startRunIndex] = this.findRun(start);
        [endRun, endRunIndex] = this.findRun(end);

        if (startRunIndex === endRunIndex) {
            interval = intervals[startRunIndex];
            obj = this.copyRun({text: startRun.text.slice(start - interval.start, end - interval.start)});
            return [obj];
        }

        let result = [];
        run = startRun;
        interval = intervals[startRunIndex];

        obj = this.copyRun({text: run.text.slice(start - interval.start)}, true);
        result.push(obj);

        for (let i = startRunIndex + 1; i <= endRunIndex - 1; i++) {
            obj = this.copyRun(runs[i]);
            result.push(obj);
        }

        interval = intervals[endRunIndex];

        obj = this.copyRun({text: endRun.text.slice(0, end - interval.start)});
        if (obj.text !== _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof) {
            result.push(obj);
        }
        return result;
    }

    plainText(optStart, optEnd) {
        return this.save(optStart, optEnd).map(c => c.text).join('');
    }

    splitRunAt(runIndex, sizeInRun) {
        let run = this.runs[runIndex];
        let interval = this.intervals[runIndex];

        let one = this.copyRun({text: run.text.slice(0, sizeInRun),
                                style: run.style});
        let two = this.copyRun({text: run.text.slice(sizeInRun, run.text.length),
                                style: run.style});
        this.runs.splice(runIndex, 1, one, two);

        one = {start: interval.start, end: interval.start + sizeInRun};
        two = {start: interval.start + sizeInRun, end: interval.end};
        this.intervals.splice(runIndex, 1, one, two);
    }

    findRun(pos) {
        let runs = this.runs;
        let intervals = this.intervals;
        let interval;
        for (let ind = 0; ind < runs.length; ind++) {
            interval = intervals[ind];
            if (interval.start <= pos && pos < interval.end) {
                return [runs[ind], ind];
            }
        }
        if (pos === interval.end) {
            return [runs[runs.length - 1], runs.length - 1];
        }
        return [null, null];
    }

    updateSelectionsInsert(user, pos, length, wasEnter) {
        for (let k in this.selections) {
            let sel = this.selections[k];
            if (k === user.id) {
                this.selections[k] = {start: pos + length, end: pos + length, isBol: wasEnter, color: user.color};
            } else {
                if (pos < sel.start) {
                    this.selections[k] = {start: sel.start + length, end: sel.end + length, isBol: wasEnter, color: sel.color};
                } else if (sel.start < pos && pos < sel.end) {
                    this.selections[k] = {start: sel.start, end: sel.end + length, isBol: wasEnter, color: sel.color};
                } /*else if (sel.end <= pos) {}*/
            }
        }
    }

    updateSelectionsDelete(user, start, end) {
        let len = end - start;
        for (let k in this.selections) {
            let sel = this.selections[k];
            if (k === user.id) {
                this.selections[k] = {start, end: start, color: user.color};
            } else {
                if (end <= sel.start) {
                    this.selections[k] = {start: sel.start - len, end: sel.end - len, color: sel.color};
                } else if (sel.end <= start) {
                } else if (start <= sel.start && sel.end <= end) {
                    this.selections[k] = {start, end: start, color: sel.color};
                } else if (start < sel.start && end < sel.end) {
                    this.selections[k] = {start, end: sel.end - len, color: sel.color};
                } else if (sel.start <= start && end < sel.end) {
                    this.selections[k] = {start: sel.start, end: sel.end - len, color: sel.color};
                } else if (sel.start <= start && start < sel.end) {
                    this.selections[k] = {start: sel.start, end: start, color: sel.color};
                }
            }
            let [run, _runIndex] = this.findRun(this.selections[k].start - 1);
            this.selections[k].isBol = run && (0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.isNewline)(run.text[run.text.length - 1]);
        }
    }

    setSelections(selections) {
        this.selections = JSON.parse(JSON.stringify(selections));
    }

    getSelections() {
        return JSON.parse(JSON.stringify(this.selections));
    }

    ensureSelection(user) {
        let sel = this.selections[user.id];
        if (!sel) {
            sel = {start: 0, end: 0, color: user.id};
            this.selections[user.id] = sel;
        }
        return sel;
    }

    snapshotFrom(content, user, timezone) {
        return {type: "snapshot",
                user,
                content: {runs: content.runs,
                          selections: JSON.parse(JSON.stringify(content.selections))},
                timezone};
    }

    undoEvent(evt, content, doc) {
        let queue = content.queue;
        let user = evt.user; // {id, color}

        function findLast(q, event) {
            for (let i = q.length - 1; i >= 0; i--) {
                if (q[i].user.id === event.user.id && q[i].timezone === evt.timezone && q[i].type !== "snapshot") {
                    return i;
                }
            }
            return -1;
        }

        function findSnapshot(q, i) {
            for (; i >= 0; i--) {
                if (q[i].type === "snapshot") {
                    return i;
                }
            }
            return -1;
        }

        let undoIndex = findLast(queue, evt);
        if (undoIndex < 0) {return content.timezone;}

        let undoEvent = queue[undoIndex];
        let snapshotIndex = findSnapshot(queue, undoIndex);
        if (snapshotIndex < 0) {return content.timezone;}

        let snapshot = queue[snapshotIndex];
        let c = snapshot.content;
        doc.load(c.runs);
        doc.setSelections(c.selections);

        let newQueue = [];
        for (let i = 0; i <= snapshotIndex; i++) {
            newQueue.push(queue[i]);
        }

        for (let i = snapshotIndex + 1; i < undoIndex; i++) {
            doc.doEvent(queue[i]);
            newQueue.push(queue[i]);
        }

        for (let i = undoIndex + 1; i < queue.length; i++) {
            if (queue[i].type !== "snapshot") {
                doc.doEvent(queue[i]);
                newQueue.push(queue[i]);
            }
        }

        content.timezone++;
        undoEvent.timezone = content.timezone;
        if (!content.undoStacks[user.id]) {
            content.undoStacks[user.id] = [];
        }

        content.undoStacks[user.id].push(undoEvent);
        content.selections = doc.getSelections();
        content.runs = doc.save();
        content.queue = newQueue;
        return content.timezone;
    }

    receiveEditEvents(events, content, doc) {
        // What this method assumes, and what this method does are:
        // - edit events from a client who lagged badly won't be processed.
        // - The model maintains the timezone counter, which is incremented once for a series
        //   of edit commands from a client (effectively, once in the invocation of
        //   this method).
        // - An event sent to the model (to this method) has a timezone value,
        //   which is the value the model sent to the view as the last view update. That is,
        //   the view commands are considered to be generated in that logical timezone.
        // - When an event arrives, first the timezone of the event is checcked to see
        //   if it is still considered recent enough.
        //   -- insert and delete events use the selection value in the model;
        //      so they don't have to be transformed.  They are puhsed into the list.
        //   -- a select event may be off as there are edit events already processed;
        //      so it has to be transformed against the events in the list with the same
        //      logical time or after but already in the list.
        // - The model executes new events, and update its data structure.
        // - Then, the early elements in the list are dropped as they are deemed to be
        //   past their life.
        // - The list is a part of the saved model. It will be saved with the string content.
        // Things are all destructively updated in content,

        let CUTOFF = 60;
        let queue = content.queue;
        let user = events[0].user; // {id, color}

        if (content.timezone % (CUTOFF / 6) === 0) {
            queue.push(this.snapshotFrom(content, user, content.timezone));
        }

        content.timezone++;

        if (queue.length > 0
            && (queue[queue.length - 1].timezone > events[0].timezone + CUTOFF)) {
            return [content.timezone, false];
        }

        function findFirst(q, event) {
            if (q.length === 0) {
                return 0;
            }
            if (q[queue.length - 1].timezone < event.timezone) {
                return q.length;
            }
            for (let i = q.length - 1; i >= 0; i--) {
                if (q[i].timezone < event.timezone) {
                    return i + 1;
                }
            }
            return 0;
        }

        function transform(n, o) {
            // it already assumes that n (for new) is newer than o (for old)
            // the first empty obj in assign is not necessary; but make it easier to debug
            if (n.type === "select") {
                if (o.type === "insert") {
                    if (o.pos <= n.start) {
                        return {...n, ...{start: n.start + o.length,
                                          end: n.end + o.length}};
                    }
                    if (n.start <= o.pos && o.pos <= n.end) {
                        return {...n, ...{end: n.end + o.length}};
                    }
                    return n;
                }
                if (o.type === "delete") {
                    if (n.end <= o.start) {
                        return n;
                    }
                    if (o.start <= n.start && n.end <= o.end) {
                        // subsume
                        return {...n, ...{start: o.start, end: o.start}};
                    }
                    if (o.end <= n.start) {
                        return n;
                    }
                    if (n.start <= o.start && n.end < o.end) {
                        return {...n, ...{end: o.start}};
                    }
                    if (o.start <= n.start && o.end < n.end) {
                        return {...n, ...{start: o.start, end: n.end - o.end}};
                    }
                }
                if (o.type === "select") {
                    return n;
                }
            }
            return n;
        }

        let thisQueue = [];
        let unseenIDs = {...content.selections};

        // all events in the variable 'events' should be in the same timezone;
        // so pick the zero-th one
        let ind = findFirst(queue, events[0]);

        events.forEach(event => {
            let t = event;
            if (ind >= 0) {
                for (let i = ind; i < queue.length; i++) {
                    t = transform(t, queue[i]);
                }
            }
            t.timezone = content.timezone;
            thisQueue.push(t);
        });

        queue.push(...thisQueue);

        // finish up by dropping old events
        ind = queue.findIndex(e => e.timezone > content.timezone - CUTOFF);
        for (let i = queue.length - 1; i >= 0; i--) {
            let e = queue[i];
            delete unseenIDs[e.user.id];
        }
        for (let k in unseenIDs) {
            delete content.selections[k];
            delete content.undoStacks[k];
        }
        queue.splice(0, ind);

        doc.setSelections(content.selections);
        let hasDone = false;
        thisQueue.forEach(e => {
            hasDone = hasDone || (e.type === "insert" || e.type === "delete");
            doc.doEvent(e);
        });

        content.runs = doc.save();
        content.selections = doc.getSelections();
        return [content.timezone, hasDone];
    }
}

class Warota {
    constructor(options, optDoc) {
        this.doc = optDoc || new Doc();

        this._width = 0;
        if (options.margins) {
            this.margins = options.margins;
        } else {
            this.margins = options.margins = {left: 0, top: 0, right: 0, bottom: 0};
        }

        this.options = options;

        this.scrollLeft = 0;
        this.scrollTop = 0;
        this.relativeScrollBarWidth = 0.02;
        this.showsScrollbar = options.showScrollBar;
        this.isScrollable = true;

        this.resize(options.width, options.height);
        this.resizeToNumLinesOrFontSize(options);

        this.events = [];
        this.timezone = 0;
    }

    resetEvents() {
        this.events = [];
    }

    width(width) {
        if (width === undefined) {
            return this._width;
        }
        this._width = width;
        return null;
    }

    setTimezone(num) {
        this.timezone = num;
    }

    resize(width, height) {
        this.screenWidth = width;
        this.screenHeight = height;
    }

    resizeToNumLinesOrFontSize(options) {
        this.defaultMeasurer = new _wrap_js__WEBPACK_IMPORTED_MODULE_0__.Measurer();
        let lineHeight = this.defaultMeasurer.lineHeight(options.font, options.fontSize);
        let marginHeight = (options.margins.top + options.margins.bottom);
        let textScreenHeight = options.height - marginHeight;
        if (options.fontSize) {
            options.numLines = textScreenHeight / options.fontSize;
        } else {
            if (options.numLines) {
                options.fontSize = textScreenHeight / options.numLines;
            } else {
                options.numLines = 10;
                options.fontSize = textScreenHeight / options.numLines;
            }
        }

        let textScreenPixels = options.numLines * lineHeight;
        let heightInPixel = options.fontSize / lineHeight;
        let neededPixels = textScreenPixels + marginHeight * heightInPixel;

        this.pixelY = neededPixels;
        let scale = neededPixels / this.screenHeight;
        this.pixelX = this.screenWidth * scale;

        if (this.pixelX * this.relativeScrollBarWidth <= 30) {
            this.relativeScrollBarWidth = 30 / this.pixelX;
        }

        this.width(this.pixelX * (1.0 - (this.showsScrollbar ? this.relativeScrollBarWidth : 0)));
        this.lineHeight = lineHeight;
    }

    resetMeasurer() {
        this.defaultMeasurer = new _wrap_js__WEBPACK_IMPORTED_MODULE_0__.Measurer();
    }

    layout() {
        if (this.lastFontLoadedTimeChecked === undefined ||
            this.lastFontLoadedTimeChecked < lastFontLoadedTime) {
            this.resetMeasurer();
            this.lastFontLoadedTimeChecked = lastFontLoadedTime;
        }
        let options = this.options || {};
        let layoutWidth = options.singleLine ? Number.MAX_VALUE : this._width;
        let hMargin = this.margins.left + this.margins.right;
        let vMargin = this.margins.top + this.margins.bottom;
        let [lines, words] = new _wrap_js__WEBPACK_IMPORTED_MODULE_0__.Wrap().wrap(this.doc.runs, layoutWidth, this.defaultMeasurer, this.doc.defaultFont, this.doc.defaultSize, this.options.margins);
        this.lines = lines;
        this.words = words;

        this.hasLastEnter = false;
        if (this.lines.length - 2 >= 0) {
            let lastRealLine = this.lines[this.lines.length - 2];
            let penultimateWord = lastRealLine[lastRealLine.length - 1];
            this.hasLastEnter = (0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.isNewline)(penultimateWord.text);
        }

        let lastWord; // there should be always one
        if (options.singleLine) {
            lastWord = lines[0][lines[0].length - 1];
        } else {
            lastWord = lines[lines.length - 1][0];
        }
        if (options.autoResize) {
            this.newWidth = (lastWord.left + lastWord.width + hMargin);
            this.newHeight = (lastWord.top + lastWord.height + vMargin);
            this.docHeight = lastWord.top + lastWord.height;
        } else {
            this.docHeight = lastWord.top + lastWord.height;
        }
    }

    /*
    paint() {
        let ctx = new MockContext();
        let canvas = {width: this.pixelX, height: this.pixelY};
        let docHeight = this.docHeight;
        let absScrollTop = this.scrollTop * docHeight;
        let absScrollLeft = this.scrollLeft * this.pixelX;

        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(0, -absScrollTop);

        this.draw(ctx, {left: absScrollLeft, top: absScrollTop, width: this.pixelX, height: this.pixelY});
        this.drawSelections(ctx);

        if (this.showsScrollbar) this.drawScrollbar(ctx);

        ctx.restore();
        if (this.mockCallback) {
            this.mockCallback(ctx);
        }
        return ctx;
    }
    */

    visibleBounds() {
        let docH = this.docHeight;
        return {left: this.scrollLeft * this.pixelX, top: this.scrollTop * docH,
                width: this.pixelX, height: this.pixelY};
    }

    visibleTextBounds() {
        let r = this.visibleBounds();
        let w = r.width * (1.0 - (this.showsScrollbar ? this.relativeScrollBarWidth : 0));
        let h = r.height;
        return {l: r.left, t: r.top, w: w, h: r.height, b: r.top + h, r: r.left + w};
    }

    draw(ctx, rect) {
        let {left, top, width, height} = rect;
        this.words.forEach(word => {
            if (word.left + word.width < left || word.top > top + height
                || word.top + word.height < top || word.left > left + width) {return;}
            if (word.styles) {
                let wLeft = word.left;
                word.styles.forEach(partialStyle => {
                    ctx.fillStyle = partialStyle.style ? partialStyle.style : {color: 'black'};
                    ctx.fillText(word.text.slice(partialStyle.start, partialStyle.end), wLeft, word.top + word.ascent);
                    wLeft += partialStyle.width;
                });
            } else {
                ctx.fillStyle = word.style || 'black';
                ctx.fillText(word.text, word.left, word.top + word.ascent);
            }
        });
    }

    drawSelections(ctx) {
        ctx.save();
        for (let k in this.doc.selections) {
            let selection = this.doc.selections[k];
            if (selection.end === selection.start) {
                ctx.fillStyle = 'barSelection ' + selection.color;
                let caretRect = this.barRect(selection);
                ctx.fillRect(caretRect.left, caretRect.top, caretRect.width, caretRect.height);
            } else {
                ctx.fillStyle = 'boxSelection ' + selection.color;
                let rects = this.selectionRects(selection);
                rects.forEach(box => {
                    ctx.fillRect(box.left, box.top, box.width, box.height);
                });
            }
        }
        ctx.restore();
    }

    drawScrollbar(ctx) {
        let {l, t, h, w} = this.scrollbarBounds();
        ctx.save();
        ctx.fillStyle = "scrollBar";
        ctx.fillRect(l, 0, w, this.pixelY);

        ctx.fillStyle = "scrollKnob";
        ctx.fillRect(l + 3, t, w - 6, h);
        ctx.restore();
    }

    scrollbarBounds() {
        let {
            pixelX,
            pixelY,
            scrollTop: scrollT, // ratio into area
            relativeScrollBarWidth: relWidth,
        } = this;
        let docH = this.docHeight;
        let scrollVRatio = pixelY / docH;
        let barW = pixelX * (this.showsScrollbar ? relWidth : 0);
        let barLeft = pixelX - barW;
        let barTop = scrollT * pixelY;
        let minHeight = pixelY / 100 * 5;
        let barH = scrollVRatio > 1.0 ? pixelY - 3 : Math.max(minHeight, pixelY * scrollVRatio - 6);
        return {l: barLeft, t: barTop, w: barW, h: barH};
    }

    scrollBy(deltaX, deltaY) {
        this.setScroll(this.scrollLeft = deltaX, this.scrollTop + deltaY);
    }

    setScroll(scrollLeft, scrollTop) {
        let {pixelY, docHeight} = this;
        let max = 1.0 - pixelY / docHeight;
        this.scrollTop = Math.max(0, Math.min(max, scrollTop));
    }

    findLine(pos, x, y) {
        // a smarty way would be to do a binary search
        let lines = this.lines;
        if (x !== undefined && y !== undefined) {
            let lineIndex = lines.findIndex(line => {
                let max = line.reduce((acc, cur) => Math.max(acc, cur.height), 0);
                let w = line[0]; // should be always one
                return w.top <= y && y < w.top + max;
            });
            if (lineIndex < 0) { // should always be the past end of line.
                lineIndex = lines.length - 1;
            }
            return [lines[lineIndex], lineIndex];
        }

        let lineIndex = lines.findIndex(line => {
            let start = line[0];
            let end = line[line.length - 1];
            return start.start <= pos && pos < end.end;
        });

        if (lineIndex < 0) { // falls back on the last eof line
            lineIndex = lines.length - 1;
        }
        return [lines[lineIndex], lineIndex];
    }

    findWord(pos, x, y) {
        if (x !== undefined && y !== undefined) {
            let [line, _lineIndex] = this.findLine(pos, x, y);
            let wordIndex = line.findIndex(w => w.left <= x && x < w.left + w.width);
            if (wordIndex < 0) {
                if (x < line[0].left) {
                    wordIndex = 0;
                } else {
                    wordIndex = line.length - 1;
                }
            }
            return line[wordIndex];
        }

        let [line, _lineIndex] = this.findLine(pos, x, y);

        let wordIndex = line.findIndex(w => w.start <= pos && pos < w.end);
        if (wordIndex < 0) {
            if (x < line[0].left) {
                wordIndex = 0;
            } else {
                wordIndex = line.length - 1;
            }
        }
        return line[wordIndex];
    }

    insert(user, runs) {
        let evt = Event.insert(user, runs, this.timezone);
        this.events.push(evt);
    }

    delete(user, backspace) {
        let evt = Event.delete(user, backspace, this.timezone);
        this.events.push(evt);
    }

    select(user, start, end, isBol) {
        let evt = Event.select(user, start, end, isBol, this.timezone);
        this.lastSelect = {start, end};
        this.events.push(evt);
    }

    setStyle(user, style, merge) {
        let evt = Event.setStyle(user, style, merge);
        this.events.push(evt);
    }

    doEvent(evt) {
        this.doc.doEvent(evt);
        this.layout();
    }

    positionFromIndex(pos) {
        let word = this.findWord(pos);
        if (pos === 0 && word.text === _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof) {
            let margins = this.margins || {};
            return {
                left: 0 + (margins.left || 0),
                top: 0 + (margins.top || 0),
                width: 0,
                height: word.height
            };
        }

        let localPos = pos - word.start;
        let tmpWord = {...word};
        tmpWord.text = word.text.slice(0, localPos);
        let measure0 = this.defaultMeasurer.measureText(tmpWord, this.doc.defaultFont, this.doc.defaultSize);
        tmpWord.text = word.text.slice(0, localPos + 1);
        let measure1 = this.defaultMeasurer.measureText(tmpWord, this.doc.defaultFont, this.doc.defaultSize);
        return {left: word.left + measure0.width, top: word.top, width: measure1.width - measure0.width, height: word.height};
    }

    indexFromPosition(x, y) {
        let word = this.findWord(null, x, y);
        let last = 0;
        let lx = x - word.left;
        if (lx < 0) {return word.start;}
        if (word.text === _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof) {return word.start;}
        if ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.isNewline)(word.text)) {return word.start;}
        let tmpWord = {...word};
        for (let i = 0; i <= word.text.length; i++) {
            let measure;
            tmpWord.text = word.text.slice(0, i !== 0 ? i : 1);
            measure = this.defaultMeasurer.measureText(tmpWord, this.doc.defaultFont, this.doc.defaultSize);
            let half = (measure.width - last) / 2;
            if (last <= lx && lx < last + half) {
                return word.start + (i === 0 ? 0 : i - 1);
            }
            if (last + half <= lx && lx < measure.width) {
                return word.start + i;
            }
            last = measure.width;
        }
        return word.end;
    }

    isBol(x, y) {
        let [line, _lineIndex] = this.findLine(null, x, y);
        let word = line[0];
        if (x < word.left) {return true;}
        if (word.text === _wrap_js__WEBPACK_IMPORTED_MODULE_0__.eof) {return this.hasLastEnter;}
        let tmpWord = {...word};
        tmpWord.text = word.text.slice(0, 1);
        let measure = this.defaultMeasurer.measureText(tmpWord, this.doc.defaultFont, this.doc.defaultSize);
        let half = measure.width / 2;
        return x - word.left < half;
    }

    changeLine(user, pos, dir) {
        let [_line, lineIndex] = this.findLine(pos);
        if (dir > 0 && lineIndex === this.lines.length - 2) {
            if (this.hasLastEnter) {
                return this.lines[this.lines.length - 1][0].start;
            }
            return pos;
        }
        let rect = this.positionFromIndex(pos);
        let newLineIndex = lineIndex + dir;
        if (newLineIndex < 0) {return 0;}
        if (newLineIndex >= this.lines.length) {
            return this.lines[this.lines.length - 1][0].start;
        }
        let newLine = this.lines[newLineIndex];
        if (newLine.length === 1 && newLine[0].text.length === 1 &&
            (newLine[0].text === "\n" || newLine[0].text === "\r")) {
            return newLine[0].start;
        }
        return this.indexFromPosition(rect.left, newLine[0].top);
    }

    lineHeightAt(index) {
        if (this.doc.length() === 0) {
            return this.defaultMeasurer.measureText({text: 'x'}, this.doc.defaultFont, this.doc.defaultSize).height;
        }
        let [line, _lineIndex] = this.findLine(index);
        return line.reduce((acc, cur) => Math.max(cur.height, acc), 0);
    }

    barRect(selection) {
        let pos = selection.start;
        if (pos === 0) {
            let rect = this.positionFromIndex(pos);
            let height = this.lineHeightAt(pos);
            return {left: rect.left - 1, top: rect.top, width: 2, height};
        }

        if (pos === this.doc.length()) {
            if (selection.isBol) {
                let rect = this.positionFromIndex(pos);
                let height = this.lineHeightAt(pos);
                return {left: rect.left - 1, top: rect.top, width: 2, height};
            }
            let [prevLine, _prevLineIndex] = this.findLine(pos - 1);
            pos = prevLine[prevLine.length - 1].end - 1;
            let rect = this.positionFromIndex(pos);
            let height = this.lineHeightAt(pos);
            return {left: rect.left + rect.width - 1, top: rect.top, width: 2, height};
        }

        let rect = this.positionFromIndex(pos);
        let height = this.lineHeightAt(pos);
        if (selection.isBol) {
            return {left: rect.left - 1, top: rect.top, width: 2, height};
        }
        return {left: rect.left - 1, top: rect.top, width: 2, height};
    }

    selectionRects(selection) {
        let {start, end} = selection;

        let [line0, line0Index] = this.findLine(start);
        let [line1, line1Index] = this.findLine(end);

        if (line0 === undefined || line1 === undefined) {return [];}

        if (line0Index === line1Index) {
            // one rectangle
            let pos1 = this.positionFromIndex(start);
            let pos2 = this.positionFromIndex(end);
            let height = this.lineHeightAt(start);
            return [{left: pos1.left, top: pos1.top,
                     width: pos2.left - pos1.left,
                     height: height}];
        }

        let rects = [];
        let pos1 = this.positionFromIndex(start);
        let height1 = this.lineHeightAt(start);
        let pos2;
        let height2;
        if (end === this.doc.length()) {
            let lastWord = this.findWord(end - 1);
            if ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_0__.isNewline)(lastWord.text[lastWord.length - 1])) {
                end--;
                let [newLine1, newLine1Index] = this.findLine(end);
                line1 = newLine1;
                line1Index = newLine1Index;
            }
        }

        let hMargin = this.options.margins.right + this.options.margins.left;

        pos2 = this.positionFromIndex(end);
        height2 = this.lineHeightAt(end);

        rects.push({left: pos1.left, top: pos1.top,
                    width: this.width() - pos1.left - hMargin,
                    height: height1});
        if (line1Index - line0Index >= 2) {
            pos1 = this.lines[line0Index + 1][0];
            rects.push({left: this.options.margins.left, top: pos1.top,
                        width: this.width() - hMargin,
                        height: pos2.top - pos1.top});
        }

        pos1 = this.lines[line1Index][0];
        height2 = this.lineHeightAt(end);
        rects.push({left: this.options.margins.left, top: pos2.top,
                    width: pos2.left - this.options.margins.left,
                    height: height2});
        return rects;
    }

    isScrollbarClick(x, _y) {
        if (!this.showsScrollbar) {return false;}
        let scrollBarWidth = this.relativeScrollBarWidth * this.pixelX,
            scrollBarLeft = this.pixelX - scrollBarWidth - 3;
        return x >= scrollBarLeft;
    }

    mouseDown(x, y, realY, user) {
        if (this.isScrollbarClick(x, y)) {
            this.scrollBarClick = {
                type: "clicked",
                scrollBarVOffset: y - this.scrollbarBounds().t,
                scrollBarTopOnDown: this.scrollTop,
                realStartY: realY,
                startX: x, startY: y
            };
        } else {
            let index = this.indexFromPosition(x, y);
            let isBol = this.isBol(x, y);
            this.extendingSelection = null;
            this.selectDragStart = index;
            this.select(user, index, index, isBol);
        }
        this.keyboardX = null;
    }

    mouseMove(x, y, realY, user) {
        if (this.selectDragStart !== null) {
            let other = this.indexFromPosition(x, y);
            let start, end;
            if (other || other === 0) {
                this.focusChar = other;
                if (this.selectDragStart > other) {
                    this.extendingSelection = 'top';
                    start = other;
                    end = this.selectDragStart;
                } else {
                    this.extendingSelection = 'bottom';
                    start = this.selectDragStart;
                    end = other;
                }
                let last = this.lastSelect;
                if (last && (last.start !== start || last.end !== end)) {
                    this.select(user, start, end);
                    return 'selectionChanged';
                }
            }
            return null;
        }

        if (this.scrollBarClick) {
            let {realStartY, scrollBarTopOnDown} = this.scrollBarClick;
            let docHeight = this.docHeight;
            let newPos = (realY - realStartY) // movement
                          * Math.max(1, docHeight / this.pixelY) // how many pixels it means relative to doc height
                          / docHeight   // ratio in doc height
                          + scrollBarTopOnDown;  // make it the new value
            this.scrollBarClick.type = "move";
            this.setScroll(0, newPos);
            return 'scrollChanged';
        }
        return null;
    }

    mouseUp(_x, _y, _realY, _user) {
        if (this.scrollBarClick) {
            if (this.scrollBarClick.type === "clicked") {
                // click to scroll behavior
            }
            this.scrollBarClick = null;
            this.wasScrollBarClick = true;
        } else {
            this.wasScrollBarClick = false;
        }
        this.selectDragStart = null;
        this.keyboardX = null;
        this.lastSelect = null;
    }

    backspace(user) {
        this.delete(user, true);
    }

    handleKey(user, key, selecting, ctrlKey) {
        let selection = this.doc.selections[user.id] || {start: 0, end: 0, color: user.color};
        let {start, end, isBol} = selection;
        let length = this.doc.length();
        let handled = false;

        let wasLine;
        let wasLineIndex;

        if (!selecting) {
            this.keyboardSelect = 0;
        } else if (!this.keyboardSelect) {
            switch (key) {
                case 37: // left arrow
                case 38: // up - find character above
                case 36: // start of line
                case 33: // page up
                    this.keyboardSelect = -1;
                    break;
                case 39: // right arrow
                case 40: // down arrow - find character below
                case 35: // end of line
                case 34: // page down
                    this.keyboardSelect = 1;
                    break;
                default:
                    break;
            }
        }

        let pos = this.keyboardSelect === 1 ? end : start;
        let oldPos = pos;
        let downEnd;
        let changingCaret = false;
        switch (key) {
            case 37: // left arrow
                if (!selecting && start !== end) {
                    pos = start;
                } else {
                    if (pos > 0) {
                        pos--;
                    }
                }
                isBol = false;
                changingCaret = true;
                break;
            case 39: // right arrow
                if (!selecting && start !== end) {
                    pos = end;
                } else {
                    if (pos < length) {
                        let [line, lineIndex] = this.findLine(pos);
                        wasLine = line;
                        wasLineIndex = lineIndex;
                        pos++;
                    }
                }
                changingCaret = true;
                break;

            case 40: // down arrow - find character below
                {
                    let [line, lineIndex] = this.findLine(pos);
                    wasLine = line;
                    wasLineIndex = lineIndex;
                    pos = this.changeLine(user, pos, 1);
                    downEnd = oldPos === pos;
                    changingCaret = true;
                }
                break;
            case 38: // up - find character above
                pos = this.changeLine(user, pos, -1);
                isBol = false;
                changingCaret = true;
                break;

            case 8: // backspace
            case 46: // delete
                this.backspace(user);
                handled = true;
                break;
            default:
                break;
        }

        if (changingCaret) {
            switch (this.keyboardSelect) {
                case 0:
                    start = end = pos;
                    break;
                case -1:
                    start = pos;
                    break;
                case 1:
                    end = pos;
                    break;
                default:
                    break;
            }

            if (start === end) {
                this.keyboardSelect = 0;
            }
            if (start > end) {
                this.keyboardSelect = -this.keyboardSelect;
                let t = end;
                end = start;
                start = t;
            }

            let nowIndex;
            if (wasLine) {
                let [_line, lineIndex] = this.findLine(pos);
                nowIndex = lineIndex;
                isBol = (wasLineIndex !== nowIndex && this.hasLastEnter) || downEnd;
            }

            this.select(user, start, end, isBol);
            handled = true;
        }

        if (ctrlKey) {
            switch (key) {
                case 65:
                    this.select(user, 0, length);
                    window.editor = this;
                    handled = true;
                    break;
                default:
                    break;
            }
        }

        return handled;
    }

    selectionText(user) {
        let sel = this.doc.selections[user.id];
        if (!sel) {
            return "";
        }
        return this.doc.plainText(sel.start, sel.end);
    }
}

class Event {
    static insert(user, runs, timezone) {
        return {type: "insert", user, runs, length: runLength(runs), timezone};
    }

    static delete(user, backspace, timezone) {
        return {type: "delete", backspace, user, timezone};
    }

    static select(user, start, end, isBol, timezone) {
        return {type: "select", user, start, end, isBol, timezone};
    }

    static setStyle(user, style, merge) {
        return {type: "setStyle", user, style, merge};
    }
}


/***/ }),

/***/ "./src/text/wrap.js":
/*!**************************!*\
  !*** ./src/text/wrap.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Measurer": () => (/* binding */ Measurer),
/* harmony export */   "Wrap": () => (/* binding */ Wrap),
/* harmony export */   "eof": () => (/* binding */ eof),
/* harmony export */   "equalStyle": () => (/* binding */ equalStyle),
/* harmony export */   "fontRegistry": () => (/* binding */ fontRegistry),
/* harmony export */   "isNewline": () => (/* binding */ isNewline)
/* harmony export */ });
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io

const eof = String.fromCharCode(26); // "^Z"

function isNewline(str) {
    return  !!/[\n\r]/.test(str);
}

function equalStyle(prev, next, defaultFont, defaultSize) {
    if (!prev && !next) {return true;}

    if (!prev) {
        return next.font === defaultFont && next.size === defaultSize
            && !next.color && !next.bold && !next.italic;
    }
    if (!next) {
        return prev.font === defaultFont && prev.size === defaultSize
            && !prev.color && !prev.bold && !prev.italic;
    }

    return (prev.font || defaultFont) === (next.font || defaultFont)
        && (prev.size || defaultSize) === (next.size || defaultSize)
        && (prev.color === next.color)
        && (!!prev.bold === !!next.bold)
        && (!!prev.italic === !!next.italic);
}

class MetricCache {
    constructor() {
        this.cache = [new Map()]; // [Map]
        this.maxMaps = 4;
        this.limit = 256;
    }

    makeKey(word, font, size) {
        let obj = {font, size, style: word.style, styles: word.styles, text: word.text};
        // JSONifying it still may not be stable, but it is okay to have multiple entries
        // for the "same" word
        return JSON.stringify(obj);
    }

    lookup(key) {
        for (let i = 0; i < this.cache.length; i++) {
            let v = this.cache[i].get(key);
            if (v) {return {...v};}
        }
        return null;
    }

    update(key, entry) {
        // assumes that lookup returned null previously
        let m = this.cache[this.cache.length - 1];
        m.set(key, entry);
        if (m.size >= this.limit) {
            if (this.cache.length === this.maxMaps) {
                let r = Math.floor(Math.random() * this.cache.length);
                this.cache.splice(r, 1);
            }
            this.cache.push(new Map());
        }
    }
}

class MSDFFontRegistry {
    constructor() {
        this.layouts = new Map();
    }

    hasLayout(name) {
        return this.layouts.get(name);
    }

    addLayout(name, layout) {
        this.layouts.set(name, layout);
        return layout;
    }

    measureText(word, font, _size) {
        let layout = this.layouts.get(font);
        if (layout) {
            return layout.measureText(word.text);
        }

        return {ascent: 36, height: 50, descent: 14, width: word.text.length * 20};
    }

    getInfo(name, fontSize) {
        let layout = this.layouts.get(name);
        let font;
        if (layout) {
            font = layout._opt.font;
        }
        if (font) {return font;}
        return {common: {lineHeight: fontSize}};
    }
}

const fontRegistry = new MSDFFontRegistry();

class Measurer {
    constructor() {
        this.cache = new MetricCache();
    }

    measureText(word, font, size) {
        let key = this.cache.makeKey(word, font, size);
        let m = this.cache.lookup(key);
        if (m) {return m;}
        m = fontRegistry.measureText(word, font, size);
        this.cache.update(key, m);
        return m;
    }

    lineHeight(font, fontSize) {
        let info = fontRegistry.getInfo(font, fontSize);
        return info.common ? info.common.lineHeight : info.atlas.size;
    }
}

class Wrap {
    splitWords(runs, defaultFont, defaultSize) {
        // returns words and lines.

        const isSpace = str => !!(/[ \f\n\r\t\v\u00A0\u2028\u2029]/.test(str));

        let push = (obj, style, ss) => {
            if (ss && ss.length > 1) {
                words.push(Object.assign(obj, {styles: ss}));
            } else if (ss && ss.length === 1) {
                words.push(Object.assign(obj, {style: ss[0].style}));
            } else if (style) {
                words.push(Object.assign(obj, {style}));
            } else {
                words.push(obj);
            }
        };

        let stylePush = (ss, newOne) => {
            if (!ss) {
                return [newOne];
            }
            let last = ss[ss.length - 1];
            if (!equalStyle(last.style, newOne.style, defaultFont, defaultSize)) {
                ss.push(newOne);
                return ss;
            }
            last.end = newOne.end;
            return ss;
        };

        let words = [];

        let isInWord;
        let start = 0;
        let leftOver = "";
        let styles = null;
        let style;
        let thisWord;

        for (let i = 0; i < runs.length - 1; i++) { // eof is at the end
            if (isInWord === undefined) {isInWord = !isSpace(runs[0].text[0]);}
            let run = runs[i];
            let text = run.text;
            style = run.style;

            if (!isInWord) {
                isInWord = !isSpace(text[0]);
            }

            let wordStart = 0;
            for (let j = 0; j < text.length; j++) {
                if (start === 0 && i === 0 && j === 0) {continue;}
                if (isInWord) {
                    if (isSpace(text[j])) {
                        thisWord = text.slice(wordStart, j);
                        let spaceAtHead = leftOver.length > 0 && thisWord.length === 0;
                        if (leftOver.length > 0) {
                            if (thisWord.length > 0) {
                                let newOne = {start: leftOver.length, end: leftOver.length + thisWord.length, style};
                                styles = stylePush(styles, newOne);
                            }
                            thisWord = leftOver + thisWord;
                            leftOver = "";
                        }
                        push({start, end: start + thisWord.length, text: thisWord}, spaceAtHead ? null : style, styles);
                        start += thisWord.length;
                        wordStart = j;
                        isInWord = false;
                        styles = null;
                    }
                } else {
                    if (j > 0) {
                        push({start, end: start + 1, text: text[j - 1], style, styles});
                        start += 1;
                        wordStart += 1;
                    }
                    if (!isSpace(text[j])) {
                        isInWord = true;
                    }
                }
            }
            // end of a run. the style ends here, but a word may continue
            // when a partial word has a different style
            thisWord = text.slice(wordStart, text.length);

            // but then, this word may be just a whitespace
            if (thisWord.length === 1 && isSpace(thisWord)) {
                push({start, end: start + 1, text: thisWord, style, styles});
                start += 1;
            } else {
                let fragment = {start: leftOver.length, end: leftOver.length + thisWord.length, style};
                styles = stylePush(styles, fragment);
                leftOver += thisWord;
            }
        }
        // the last word in the entire text.
        // the special case here is that the style for left over,
        // and the 'fragment' may just be the same as style.  If that is the case,
        // it simply creates a run with one style
        let eofPos = start;
        if (leftOver.length > 0) {
            eofPos = start + leftOver.length;
            let word = {start, end: eofPos, text: leftOver};
            if (styles && styles.length === 1 && equalStyle(style, styles[0].style, defaultFont, defaultSize)) {
                push(word, style);
            } else {
                push(word, null, styles);
            }
        }
        push({start: eofPos, end: eofPos + 1, text: eof});
        return words;
    }

    mergeRect(m1, m2) {
        if (!m1) {return m2;}
        if (!m2) {return m1;}
        return {
            width: m1.width + m2.width,
            height: Math.max(m1.height, m2.height),
            ascent: Math.max(m1.ascent, m2.ascent),
        };
    }

    wrap(runs, textWidth, measurer, defaultFont, defaultSize, margins) {
        // returns words and lines.

        if (!margins) {
            margins = {left: 0, top: 0, right: 0, bottom: 0};
        }

        const width = textWidth - margins.left - margins.right;

        let currentLine = [];
        let currentHeight = 0;
        let currentAscent = 0;
        let lines = []; // list of list of words

        let left = margins.left;
        let top = margins.top;

        let words = this.splitWords(runs, defaultFont, defaultSize);

        let pushLine = () => {
            if (currentLine.length === 0) {return;}
            currentLine.forEach(c => {
                c.ascent = currentAscent;
            });
            lines.push(currentLine);
            currentLine = [];
            left = margins.left;
            top += currentHeight;
            currentHeight = 0;
            currentAscent = 0;
        };

        for (let w = 0; w < words.length - 1; w++) {
            let word = words[w];
            let rect;

            if (isNewline(word.text)) {
                rect = measurer.measureText(word, defaultFont, defaultSize);
                if (w === words.length - 1) {
                    pushLine();
                } else {
                    currentHeight = Math.max(currentHeight, rect.height);
                    currentAscent = Math.max(currentAscent, rect.ascent);
                }
                rect.left = left;
                rect.top = top;
                Object.assign(word, rect);
                currentLine.push(word);
                pushLine();
                currentHeight = 0;
                currentAscent = 0;
                continue;
            }

            rect = measurer.measureText(word, defaultFont, defaultSize);
            currentHeight = Math.max(currentHeight, rect.height);
            currentAscent = Math.max(currentAscent, rect.ascent);

            if (rect.width + left > width) {
                pushLine();
            }
            rect.left = left;
            rect.top = top;
            Object.assign(word, rect);
            left += rect.width;
            currentLine.push(word);
        }

        pushLine();

        let word = words[words.length - 1];
        let rect = measurer.measureText(word, defaultFont, defaultSize);
        currentHeight = Math.max(currentHeight, rect.height);
        currentAscent = Math.max(currentAscent, rect.ascent);
        rect.left = margins.left;
        rect.top = top;
        Object.assign(word, rect);
        currentLine.push(word);
        pushLine();
        return [lines, words];
    }
}


/***/ }),

/***/ "./src/worldSaver.js":
/*!***************************!*\
  !*** ./src/worldSaver.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorldSaver": () => (/* binding */ WorldSaver)
/* harmony export */ });
/* harmony import */ var _card_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./card.js */ "./src/card.js");
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io
//
// enumerate all cards, including the ones that are embedded into others (that is, their parents are *not* model root.
// save the json that would be used for create, but along with the class name (hopefully we can retire this field, but may not be true.
//
// loading time: in general, the parent needs to be created before a child




class WorldSaver {
    constructor(defaultClass) {
        this.map = new Map();
        this.id = 0;
        this.defaultClass = defaultClass;
    }

    newId() {
        return (++this.id).toString().padStart(4, '0');
    }

    save(model) {
        let cards = [];
        for (let [_id, actor] of model.service("ActorManager").actors) {
            if (actor.isCard && !actor.noSave) {
                cards.push(actor);
            }
        }
        let sortedMap = this.topologicalSort(cards);
        let resultArray = this.collectData(sortedMap);

        let behaviorModules = model.service("BehaviorModelManager").save();

        let result = {behaviorModules, cards: resultArray};

        if (_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_1__.Constants.UseRapier) {
            result.useRapier = true;
        }
        return result;
    }

    topologicalSort(cards) {
        let result = new Map();
        let toSort = [...cards];
        let checked = new Map();

        while (toSort.length > 0) {
            let n = toSort.shift();
            if (!n._parent || result.get(n._parent.id)) {
                // it is a root child, or its parent is already in result
                result.set(n.id, n);
            } else {
                // Its parent may be still in the toSort array
                if (checked.get(n)) {throw new Error("actors make a cycle");}
                toSort.push(n);
                checked.set(n, true);
            }
        }
        return result;
    }

    collectData(cardsMap) {
        let result = [];
        for (let [_id, actor] of cardsMap) {
            let obj = {id: this.newId()};
            this.map.set(actor, obj);
            let data = this.collectCardData(actor);
            obj.card = data;
            result.push(obj);
        };
        return result;
    }

    collectCardData(card, useRealId) {
        let result = {};
        if (card.constructor !== this.defaultClass) {
            result.className = card.constructor.name;
        }
        _card_js__WEBPACK_IMPORTED_MODULE_0__.intrinsicProperties.forEach((prop) => {
            if (card[`_${prop}`]) {
                if (prop === "parent") {
                    if (!useRealId) {
                        let entry = this.map.get(card[prop]);
                        if (!entry) {throw new Error("undefined parent used");}
                        result[prop] = entry.id;
                    } else {
                        let entry = card[prop];
                        if (!entry) {throw new Error("undefined parent used");}
                        result[prop] = entry.id;
                    }
                } else {
                    result[prop] = card[`_${prop}`];
                }
            }
        });

        if (card._cardData) {
            let keys = Object.keys(card._cardData);
            keys.sort();
            keys.forEach((k) => {
                result[k] = card._cardData[k];
            });
        }
        return result;
    }

    stringifyInner(node, seen) {
        if (node === undefined) return undefined;
        if (typeof node === 'number') return Number.isFinite(node) ? `${node}` : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        let out;
        if (Array.isArray(node)) {
            out = '[';
            for (let i = 0; i < node.length; i++) {
                if (i > 0) out += ',';
                out += this.stringifyInner(node[i], seen) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.has(node)) {
            throw new TypeError('Converting circular structure to JSON');
        }

        seen.add(node);

        if (node.constructor === window.Map) {
            let replacement = {__map: true, values: [...node]};
            return this.stringifyInner(replacement, seen);
        }

        let keys = Object.keys(node).sort();
        out = '';
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let value = this.stringifyInner(node[key], seen, out);
            if (!value) continue;
            if (out !== '') out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.delete(node);
        return '{' + out + '}';
    }

    stringify(obj) {
        let seen = new Set();
        return this.stringifyInner(obj, seen);
    }

    parse(string) {
        return JSON.parse(string, (_key, value) => {
            if (typeof value === "object" && value !== null && value.__map) {
                return new Map(value.values);
            }
            return value;
        });
    }
}


/***/ }),

/***/ "./assets/fonts/Roboto.json":
/*!**********************************!*\
  !*** ./assets/fonts/Roboto.json ***!
  \**********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"pages":["Roboto-msdf.png"],"chars":[{"id":41,"width":22,"height":53,"xoffset":0,"yoffset":-33.6943359375,"xadvance":14.6015625,"chnl":15,"x":0,"y":0,"page":0},{"id":40,"width":24,"height":53,"xoffset":0,"yoffset":-33.6943359375,"xadvance":14.35546875,"chnl":15,"x":0,"y":55,"page":0},{"id":93,"width":18,"height":51,"xoffset":0,"yoffset":-34.125,"xadvance":11.1357421875,"chnl":15,"x":0,"y":110,"page":0},{"id":91,"width":21,"height":51,"xoffset":0,"yoffset":-34.125,"xadvance":11.1357421875,"chnl":15,"x":0,"y":163,"page":0},{"id":125,"width":23,"height":50,"xoffset":0,"yoffset":-32.7509765625,"xadvance":14.2119140625,"chnl":15,"x":0,"y":216,"page":0},{"id":123,"width":24,"height":50,"xoffset":0,"yoffset":-32.7509765625,"xadvance":14.2119140625,"chnl":15,"x":0,"y":268,"page":0},{"id":106,"width":18,"height":49,"xoffset":0,"yoffset":-30.26953125,"xadvance":10.0283203125,"chnl":15,"x":0,"y":320,"page":0},{"id":36,"width":31,"height":49,"xoffset":0,"yoffset":-34.69921875,"xadvance":23.583984375,"chnl":15,"x":0,"y":371,"page":0},{"id":64,"width":46,"height":49,"xoffset":0,"yoffset":-29.3466796875,"xadvance":37.7138671875,"chnl":15,"x":0,"y":422,"page":0},{"id":87,"width":46,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":37.2626953125,"chnl":15,"x":48,"y":422,"page":0},{"id":124,"width":17,"height":45,"xoffset":0,"yoffset":-29.859375,"xadvance":10.2333984375,"chnl":15,"x":33,"y":371,"page":0},{"id":81,"width":36,"height":45,"xoffset":0,"yoffset":-30.26953125,"xadvance":28.875,"chnl":15,"x":52,"y":371,"page":0},{"id":109,"width":44,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":36.8115234375,"chnl":15,"x":0,"y":473,"page":0},{"id":77,"width":43,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":36.66796875,"chnl":15,"x":96,"y":422,"page":0},{"id":39,"width":15,"height":42,"xoffset":0,"yoffset":-31.5,"xadvance":7.3212890625,"chnl":15,"x":90,"y":371,"page":0},{"id":34,"width":21,"height":42,"xoffset":0,"yoffset":-31.5,"xadvance":13.4326171875,"chnl":15,"x":107,"y":371,"page":0},{"id":92,"width":27,"height":42,"xoffset":0,"yoffset":-29.859375,"xadvance":17.2265625,"chnl":15,"x":130,"y":371,"page":0},{"id":104,"width":30,"height":42,"xoffset":0,"yoffset":-31.5,"xadvance":23.1328125,"chnl":15,"x":159,"y":371,"page":0},{"id":47,"width":26,"height":42,"xoffset":0,"yoffset":-29.859375,"xadvance":17.30859375,"chnl":15,"x":191,"y":371,"page":0},{"id":108,"width":17,"height":42,"xoffset":0,"yoffset":-31.5,"xadvance":10.1923828125,"chnl":15,"x":219,"y":371,"page":0},{"id":98,"width":32,"height":42,"xoffset":0,"yoffset":-31.5,"xadvance":23.5634765625,"chnl":15,"x":238,"y":371,"page":0},{"id":107,"width":31,"height":42,"xoffset":0,"yoffset":-31.5,"xadvance":21.287109375,"chnl":15,"x":272,"y":371,"page":0},{"id":100,"width":31,"height":42,"xoffset":0,"yoffset":-31.5,"xadvance":23.6865234375,"chnl":15,"x":305,"y":371,"page":0},{"id":102,"width":25,"height":42,"xoffset":0,"yoffset":-31.9306640625,"xadvance":14.5810546875,"chnl":15,"x":338,"y":371,"page":0},{"id":48,"width":31,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":23.583984375,"chnl":15,"x":365,"y":371,"page":0},{"id":51,"width":31,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":23.583984375,"chnl":15,"x":398,"y":371,"page":0},{"id":83,"width":33,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":24.9169921875,"chnl":15,"x":431,"y":371,"page":0},{"id":56,"width":31,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":23.583984375,"chnl":15,"x":466,"y":371,"page":0},{"id":119,"width":41,"height":32,"xoffset":0,"yoffset":-22.189453125,"xadvance":31.5615234375,"chnl":15,"x":46,"y":473,"page":0},{"id":37,"width":39,"height":41,"xoffset":0,"yoffset":-30.2900390625,"xadvance":30.76171875,"chnl":15,"x":20,"y":320,"page":0},{"id":103,"width":31,"height":41,"xoffset":0,"yoffset":-22.599609375,"xadvance":23.5634765625,"chnl":15,"x":61,"y":320,"page":0},{"id":113,"width":31,"height":41,"xoffset":0,"yoffset":-22.599609375,"xadvance":23.87109375,"chnl":15,"x":94,"y":320,"page":0},{"id":96,"width":20,"height":41,"xoffset":0,"yoffset":-31.458984375,"xadvance":12.9814453125,"chnl":15,"x":127,"y":320,"page":0},{"id":38,"width":36,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":26.1064453125,"chnl":15,"x":149,"y":320,"page":0},{"id":121,"width":29,"height":41,"xoffset":0,"yoffset":-22.189453125,"xadvance":19.8720703125,"chnl":15,"x":187,"y":320,"page":0},{"id":67,"width":35,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":27.3369140625,"chnl":15,"x":218,"y":320,"page":0},{"id":79,"width":36,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":28.875,"chnl":15,"x":255,"y":320,"page":0},{"id":71,"width":36,"height":41,"xoffset":0,"yoffset":-30.26953125,"xadvance":28.6083984375,"chnl":15,"x":293,"y":320,"page":0},{"id":112,"width":32,"height":41,"xoffset":0,"yoffset":-22.599609375,"xadvance":23.5634765625,"chnl":15,"x":331,"y":320,"page":0},{"id":72,"width":36,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":29.94140625,"chnl":15,"x":141,"y":422,"page":0},{"id":73,"width":18,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":11.4228515625,"chnl":15,"x":179,"y":422,"page":0},{"id":74,"width":30,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":23.173828125,"chnl":15,"x":199,"y":422,"page":0},{"id":75,"width":36,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":26.33203125,"chnl":15,"x":231,"y":422,"page":0},{"id":76,"width":32,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":22.599609375,"chnl":15,"x":269,"y":422,"page":0},{"id":57,"width":31,"height":40,"xoffset":0,"yoffset":-30.26953125,"xadvance":23.583984375,"chnl":15,"x":303,"y":422,"page":0},{"id":78,"width":36,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":29.94140625,"chnl":15,"x":336,"y":422,"page":0},{"id":33,"width":18,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":10.8076171875,"chnl":15,"x":374,"y":422,"page":0},{"id":80,"width":35,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":26.49609375,"chnl":15,"x":394,"y":422,"page":0},{"id":42,"width":27,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":18.087890625,"chnl":15,"x":431,"y":422,"page":0},{"id":82,"width":35,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":25.8603515625,"chnl":15,"x":460,"y":422,"page":0},{"id":49,"width":25,"height":40,"xoffset":0,"yoffset":-30.0029296875,"xadvance":23.583984375,"chnl":15,"x":365,"y":320,"page":0},{"id":84,"width":34,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":25.060546875,"chnl":15,"x":392,"y":320,"page":0},{"id":85,"width":34,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":27.234375,"chnl":15,"x":428,"y":320,"page":0},{"id":86,"width":36,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":26.7216796875,"chnl":15,"x":464,"y":320,"page":0},{"id":50,"width":32,"height":40,"xoffset":0,"yoffset":-30.26953125,"xadvance":23.583984375,"chnl":15,"x":26,"y":268,"page":0},{"id":88,"width":35,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":26.33203125,"chnl":15,"x":60,"y":268,"page":0},{"id":89,"width":35,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":25.224609375,"chnl":15,"x":97,"y":268,"page":0},{"id":90,"width":34,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":25.142578125,"chnl":15,"x":134,"y":268,"page":0},{"id":105,"width":17,"height":40,"xoffset":0,"yoffset":-30.26953125,"xadvance":10.1923828125,"chnl":15,"x":170,"y":268,"page":0},{"id":52,"width":33,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":23.583984375,"chnl":15,"x":189,"y":268,"page":0},{"id":63,"width":28,"height":40,"xoffset":0,"yoffset":-30.26953125,"xadvance":19.8310546875,"chnl":15,"x":224,"y":268,"page":0},{"id":94,"width":26,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":17.5546875,"chnl":15,"x":254,"y":268,"page":0},{"id":53,"width":32,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":23.583984375,"chnl":15,"x":282,"y":268,"page":0},{"id":65,"width":37,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":27.3984375,"chnl":15,"x":316,"y":268,"page":0},{"id":66,"width":34,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":26.1474609375,"chnl":15,"x":355,"y":268,"page":0},{"id":54,"width":32,"height":40,"xoffset":0,"yoffset":-29.8798828125,"xadvance":23.583984375,"chnl":15,"x":391,"y":268,"page":0},{"id":68,"width":35,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":27.5419921875,"chnl":15,"x":425,"y":268,"page":0},{"id":55,"width":32,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":23.583984375,"chnl":15,"x":462,"y":268,"page":0},{"id":70,"width":32,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":23.21484375,"chnl":15,"x":25,"y":216,"page":0},{"id":35,"width":35,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":25.8603515625,"chnl":15,"x":59,"y":216,"page":0},{"id":69,"width":32,"height":40,"xoffset":0,"yoffset":-29.859375,"xadvance":23.87109375,"chnl":15,"x":96,"y":216,"page":0},{"id":116,"width":22,"height":38,"xoffset":0,"yoffset":-27.5625,"xadvance":13.7197265625,"chnl":15,"x":130,"y":216,"page":0},{"id":59,"width":17,"height":38,"xoffset":0,"yoffset":-22.39453125,"xadvance":8.8798828125,"chnl":15,"x":154,"y":216,"page":0},{"id":126,"width":36,"height":26,"xoffset":0,"yoffset":-16.447265625,"xadvance":28.5673828125,"chnl":15,"x":89,"y":473,"page":0},{"id":43,"width":32,"height":35,"xoffset":0,"yoffset":-24.732421875,"xadvance":23.8095703125,"chnl":15,"x":173,"y":216,"page":0},{"id":60,"width":28,"height":33,"xoffset":0,"yoffset":-22.517578125,"xadvance":21.3486328125,"chnl":15,"x":207,"y":216,"page":0},{"id":97,"width":31,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":22.845703125,"chnl":15,"x":237,"y":216,"page":0},{"id":101,"width":31,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":22.2509765625,"chnl":15,"x":270,"y":216,"page":0},{"id":110,"width":30,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":23.173828125,"chnl":15,"x":303,"y":216,"page":0},{"id":111,"width":32,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":23.953125,"chnl":15,"x":335,"y":216,"page":0},{"id":62,"width":30,"height":33,"xoffset":0,"yoffset":-22.5380859375,"xadvance":21.943359375,"chnl":15,"x":369,"y":216,"page":0},{"id":58,"width":17,"height":33,"xoffset":0,"yoffset":-22.39453125,"xadvance":10.171875,"chnl":15,"x":401,"y":216,"page":0},{"id":114,"width":24,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":14.2119140625,"chnl":15,"x":420,"y":216,"page":0},{"id":115,"width":30,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":21.65625,"chnl":15,"x":446,"y":216,"page":0},{"id":99,"width":31,"height":33,"xoffset":0,"yoffset":-22.599609375,"xadvance":21.984375,"chnl":15,"x":478,"y":216,"page":0},{"id":117,"width":30,"height":33,"xoffset":0,"yoffset":-22.189453125,"xadvance":23.1533203125,"chnl":15,"x":23,"y":163,"page":0},{"id":118,"width":30,"height":32,"xoffset":0,"yoffset":-22.189453125,"xadvance":20.34375,"chnl":15,"x":55,"y":163,"page":0},{"id":120,"width":30,"height":32,"xoffset":0,"yoffset":-22.189453125,"xadvance":20.8154296875,"chnl":15,"x":87,"y":163,"page":0},{"id":122,"width":29,"height":32,"xoffset":0,"yoffset":-22.189453125,"xadvance":20.8154296875,"chnl":15,"x":119,"y":163,"page":0},{"id":61,"width":30,"height":30,"xoffset":0,"yoffset":-19.9951171875,"xadvance":23.05078125,"chnl":15,"x":150,"y":163,"page":0},{"id":95,"width":29,"height":13,"xoffset":0,"yoffset":0,"xadvance":18.94921875,"chnl":15,"x":127,"y":473,"page":0},{"id":45,"width":21,"height":24,"xoffset":0,"yoffset":-14.232421875,"xadvance":11.5869140625,"chnl":15,"x":182,"y":163,"page":0},{"id":44,"width":16,"height":20,"xoffset":0,"yoffset":-4.4912109375,"xadvance":8.244140625,"chnl":15,"x":496,"y":268,"page":0},{"id":46,"width":18,"height":15,"xoffset":0,"yoffset":-4.2861328125,"xadvance":11.0537109375,"chnl":15,"x":23,"y":198,"page":0},{"id":32,"width":0,"height":0,"xoffset":0,"yoffset":0,"xadvance":10.3974609375,"chnl":15,"x":0,"y":508,"page":0}],"info":{"face":"Roboto","size":42,"bold":0,"italic":0,"charset":[" ","!","\\"","#","$","%","&","\'","(",")","*","+",",","-",".","/","0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?","@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","[","\\\\","]","^","_","`","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","{","|","}","~"],"unicode":1,"stretchH":100,"smooth":1,"aa":1,"padding":[0,0,0,0],"spacing":[2,2]},"common":{"lineHeight":44.091796875,"base":38.96484375,"scaleW":512,"scaleH":512,"pages":1,"packed":0,"alphaChnl":0,"redChnl":0,"greenChnl":0,"blueChnl":0},"kernings":[{"first":32,"second":84,"amount":-0.8203125},{"first":34,"second":34,"amount":-2.1943359375},{"first":34,"second":39,"amount":-2.1943359375},{"first":34,"second":65,"amount":-2.4609375},{"first":34,"second":97,"amount":-1.025390625},{"first":34,"second":99,"amount":-1.2099609375},{"first":34,"second":100,"amount":-1.2099609375},{"first":34,"second":101,"amount":-1.2099609375},{"first":34,"second":103,"amount":-1.2099609375},{"first":34,"second":109,"amount":-0.41015625},{"first":34,"second":110,"amount":-0.41015625},{"first":34,"second":111,"amount":-1.2509765625},{"first":34,"second":112,"amount":-0.41015625},{"first":34,"second":113,"amount":-1.2099609375},{"first":34,"second":115,"amount":-1.640625},{"first":39,"second":34,"amount":-2.1943359375},{"first":39,"second":39,"amount":-2.1943359375},{"first":39,"second":65,"amount":-2.4609375},{"first":39,"second":97,"amount":-1.025390625},{"first":39,"second":99,"amount":-1.2099609375},{"first":39,"second":100,"amount":-1.2099609375},{"first":39,"second":101,"amount":-1.2099609375},{"first":39,"second":103,"amount":-1.2099609375},{"first":39,"second":109,"amount":-0.41015625},{"first":39,"second":110,"amount":-0.41015625},{"first":39,"second":111,"amount":-1.2509765625},{"first":39,"second":112,"amount":-0.41015625},{"first":39,"second":113,"amount":-1.2099609375},{"first":39,"second":115,"amount":-1.640625},{"first":40,"second":86,"amount":0.41015625},{"first":40,"second":87,"amount":0.369140625},{"first":40,"second":89,"amount":0.451171875},{"first":44,"second":34,"amount":-3.486328125},{"first":44,"second":39,"amount":-3.486328125},{"first":46,"second":34,"amount":-3.486328125},{"first":46,"second":39,"amount":-3.486328125},{"first":47,"second":47,"amount":-4.59375},{"first":65,"second":34,"amount":-2.4609375},{"first":65,"second":39,"amount":-2.4609375},{"first":65,"second":67,"amount":-0.2255859375},{"first":65,"second":71,"amount":-0.2255859375},{"first":65,"second":79,"amount":-0.2255859375},{"first":65,"second":81,"amount":-0.2255859375},{"first":65,"second":84,"amount":-2.6455078125},{"first":65,"second":85,"amount":-0.3486328125},{"first":65,"second":86,"amount":-1.7841796875},{"first":65,"second":87,"amount":-1.4150390625},{"first":65,"second":89,"amount":-1.927734375},{"first":65,"second":111,"amount":-0.24609375},{"first":65,"second":117,"amount":-0.2255859375},{"first":65,"second":118,"amount":-1.025390625},{"first":65,"second":121,"amount":-1.025390625},{"first":65,"second":122,"amount":0.24609375},{"first":66,"second":84,"amount":-0.5537109375},{"first":66,"second":86,"amount":-0.4921875},{"first":66,"second":89,"amount":-1.1279296875},{"first":67,"second":84,"amount":-0.5947265625},{"first":68,"second":44,"amount":-2.091796875},{"first":68,"second":46,"amount":-2.091796875},{"first":68,"second":65,"amount":-0.4306640625},{"first":68,"second":84,"amount":-0.5537109375},{"first":68,"second":86,"amount":-0.451171875},{"first":68,"second":88,"amount":-0.451171875},{"first":68,"second":89,"amount":-0.8818359375},{"first":68,"second":90,"amount":-0.4716796875},{"first":69,"second":84,"amount":0.41015625},{"first":69,"second":99,"amount":-0.3896484375},{"first":69,"second":100,"amount":-0.3896484375},{"first":69,"second":101,"amount":-0.3896484375},{"first":69,"second":103,"amount":-0.3896484375},{"first":69,"second":111,"amount":-0.3896484375},{"first":69,"second":113,"amount":-0.3896484375},{"first":69,"second":117,"amount":-0.3486328125},{"first":69,"second":118,"amount":-0.533203125},{"first":69,"second":121,"amount":-0.533203125},{"first":70,"second":44,"amount":-4.798828125},{"first":70,"second":46,"amount":-4.798828125},{"first":70,"second":65,"amount":-3.486328125},{"first":70,"second":74,"amount":-5.4140625},{"first":70,"second":84,"amount":0.41015625},{"first":70,"second":97,"amount":-0.697265625},{"first":70,"second":99,"amount":-0.4306640625},{"first":70,"second":100,"amount":-0.4306640625},{"first":70,"second":101,"amount":-0.4306640625},{"first":70,"second":103,"amount":-0.4306640625},{"first":70,"second":111,"amount":-0.4306640625},{"first":70,"second":113,"amount":-0.4306640625},{"first":70,"second":114,"amount":-0.533203125},{"first":70,"second":117,"amount":-0.451171875},{"first":70,"second":118,"amount":-0.4921875},{"first":70,"second":121,"amount":-0.4921875},{"first":72,"second":65,"amount":0.369140625},{"first":72,"second":84,"amount":-0.5947265625},{"first":72,"second":88,"amount":0.3486328125},{"first":72,"second":89,"amount":-0.57421875},{"first":73,"second":65,"amount":0.369140625},{"first":73,"second":84,"amount":-0.5947265625},{"first":73,"second":88,"amount":0.3486328125},{"first":73,"second":89,"amount":-0.57421875},{"first":74,"second":65,"amount":-0.451171875},{"first":75,"second":45,"amount":-1.3125},{"first":75,"second":67,"amount":-0.6357421875},{"first":75,"second":71,"amount":-0.6357421875},{"first":75,"second":79,"amount":-0.6357421875},{"first":75,"second":81,"amount":-0.6357421875},{"first":75,"second":99,"amount":-0.533203125},{"first":75,"second":100,"amount":-0.533203125},{"first":75,"second":101,"amount":-0.533203125},{"first":75,"second":103,"amount":-0.533203125},{"first":75,"second":109,"amount":-0.4716796875},{"first":75,"second":110,"amount":-0.4716796875},{"first":75,"second":111,"amount":-0.5537109375},{"first":75,"second":112,"amount":-0.4716796875},{"first":75,"second":113,"amount":-0.533203125},{"first":75,"second":117,"amount":-0.4716796875},{"first":75,"second":118,"amount":-0.8203125},{"first":75,"second":121,"amount":-0.8203125},{"first":76,"second":34,"amount":-6.890625},{"first":76,"second":39,"amount":-6.890625},{"first":76,"second":65,"amount":0.3896484375},{"first":76,"second":67,"amount":-1.3330078125},{"first":76,"second":71,"amount":-1.3330078125},{"first":76,"second":79,"amount":-1.3330078125},{"first":76,"second":81,"amount":-1.3330078125},{"first":76,"second":84,"amount":-5.6396484375},{"first":76,"second":85,"amount":-1.107421875},{"first":76,"second":86,"amount":-3.5888671875},{"first":76,"second":87,"amount":-2.9326171875},{"first":76,"second":89,"amount":-4.9013671875},{"first":76,"second":117,"amount":-0.90234375},{"first":76,"second":118,"amount":-2.7275390625},{"first":76,"second":121,"amount":-2.7275390625},{"first":77,"second":65,"amount":0.369140625},{"first":77,"second":84,"amount":-0.5947265625},{"first":77,"second":88,"amount":0.3486328125},{"first":77,"second":89,"amount":-0.57421875},{"first":78,"second":65,"amount":0.369140625},{"first":78,"second":84,"amount":-0.5947265625},{"first":78,"second":88,"amount":0.3486328125},{"first":78,"second":89,"amount":-0.57421875},{"first":79,"second":44,"amount":-2.091796875},{"first":79,"second":46,"amount":-2.091796875},{"first":79,"second":65,"amount":-0.4306640625},{"first":79,"second":84,"amount":-0.5537109375},{"first":79,"second":86,"amount":-0.451171875},{"first":79,"second":88,"amount":-0.451171875},{"first":79,"second":89,"amount":-0.8818359375},{"first":79,"second":90,"amount":-0.4716796875},{"first":80,"second":44,"amount":-6.64453125},{"first":80,"second":46,"amount":-6.64453125},{"first":80,"second":65,"amount":-2.830078125},{"first":80,"second":74,"amount":-4.1015625},{"first":80,"second":88,"amount":-0.6357421875},{"first":80,"second":90,"amount":-0.533203125},{"first":80,"second":97,"amount":-0.2255859375},{"first":80,"second":99,"amount":-0.2666015625},{"first":80,"second":100,"amount":-0.2666015625},{"first":80,"second":101,"amount":-0.2666015625},{"first":80,"second":103,"amount":-0.2666015625},{"first":80,"second":111,"amount":-0.2666015625},{"first":80,"second":113,"amount":-0.2666015625},{"first":80,"second":118,"amount":0.3076171875},{"first":80,"second":121,"amount":0.3076171875},{"first":81,"second":84,"amount":-0.8818359375},{"first":81,"second":86,"amount":-0.57421875},{"first":81,"second":87,"amount":-0.41015625},{"first":81,"second":89,"amount":-0.7177734375},{"first":82,"second":84,"amount":-1.640625},{"first":82,"second":86,"amount":-0.3896484375},{"first":82,"second":89,"amount":-0.984375},{"first":84,"second":44,"amount":-4.470703125},{"first":84,"second":45,"amount":-4.7578125},{"first":84,"second":46,"amount":-4.470703125},{"first":84,"second":65,"amount":-1.6201171875},{"first":84,"second":67,"amount":-0.57421875},{"first":84,"second":71,"amount":-0.57421875},{"first":84,"second":74,"amount":-4.921875},{"first":84,"second":79,"amount":-0.57421875},{"first":84,"second":81,"amount":-0.57421875},{"first":84,"second":83,"amount":-0.328125},{"first":84,"second":84,"amount":0.328125},{"first":84,"second":86,"amount":0.328125},{"first":84,"second":87,"amount":0.3076171875},{"first":84,"second":89,"amount":0.328125},{"first":84,"second":97,"amount":-2.3173828125},{"first":84,"second":99,"amount":-2.0302734375},{"first":84,"second":100,"amount":-2.0302734375},{"first":84,"second":101,"amount":-2.0302734375},{"first":84,"second":103,"amount":-2.0302734375},{"first":84,"second":109,"amount":-2.2353515625},{"first":84,"second":110,"amount":-2.2353515625},{"first":84,"second":111,"amount":-2.0302734375},{"first":84,"second":112,"amount":-2.2353515625},{"first":84,"second":113,"amount":-2.0302734375},{"first":84,"second":115,"amount":-2.37890625},{"first":84,"second":117,"amount":-1.9482421875},{"first":84,"second":118,"amount":-1.4765625},{"first":84,"second":120,"amount":-1.5791015625},{"first":84,"second":121,"amount":-1.4765625},{"first":84,"second":122,"amount":-1.23046875},{"first":85,"second":65,"amount":-0.451171875},{"first":86,"second":44,"amount":-4.6142578125},{"first":86,"second":45,"amount":-0.7587890625},{"first":86,"second":46,"amount":-4.6142578125},{"first":86,"second":65,"amount":-1.5380859375},{"first":86,"second":67,"amount":-0.2666015625},{"first":86,"second":71,"amount":-0.2666015625},{"first":86,"second":79,"amount":-0.2666015625},{"first":86,"second":81,"amount":-0.2666015625},{"first":86,"second":97,"amount":-0.943359375},{"first":86,"second":99,"amount":-0.90234375},{"first":86,"second":100,"amount":-0.90234375},{"first":86,"second":101,"amount":-0.90234375},{"first":86,"second":103,"amount":-0.90234375},{"first":86,"second":111,"amount":-0.943359375},{"first":86,"second":113,"amount":-0.90234375},{"first":86,"second":117,"amount":-0.57421875},{"first":86,"second":118,"amount":-0.2255859375},{"first":86,"second":121,"amount":-0.2255859375},{"first":87,"second":44,"amount":-2.5224609375},{"first":87,"second":45,"amount":-1.23046875},{"first":87,"second":46,"amount":-2.5224609375},{"first":87,"second":65,"amount":-0.8818359375},{"first":87,"second":84,"amount":0.287109375},{"first":87,"second":97,"amount":-0.6767578125},{"first":87,"second":99,"amount":-0.6357421875},{"first":87,"second":100,"amount":-0.6357421875},{"first":87,"second":101,"amount":-0.6357421875},{"first":87,"second":103,"amount":-0.6357421875},{"first":87,"second":111,"amount":-0.6357421875},{"first":87,"second":113,"amount":-0.6357421875},{"first":87,"second":117,"amount":-0.3896484375},{"first":88,"second":45,"amount":-0.943359375},{"first":88,"second":67,"amount":-0.5126953125},{"first":88,"second":71,"amount":-0.5126953125},{"first":88,"second":79,"amount":-0.5126953125},{"first":88,"second":81,"amount":-0.5126953125},{"first":88,"second":86,"amount":0.287109375},{"first":88,"second":99,"amount":-0.533203125},{"first":88,"second":100,"amount":-0.533203125},{"first":88,"second":101,"amount":-0.533203125},{"first":88,"second":103,"amount":-0.533203125},{"first":88,"second":111,"amount":-0.4306640625},{"first":88,"second":113,"amount":-0.533203125},{"first":88,"second":117,"amount":-0.4306640625},{"first":88,"second":118,"amount":-0.6357421875},{"first":88,"second":121,"amount":-0.6357421875},{"first":89,"second":44,"amount":-4.3271484375},{"first":89,"second":45,"amount":-1.06640625},{"first":89,"second":46,"amount":-4.3271484375},{"first":89,"second":65,"amount":-1.927734375},{"first":89,"second":67,"amount":-0.5947265625},{"first":89,"second":71,"amount":-0.5947265625},{"first":89,"second":74,"amount":-1.96875},{"first":89,"second":79,"amount":-0.5947265625},{"first":89,"second":81,"amount":-0.5947265625},{"first":89,"second":83,"amount":-0.328125},{"first":89,"second":84,"amount":0.3486328125},{"first":89,"second":85,"amount":-1.96875},{"first":89,"second":86,"amount":0.369140625},{"first":89,"second":87,"amount":0.3486328125},{"first":89,"second":88,"amount":0.2666015625},{"first":89,"second":89,"amount":0.369140625},{"first":89,"second":97,"amount":-1.4970703125},{"first":89,"second":99,"amount":-1.3330078125},{"first":89,"second":100,"amount":-1.3330078125},{"first":89,"second":101,"amount":-1.3330078125},{"first":89,"second":103,"amount":-1.3330078125},{"first":89,"second":109,"amount":-0.8203125},{"first":89,"second":110,"amount":-0.8203125},{"first":89,"second":111,"amount":-1.3330078125},{"first":89,"second":112,"amount":-0.8203125},{"first":89,"second":113,"amount":-1.3330078125},{"first":89,"second":115,"amount":-1.189453125},{"first":89,"second":117,"amount":-0.7998046875},{"first":89,"second":118,"amount":-0.41015625},{"first":89,"second":120,"amount":-0.4716796875},{"first":89,"second":121,"amount":-0.41015625},{"first":89,"second":122,"amount":-0.615234375},{"first":90,"second":65,"amount":0.2666015625},{"first":90,"second":67,"amount":-0.533203125},{"first":90,"second":71,"amount":-0.533203125},{"first":90,"second":79,"amount":-0.533203125},{"first":90,"second":81,"amount":-0.533203125},{"first":90,"second":99,"amount":-0.4306640625},{"first":90,"second":100,"amount":-0.4306640625},{"first":90,"second":101,"amount":-0.4306640625},{"first":90,"second":103,"amount":-0.4306640625},{"first":90,"second":111,"amount":-0.4306640625},{"first":90,"second":113,"amount":-0.4306640625},{"first":90,"second":117,"amount":-0.3896484375},{"first":90,"second":118,"amount":-0.5537109375},{"first":90,"second":121,"amount":-0.5537109375},{"first":91,"second":74,"amount":-0.369140625},{"first":91,"second":85,"amount":-0.369140625},{"first":97,"second":34,"amount":-1.3740234375},{"first":97,"second":39,"amount":-1.3740234375},{"first":97,"second":118,"amount":-0.3076171875},{"first":97,"second":121,"amount":-0.3076171875},{"first":98,"second":34,"amount":-0.5947265625},{"first":98,"second":39,"amount":-0.5947265625},{"first":98,"second":118,"amount":-0.2255859375},{"first":98,"second":120,"amount":-0.3076171875},{"first":98,"second":121,"amount":-0.2255859375},{"first":98,"second":122,"amount":-0.3076171875},{"first":99,"second":34,"amount":-0.2255859375},{"first":99,"second":39,"amount":-0.2255859375},{"first":101,"second":34,"amount":-0.287109375},{"first":101,"second":39,"amount":-0.287109375},{"first":101,"second":118,"amount":-0.2666015625},{"first":101,"second":121,"amount":-0.2666015625},{"first":102,"second":34,"amount":0.328125},{"first":102,"second":39,"amount":0.328125},{"first":102,"second":41,"amount":0.41015625},{"first":102,"second":93,"amount":0.369140625},{"first":102,"second":99,"amount":-0.4921875},{"first":102,"second":100,"amount":-0.4921875},{"first":102,"second":101,"amount":-0.4921875},{"first":102,"second":103,"amount":-0.4921875},{"first":102,"second":113,"amount":-0.4921875},{"first":102,"second":125,"amount":0.3896484375},{"first":104,"second":34,"amount":-2.1328125},{"first":104,"second":39,"amount":-2.1328125},{"first":107,"second":99,"amount":-0.41015625},{"first":107,"second":100,"amount":-0.41015625},{"first":107,"second":101,"amount":-0.41015625},{"first":107,"second":103,"amount":-0.41015625},{"first":107,"second":113,"amount":-0.41015625},{"first":109,"second":34,"amount":-2.1328125},{"first":109,"second":39,"amount":-2.1328125},{"first":110,"second":34,"amount":-2.1328125},{"first":110,"second":39,"amount":-2.1328125},{"first":111,"second":34,"amount":-2.7890625},{"first":111,"second":39,"amount":-2.7890625},{"first":111,"second":118,"amount":-0.3076171875},{"first":111,"second":120,"amount":-0.4306640625},{"first":111,"second":121,"amount":-0.3076171875},{"first":111,"second":122,"amount":-0.328125},{"first":112,"second":34,"amount":-0.5947265625},{"first":112,"second":39,"amount":-0.5947265625},{"first":112,"second":118,"amount":-0.2255859375},{"first":112,"second":120,"amount":-0.3076171875},{"first":112,"second":121,"amount":-0.2255859375},{"first":112,"second":122,"amount":-0.3076171875},{"first":114,"second":34,"amount":0.328125},{"first":114,"second":39,"amount":0.328125},{"first":114,"second":44,"amount":-2.5224609375},{"first":114,"second":46,"amount":-2.5224609375},{"first":114,"second":97,"amount":-0.8203125},{"first":114,"second":99,"amount":-0.3896484375},{"first":114,"second":100,"amount":-0.3896484375},{"first":114,"second":101,"amount":-0.3896484375},{"first":114,"second":103,"amount":-0.3896484375},{"first":114,"second":111,"amount":-0.41015625},{"first":114,"second":113,"amount":-0.3896484375},{"first":114,"second":118,"amount":0.369140625},{"first":114,"second":121,"amount":0.369140625},{"first":116,"second":111,"amount":-0.41015625},{"first":118,"second":34,"amount":0.3076171875},{"first":118,"second":39,"amount":0.3076171875},{"first":118,"second":44,"amount":-2.1943359375},{"first":118,"second":46,"amount":-2.1943359375},{"first":118,"second":97,"amount":-0.3076171875},{"first":118,"second":99,"amount":-0.2666015625},{"first":118,"second":100,"amount":-0.2666015625},{"first":118,"second":101,"amount":-0.2666015625},{"first":118,"second":103,"amount":-0.2666015625},{"first":118,"second":111,"amount":-0.3076171875},{"first":118,"second":113,"amount":-0.2666015625},{"first":119,"second":44,"amount":-2.54296875},{"first":119,"second":46,"amount":-2.54296875},{"first":120,"second":99,"amount":-0.41015625},{"first":120,"second":100,"amount":-0.41015625},{"first":120,"second":101,"amount":-0.41015625},{"first":120,"second":103,"amount":-0.41015625},{"first":120,"second":111,"amount":-0.41015625},{"first":120,"second":113,"amount":-0.41015625},{"first":121,"second":34,"amount":0.3076171875},{"first":121,"second":39,"amount":0.3076171875},{"first":121,"second":44,"amount":-2.1943359375},{"first":121,"second":46,"amount":-2.1943359375},{"first":121,"second":97,"amount":-0.3076171875},{"first":121,"second":99,"amount":-0.2666015625},{"first":121,"second":100,"amount":-0.2666015625},{"first":121,"second":101,"amount":-0.2666015625},{"first":121,"second":103,"amount":-0.2666015625},{"first":121,"second":111,"amount":-0.3076171875},{"first":121,"second":113,"amount":-0.2666015625},{"first":122,"second":99,"amount":-0.328125},{"first":122,"second":100,"amount":-0.328125},{"first":122,"second":101,"amount":-0.328125},{"first":122,"second":103,"amount":-0.328125},{"first":122,"second":111,"amount":-0.328125},{"first":122,"second":113,"amount":-0.328125},{"first":123,"second":74,"amount":-0.41015625},{"first":123,"second":85,"amount":-0.41015625}]}');

/***/ })

}]);