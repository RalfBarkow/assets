"use strict";
(globalThis["webpackChunk_croquet_microverse"] = globalThis["webpackChunk_croquet_microverse"] || []).push([["root_js"],{

/***/ "./apps/multiblaster.js":
/*!******************************!*\
  !*** ./apps/multiblaster.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiBlaster": () => (/* binding */ MultiBlaster)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
/* harmony import */ var _src_card_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/card.js */ "./src/card.js");




/////////// Model code is executed inside of synced VM /////////// 

class MultiBlaster extends _src_card_js__WEBPACK_IMPORTED_MODULE_1__.CardActor {
    get pawn(){ return MultiBlasterDisplay; }
    init(options) {
        super.init(options);
        this.beWellKnownAs("multiBlaster");
        this.ships = new Map();
        this.asteroids = new Set();
        this.blasts = new Set();
        this.subscribe(this.sessionId, "view-join", this.viewJoined);
        this.subscribe(this.sessionId, "view-exit", this.viewExited);
        this.subscribe(this.sessionId, "switch-pause", this.switchPause);
        Asteroid.create({});
        this.active = true;
        this.mainLoop();
    }

    switchPause() {
        console.log("switchPaused!!!!")
        this.active = !this.active;
    }

    viewJoined(viewId) {
        const ship = Ship.create({ viewId });
        this.ships.set(viewId, ship);
    }

    viewExited(viewId) {
        const ship = this.ships.get(viewId);
        this.ships.delete(viewId);
        ship.destroy();
    }

    checkCollisions() {
        for (const asteroid of this.asteroids) {
            if (asteroid.wasHit) continue;
            const minx = asteroid.x - asteroid.size;
            const maxx = asteroid.x + asteroid.size;
            const miny = asteroid.y - asteroid.size;
            const maxy = asteroid.y + asteroid.size;
            for (const blast of this.blasts) {
                if (blast.x > minx && blast.x < maxx && blast.y > miny && blast.y < maxy) {
                    asteroid.hitBy(blast);
                    break;
                }
            }
            for (const ship of this.ships.values()) {
                if (!ship.wasHit && ship.x + 10 > minx && ship.x - 10 < maxx && ship.y + 10 > miny && ship.y - 10 < maxy) {
                    if (!ship.score && Math.abs(ship.x-512) + Math.abs(ship.y-512) < 40) continue; // no hit if just spawned
                    ship.hitBy(asteroid);
                    break;
                }
            }
        }
    }

    mainLoop() {
        if(this.active){
            for (const ship of this.ships.values()) ship.move();
            for (const asteroid of this.asteroids) asteroid.move();
            for (const blast of this.blasts) blast.move();
            this.checkCollisions();
        }
        this.future(50).mainLoop(); // move & check every 50 ms
    }
}
MultiBlaster.register("MultiBlaster");

class Ship extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Actor {
    init({ viewId }) {
        super.init();
        this.viewId = viewId;
        this.reset();
        this.subscribe(viewId, "left-thruster", this.leftThruster);
        this.subscribe(viewId, "right-thruster", this.rightThruster);
        this.subscribe(viewId, "forward-thruster", this.forwardThruster);
        this.subscribe(viewId, "fire-blaster", this.fireBlaster);
    }

    reset() {
        this.x = 512;
        this.y = 512;
        this.a = -Math.PI / 2;
        this.dx = 0;
        this.dy = 0;
        this.left = false;
        this.right = false;
        this.forward = false;
        this.score = 0;
        this.wasHit = 0;
    }

    leftThruster(active) {
        if (this.wasHit) return;
        this.left = active;
    }

    rightThruster(active) {
        if (this.wasHit) return;
        this.right = active;
    }

    forwardThruster(active) {
        if (this.wasHit) return;
        this.forward = active;
    }

    fireBlaster() {
        if (this.wasHit) return;
        const dx = Math.cos(this.a) * 20;
        const dy = Math.sin(this.a) * 20;
        const x = this.x + dx;
        const y = this.y + dy;
        Blast.create({ x, y, dx, dy, ship: this });
    }

    move() {
        if (this.wasHit) {
            // keep drifting as debris for 3 seconds
            if (++this.wasHit > 60) this.reset();
        } else {
            // process thruster controls
            if (this.forward) {
                this.dx += Math.cos(this.a) * 0.5;
                this.dy += Math.sin(this.a) * 0.5;
                if (this.dx > 10) this.dx = 10;
                if (this.dx < -10) this.dx = -10;
                if (this.dy > 10) this.dy = 10;
                if (this.dy < -10) this.dy = -10;
            }
            if (this.left) this.a -= 0.2;
            if (this.right) this.a += 0.2;
            if (this.a < 0) this.a += Math.PI * 2;
            if (this.a > Math.PI * 2) this.a -= Math.PI * 2;
        }
        // drift through space
        this.x += this.dx;
        this.y += this.dy;
        if (this.x < 0) this.x += 1024;
        if (this.x > 1024) this.x -= 1024;
        if (this.y < 0) this.y += 1024;
        if (this.y > 1024) this.y -= 1024;
    }

    hitBy(asteroid) {
        // turn both into debris
        this.wasHit = 1;
        asteroid.wasHit = 1;
    }
}
Ship.register("Ship");

class Asteroid extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Actor {
    init({ size, x, y, a, dx, dy, da }) {
        super.init();
        if (size) {
            // init second asteroid after spliting
            this.size = size;
            this.x = x;
            this.y = y;
            this.a = a;
            this.dx = dx;
            this.dy = dy;
            this.da = da;
        } else {
            // init new large asteroid
            this.size = 40;
            this.x = Math.random() * 400 - 200;
            this.y = Math.random() * 400 - 200;
            this.a = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 1;
            this.dx = Math.cos(this.a) * speed;
            this.dy = Math.sin(this.a) * speed;
            this.da = (0.02 + Math.random() * 0.03) * (Math.random() < 0.5 ? 1 : -1);
            this.wasHit = 0;
            this.move();
        }
        this.wellKnownModel("multiBlaster").asteroids.add(this);
    }

    move() {
        if (this.wasHit) {
            // keep drifting as debris, larger pieces drift longer
            if (++this.wasHit > this.size) this.destroy();
        }
        this.x += this.dx;
        this.y += this.dy;
        if (this.x < 0) this.x += 1024;
        if (this.x > 1024) this.x -= 1024;
        if (this.y < 0) this.y += 1024;
        if (this.y > 1024) this.y -= 1024;
        if (!this.wasHit) {
            this.a += this.da;
            if (this.a < 0) this.a += Math.PI * 2;
            if (this.a > Math.PI * 2) this.a -= Math.PI * 2;
        }
    }

    hitBy(blast) {
        if (!blast.ship.wasHit) blast.ship.score++;
        if (this.size > 20) {
            // split into two smaller faster asteroids
            this.size *= 0.7;
            this.da *= 1.5;
            this.dx = -blast.dy * 10 / this.size;
            this.dy = blast.dx * 10 / this.size;
            Asteroid.create({ size: this.size, x: this.x, y: this.y, a: this.a, dx: -this.dx, dy: -this.dy, da: this.da });
        } else {
            // turn into debris
            this.wasHit = 1;
        }
        blast.destroy();
    }

    destroy() {
        const asteroids = this.wellKnownModel("multiBlaster").asteroids;
        asteroids.delete(this);
        super.destroy();
        // keep at least 5 asteroids around
        if (asteroids.size < 5) Asteroid.create({});
    }
}
Asteroid.register("Asteroid");

class Blast extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Actor {
    init({x, y, dx, dy, ship}) {
        super.init();
        this.ship = ship;
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
        this.t = 0;
        this.wellKnownModel("multiBlaster").blasts.add(this);
    }

    move() {
        // move for 1.5 second before disappearing
        if (++this.t < 30) {
            this.x += this.dx;
            this.y += this.dy;
            if (this.x < 0) this.x += 1024;
            if (this.x > 1024) this.x -= 1024;
            if (this.y < 0) this.y += 1024;
            if (this.y > 1024) this.y -= 1024;
        } else {
            this.destroy();
        }
    }

    destroy() {
        this.wellKnownModel("multiBlaster").blasts.delete(this);
        super.destroy();
    }
}
Blast.register("Blast");


/////////// Code below is executed outside of synced VM /////////// 

// Copyright 2021 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io

class MultiBlasterDisplay extends _src_card_js__WEBPACK_IMPORTED_MODULE_1__.CardPawn {
    constructor(actor) {
        super(actor);

        this.addEventListener("pointerDown", "onPointerDown");
        this.addEventListener("pointerMove", "onPointerMove");
        this.addEventListener("pointerUp", "onPointerUp");
        this.addEventListener("keyDown", "onKeyDown");
        this.addEventListener("keyUp", "onKeyUp");

        this.smoothing = new WeakMap(); // position cache for interpolated rendering

        this.context = this.canvas.getContext("2d");
        this.future(50).doUpdate();
    }

    onPointerDown(p3d) {
        if (!p3d.uv) {return;}
        this.joystick = this.uv2xy(p3d.uv);
        this.knob = this.joystick;
    }

    onPointerMove(p3d) {
        if (!p3d.uv) {return;}
        this.knob= this.uv2xy(p3d.uv);
        let dx = this.knob[0]- this.joystick[0];
        let dy = this.knob[1] - this.joystick[1];
        if (dx > 30) {
            if (!this.right) { this.publish(this.viewId, "right-thruster", true); this.right = true; }
        } else if (this.right) { this.publish(this.viewId, "right-thruster", false); this.right = false; }
        if (dx < -30) {
            if (!this.left) { this.publish(this.viewId, "left-thruster", true); this.left = true; }
        } else if (this.left) { this.publish(this.viewId, "left-thruster", false); this.left = false; }
        if (dy < -30) {
            if (!this.forward) { this.publish(this.viewId, "forward-thruster", true); this.forward = true; }
        } else if (this.forward) { this.publish(this.viewId, "forward-thruster", false); this.forward = false; }
    }

    onPointerUp(p3d) {
        if (!p3d.uv) {return;}
        if (!this.right && !this.left && !this.forward) {
            this.publish(this.viewId, "fire-blaster");
        }
        if (this.right) { this.publish(this.viewId, "right-thruster", this.false); this.right = false; }
        if (this.left) { this.publish(this.viewId, "left-thruster", false); this.left = false;  }
        if (this.forward) { this.publish(this.viewId, "forward-thruster", false); this.forward = false; }

        this.joystick = null;
        this.knob= null;
    }

    onPointerCancel(p3d) {
        this.onPointerUp(p3d);
    }

    onKeyDown(e) {
        //joystick.style.display = "none";
        if (e.repeat) return;
        switch (e.key) {
            case "a": case "A": case "ArrowLeft":  this.publish(this.viewId, "left-thruster", true); break;
            case "d": case "D": case "ArrowRight": this.publish(this.viewId, "right-thruster", true); break;
            case "w": case "W": case "ArrowUp":    this.publish(this.viewId, "forward-thruster", true); break;
            case " ":                              this.publish(this.viewId, "fire-blaster"); break;
            case "p": case "P":                    this.publish(this.actor.sessionId, "switch-pause"); break;
        }
    }

    onKeyUp(e) {
        if (e.repeat) return;
        switch (e.key) {
            case "a": case "A": case "ArrowLeft":  this.publish(this.viewId, "left-thruster", false); break;
            case "d": case "D": case "ArrowRight": this.publish(this.viewId, "right-thruster", false); break;
            case "w": case "W": case "ArrowUp":    this.publish(this.viewId, "forward-thruster", false); break;
        }
    }

    // update is called once per render frame
    // read from shared model, interpolate, render

    setup() {
    }

    doUpdate() {
        if(this.actor.active){
            this.context.clearRect(0, 0, 1024, 1024);
            this.context.font = '40px sans-serif';
            this.context.fillStyle = "rgba(255, 255, 255, 0.5)";
            this.context.lineWidth = 3;
            this.context.strokeStyle = "white";
            for (const ship of this.actor.ships.values()) {
                const { x, y, a } = this.smoothPosAndAngle(ship);
                this.context.save();
                this.context.translate(x, y);
                if (ship.score) this.context.fillText(ship.score, 30, 15);
                this.context.rotate(a);
                if (ship.wasHit) this.drawShipDebris(ship.wasHit);
                else this.drawShip(ship.forward, ship.viewId === this.viewId);
                this.context.restore();
            }
            for (const asteroid of this.actor.asteroids) {
                const { x, y, a } = this.smoothPosAndAngle(asteroid);
                this.context.save();
                this.context.translate(x, y);
                this.context.rotate(a);
                if (asteroid.wasHit) this.drawAsteroidDebris(asteroid.size, asteroid.wasHit * 2);
                else this.drawAsteroid(asteroid.size);
                this.context.restore();
            }
            for (const blast of this.actor.blasts) {
                const { x, y } = this.smoothPos(blast);
                this.context.save();
                this.context.translate(x, y);
                this.drawBlast();
                this.context.restore();
            }
            if(this.joystick)this.drawJoystick();
            this.texture.needsUpdate = true;
        }
        this.future(50).doUpdate();
    }

    smoothPos(obj) {
        if (!this.smoothing.has(obj)) {
            this.smoothing.set(obj, { x: obj.x, y: obj.y, a: obj.a });
        }
        const smoothed = this.smoothing.get(obj);
        const dx = obj.x - smoothed.x;
        const dy = obj.y - smoothed.y;
        if (Math.abs(dx) < 50) smoothed.x += dx * 0.3; else smoothed.x = obj.x;
        if (Math.abs(dy) < 50) smoothed.y += dy * 0.3; else smoothed.y = obj.y;
        return smoothed;
    }

    smoothPosAndAngle(obj) {
        const smoothed = this.smoothPos(obj);
        const da = obj.a - smoothed.a;
        if (Math.abs(da) < 1) smoothed.a += da * 0.3; else smoothed.a = obj.a;
        return smoothed;
    }

    drawJoystick() {
        this.drawCircle(this.joystick, 50, false);
        this.drawCircle(this.knob, 25, true);
    }

    drawCircle(pos, radius, filled) {
        this.context.fillStyle = '#ffffff';
        this.context.beginPath();
        this.context.arc(pos[0], pos[1], radius, 0, Math.PI*2, true);
        if(filled)this.context.fill();
        else this.context.stroke();
    }

    drawShip(thrust, highlight) {
        this.context.beginPath();
        this.context.moveTo(+20,   0);
        this.context.lineTo(-20, +10);
        this.context.lineTo(-20, -10);
        this.context.closePath();
        this.context.stroke();
        if (highlight) {
            this.context.fill();
        }
        if (thrust) {
            this.context.beginPath();
            this.context.moveTo(-20, +5);
            this.context.lineTo(-30,  0);
            this.context.lineTo(-20, -5);
            this.context.stroke();
        }
    }

    drawShipDebris(t) {
        this.context.beginPath();
        this.context.moveTo(+20 + t,   0 + t);
        this.context.lineTo(-20 + t, +10 + t);
        this.context.moveTo(-20 - t * 1.4, +10);
        this.context.lineTo(-20 - t * 1.4, -10);
        this.context.moveTo(-20 + t, -10 - t);
        this.context.lineTo(+20 + t,   0 - t);
        this.context.stroke();
    }

    drawAsteroid(size) {
        this.context.beginPath();
        this.context.moveTo(+size,  0);
        this.context.lineTo( 0, +size);
        this.context.lineTo(-size,  0);
        this.context.lineTo( 0, -size);
        this.context.closePath();
        this.context.stroke();
    }

    drawAsteroidDebris(size, t) {
        this.context.beginPath();
        this.context.moveTo(+size + t,  0 + t);
        this.context.lineTo( 0 + t, +size + t);
        this.context.moveTo(-size - t,  0 - t);
        this.context.lineTo( 0 - t, -size - t);
        this.context.moveTo(-size - t,  0 + t);
        this.context.lineTo( 0 - t, +size + t);
        this.context.moveTo(+size + t,  0 - t);
        this.context.lineTo( 0 + t, -size - t);
        this.context.stroke();
    }

    drawBlast() {
        this.context.beginPath();
        this.context.ellipse(0, 0, 2, 2, 0, 0, 2 * Math.PI);
        this.context.closePath();
        this.context.stroke();
    }
}


/***/ }),

/***/ "./root.js":
/*!*****************!*\
  !*** ./root.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "basenames": () => (/* binding */ basenames),
/* harmony export */   "startWorld": () => (/* binding */ startWorld)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
/* harmony import */ var _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @croquet/worldcore-three */ "./node_modules/@croquet/worldcore-three/index.js");
/* harmony import */ var _src_physics_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/physics.js */ "./src/physics.js");
/* harmony import */ var _src_text_text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/text/text.js */ "./src/text/text.js");
/* harmony import */ var _src_card_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/card.js */ "./src/card.js");
/* harmony import */ var _src_avatar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/avatar.js */ "./src/avatar.js");
/* harmony import */ var _src_code_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/code.js */ "./src/code.js");
/* harmony import */ var _src_portal_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/portal.js */ "./src/portal.js");
/* harmony import */ var _src_worldSaver_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/worldSaver.js */ "./src/worldSaver.js");
/* harmony import */ var _apps_multiblaster_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./apps/multiblaster.js */ "./apps/multiblaster.js");
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! fflate */ "./node_modules/fflate/esm/browser.js");
/* harmony import */ var _src_wcAssetManager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/wcAssetManager.js */ "./src/wcAssetManager.js");
/* harmony import */ var _three_threeLibsLoader_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./three/threeLibsLoader.js */ "./three/threeLibsLoader.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io












// apps -------------------------------------------





// import {loadThreeJSLib} from "./src/ThreeJSLibLoader.js";


// turn off antialiasing for mobile and safari
// Safari has exhibited a number of problems when using antialiasing. It is also extremely slow rendering webgl. This is likely on purpose by Apple.
// Firefox seems to be dissolving in front of our eyes as well. It is also much slower. 
// mobile devices are usually slower, so we don't want to run those with antialias either. Modern iPads are very fast but see the previous line.
let AA = true;
const isSafari = navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1;
if(isSafari)AA=false;
const isFirefox = navigator.userAgent.includes('Firefox');
if(isFirefox)AA=false;
const isMobile = !!("ontouchstart" in window);
if(isMobile)AA=false;
console.log("antialias is: ", AA, 'mobile:', isMobile, 'browser:', isFirefox?'Firefox':isSafari?'Safari':'Other Browser' );

console.log('%cTHREE.REVISION:', 'color: #f00', _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.REVISION);

/*
function loadLoaders() {
    return loadThreeJSLib("postprocessing/Pass.js", THREE)
        .then(() => loadThreeJSLib("shaders/CopyShader.js", THREE))
        .then(() => loadThreeJSLib("csm/CSMFrustum.js", THREE))
        .then(() => loadThreeJSLib("csm/CSMShader.js", THREE))
        .then(()=>{
            let libs = [
                "loaders/OBJLoader.js",
                "loaders/MTLLoader.js",
                "loaders/GLTFLoader.js",
                "loaders/FBXLoader.js",
                "loaders/DRACOLoader.js",
                "loaders/SVGLoader.js",
                "loaders/EXRLoader.js",
                "utils/BufferGeometryUtils.js",
                "csm/CSM.js"
            ];

            window.JSZip = JSZip;
            window.fflate = fflate;

            return Promise.all(libs.map((file) => {
                return loadThreeJSLib(file, THREE);
            }));
        });
}
*/

function loadLoaders() {
    window.JSZip = (jszip__WEBPACK_IMPORTED_MODULE_10___default());
    window.fflate = fflate__WEBPACK_IMPORTED_MODULE_13__;
    return (0,_three_threeLibsLoader_js__WEBPACK_IMPORTED_MODULE_12__.loadThreeLibs)(_croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE);
}

function basenames() {
    let pathname = window.location.pathname;
    let match = /([^/]+)\.html$/.exec(pathname);
    let basename = new URL(window.location).searchParams.get("world");

    if (!basename) {
        basename = (!match || match[1] === "index") ? "default" : match[1];
    }

    let basedir;
    if (match) {
        basedir = pathname.slice(0, match.index);
    } else {
        let slash = pathname.lastIndexOf("/");
        basedir = pathname.slice(0, slash + 1);
    }

    return {basedir, basename};
}

function loadInitialBehaviors(paths, directory) {
    let library = _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.Library || new _src_code_js__WEBPACK_IMPORTED_MODULE_6__.CodeLibrary();
    _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.Library = library;
    if (!paths || !directory) {return;}
    let {basedir, _pathname} = basenames();

    if (!directory) {
        throw new Error("directory argument has to be specified. It is a name for a sub directory name under the ./behaviors directory.");
    }
    let isSystem = directory === _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.SystemBehaviorDirectory;
    let promises = paths.map((path) => {
        if (!isSystem) {
            let code = `import('${basedir}${directory}/${path}')`;
            return eval(code).then((module) => {
                let rest = directory.slice("behaviors/".length);
                return [`${rest}/${path}`, module];
            })
        } else {
            let modulePath =  `${directory.split("/")[1]}/${path}`;
            let code = `import('${basedir}behaviors/${modulePath}')`;
            return eval(code).then((module) => {
                return [modulePath, module];
            })
        }
    });

    return Promise.all(promises).then((array) => {
        array.forEach((pair) => {
            let [path, module] = pair;
            let dot = path.lastIndexOf(".");
            let fileName = path.slice(0, dot);
            library.add(module.default, fileName, isSystem);
        });
        return true;
    });
}

class MyPlayerManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.PlayerManager {
    init(name) {
        super.init(name);
        this.avatarCount = 0;

        this.presentationMode = null; // or the viewId of the leader
        this.followers = new Set();

        this.subscribe("playerManager", "create", this.playerCreated);
        this.subscribe("playerManager", "destroy", this.playerDestroyed);
        this.subscribe("playerManager", "enter", this.playerEnteredWorld);
        this.subscribe("playerManager", "leave", this.playerLeftWorld);
    }

    createPlayer(playerOptions) {
        // when we have a better user management,
        // options will be compatible with a card spec
        // until then, we check the AvatarNames variable, and if it is a short name
        // (as it is) it'd fall back to use the short string as a stem of the model file name.
        // if it is an object, we use it as the card spec.

        let index = this.avatarCount % _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.AvatarNames.length;
        this.avatarCount++;
        let avatarSpec = _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.AvatarNames[index];
        console.log("MyPlayerManager", this.avatarCount);
        let options = {...playerOptions};
        options.noSave = true;
        options.type = "3d";
        options.singleSided = true;

        if (typeof avatarSpec === "string") {
            options.name = avatarSpec;
            options.dataScale = [0.3, 0.3, 0.3];
            options.dataRotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, Math.PI, 0);
            options.dataTranslation = [0, -0.4, 0];
            options.dataLocation = `./assets/avatars/${options.name}.zip`;
        } else {
            options = {...options, ...avatarSpec};
        }

        let behaviorManager = this.service("BehaviorModelManager");

        if (behaviorManager && behaviorManager.modules.get("AvatarEventHandler")) {
            let modules;
            if (!options.behaviorModules) {
                options.behaviorModules = ["AvatarEventHandler"];
            } else {
                options.behaviorModules = [...options.behaviorModules, "AvatarEventHandler"];
            }
        }

        return _src_avatar_js__WEBPACK_IMPORTED_MODULE_5__.AvatarActor.create(options);
    }

    destroyPlayer(player) {
        if (player.inWorld) player.set({inWorld: false});
        super.destroyPlayer(player);
    }

    playerInWorldChanged(player) {
        if (player.inWorld) {
            this.publish("playerManager", "enter", player);
        } else {
            this.publish("playerManager", "leave", player);
        }
    }

    playersInWorld() {
        return [...this.players.values()].filter((player) => player.inWorld);
    }

    startPresentation(playerId, teleport) {
        if (this.presentationMode && this.presentationMode !== playerId) {
            return; // somebody is already presenting
        }

        this.presentationMode = playerId;

        let { translation, rotation } = this.players.get(playerId);

        this.playersInWorld().forEach((player) => {
            this.followers.add(player.playerId);
            if (teleport) {
                player.set({ translation, rotation });
                player.say("forceOnPosition");
            }
        });
        this.publish("playerManager", "presentationStarted", playerId);
        this.publish("playerManager", "playerCountChanged");
    }

    stopPresentation() {
        this.presentationMode = null;
        this.publish("playerManager", "presentationStopped");
        this.publish("playerManager", "playerCountChanged");
        this.followers.clear();
    }

    leavePresentation(playerId) {
        if (this.presentationMode === playerId) {return;}
        this.followers.delete(playerId);
        this.publish("playerManager", "playerCountChanged");
    }

    playerEnteredWorld(player) {
        console.log(this.sessionId, "playerEnteredWorld", player);
        if (this.presentationMode) {
            this.followers.add(player.playerId);
            player.presentationStarted(this.presentationMode, true);
        }
        this.publish("playerManager", "playerCountChanged");
    }

    playerLeftWorld(player) {
        console.log(this.sessionId, "playerLeftWorld", player);
        if (player.playerId === this.presentationMode) {
            this.stopPresentation();
        }
        this.followers.delete(player.playerId);
        this.publish("playerManager", "playerCountChanged");
    }

    playerCreated(_player) {
        this.publish("playerManager", "playerCountChanged");
    }

    playerDestroyed(_player) {
        this.publish("playerManager", "playerCountChanged");
    }
}

MyPlayerManager.register("MyPlayerManager");

class MyModelRoot extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ModelRoot {
    static modelServices() {
        return [
            MyPlayerManager,
            _src_card_js__WEBPACK_IMPORTED_MODULE_4__.MicroverseAppManager,
            _src_code_js__WEBPACK_IMPORTED_MODULE_6__.BehaviorModelManager,
            _src_text_text_js__WEBPACK_IMPORTED_MODULE_3__.FontModelManager,
            ...(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.UseRapier ? [{service: _src_physics_js__WEBPACK_IMPORTED_MODULE_2__.RapierPhysicsManager, options: {useCollisionEventQueue: true}}] : [])
        ];
    }
    init(options, persistentData) {
        super.init(options);

        let appManager = this.service("MicroverseAppManager");
        appManager.add(_apps_multiblaster_js__WEBPACK_IMPORTED_MODULE_9__.MultiBlaster);
        appManager.add(_src_text_text_js__WEBPACK_IMPORTED_MODULE_3__.TextFieldActor);
        appManager.add(_src_portal_js__WEBPACK_IMPORTED_MODULE_7__.PortalActor);

        this.ensurePersistenceProps();
        this.subscribe(this.sessionId, "triggerPersist", "triggerPersist");
        this.subscribe(this.id, "loadStart", "loadStart");
        this.subscribe(this.id, "loadOne", "loadOne");
        this.subscribe(this.id, "loadDone", "loadDone");

        if (persistentData) {
            this.loadPersistentData(persistentData);
            return;
        }

        this.loadBehaviorModules(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.Library.modules, "1");
        this.load(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.DefaultCards, "1");
    }

    ensurePersistenceProps() {
        if (!this.persistPeriod) {
            let period = 1 * 60 * 1000;
            this.persistPeriod = period;
        }
        if (this.lastPersistTime === undefined) {
            this.lastPersistTime = 0;
        }

        if (this.persistRequested === undefined) {
            this.persistRequested = false;
        }
    }

    loadPersistentData({ _name, version, data }) {
        try {
            delete this.loadingPersistentDataErrored;
            this.loadingPersistentData = true;

            let saver = new _src_worldSaver_js__WEBPACK_IMPORTED_MODULE_8__.WorldSaver(_src_card_js__WEBPACK_IMPORTED_MODULE_4__.CardActor);
            let json = saver.parse(JSON.stringify(data));

            //maybe we need to delete all DefaultUserBehaviors at this point.

            let lib = _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.Library;
            let systemModules = new Map();

            for (let [k, v] of lib.modules) {
                if (v.systemModule) {
                    systemModules.set(k, v);
                }
            }

            this.loadBehaviorModules(systemModules, version);

            this.loadBehaviorModules(json.behaviorModules, version);
            if (json.cards) {
                this.load(json.cards, version);
            }
        } catch (error) {
            console.error("error in loading persistent data", error);
            this.loadingPersistentDataErrored = true;
        } finally {
            delete this.loadingPersistentData;
        }
    }

    savePersistentData() {
        if (this.loadingPersistentData) {return;}
        if (this.loadingPersistentDataErrored) {return;}
        this.lastPersistTime = this.now();
        let func = () => this.saveData();
        this.persistSession(func);
    }

    saveData() {
        let name = this.sessionName || "Unknown";
        let saver = new _src_worldSaver_js__WEBPACK_IMPORTED_MODULE_8__.WorldSaver(_src_card_js__WEBPACK_IMPORTED_MODULE_4__.CardActor);
        let json = saver.save(this);
        let string = saver.stringify(json);
        return {name, version: "1", data: JSON.parse(string)};
    }

    loadBehaviorModules(moduleDefs, version) {
        // the persistent data should never contain a system behavior
        if (version === "1") {
            let behaviorManager = this.service("BehaviorModelManager");
            return behaviorManager.loadLibraries([...moduleDefs.values()]);
        }
        return null;
    }

    load(cards, version) {
        if (version === "1") {
            return _src_card_js__WEBPACK_IMPORTED_MODULE_4__.CardActor.load(cards, this, version);
        }
    }

    triggerPersist() {
        let now = this.now();
        let diff = now - this.lastPersistTime;
        let period = this.persistPeriod;
        if (diff < period) {
            if (!this.persistRequested) {
                this.persistRequested = true;
                this.future(period - diff).triggerPersist();
            }
            //console.log("persist not ready");
            return;
        }
        this.lastPersistTime = now;
        this.persistRequested = false;
        this.savePersistentData();
    }

    loadStart(key) {
        this.loadKey = key;
        this.loadBuffer = [];
    }

    loadOne(data) {
        let {key, buf} = data;
        if (key !== this.loadKey) {return;}
        this.loadBuffer.push(buf);
    }

    loadDone(data) {
        let {key, asScene, pose} = data;
        if (key !== this.loadKey) {return;}

        let array = this.loadBuffer;
        this.loadBuffer = [];
        this.loadKey = null;

        if (!array) {
            console.log("inconsistent message");
            return;
        }

        let len = array.reduce((acc, cur) => acc + cur.length, 0);
        let all = new Uint8Array(len);
        let ind = 0;
        for (let i = 0; i < array.length; i++) {
            all.set(array[i], ind);
            ind += array[i].length;
        }

        let result = new TextDecoder("utf-8").decode(all);
        let savedData = JSON.parse(result);
        if (savedData.version === "1") {
            let string = JSON.stringify(savedData.data);
            savedData.data = string;
            this.loadFromFile(savedData, asScene, pose);
        }
    }

    loadFromFile({ _name, version, data }, asScene, pose) {
        try {
            let saver = new _src_worldSaver_js__WEBPACK_IMPORTED_MODULE_8__.WorldSaver(_src_card_js__WEBPACK_IMPORTED_MODULE_4__.CardActor);
            let json = saver.parse(data);

            let nameMap = this.loadBehaviorModules(json.behaviorModules, version);
            if (json.cards) {
                let result = this.load({array: json.cards, nameMap: asScene ? null : nameMap}, version);
                if (pose) {
                    result.forEach((card) => {
                        card._translation = pose.translation;
                        card._rotation = pose.rotation;
                    });
                }
            }
        } catch (error) {
            console.error("error in loading persistent data", error);
        }
    }
}

MyModelRoot.register("MyModelRoot");

class MyViewRoot extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.ViewRoot {
    static viewServices() {
        return [
            _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.InputManager,
            {service: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.ThreeRenderManager, options:{useBVH: true, antialias:AA}},
            _src_wcAssetManager_js__WEBPACK_IMPORTED_MODULE_11__.AssetManager,
            _src_text_text_js__WEBPACK_IMPORTED_MODULE_3__.KeyFocusManager,
            _src_text_text_js__WEBPACK_IMPORTED_MODULE_3__.FontViewManager,
            _src_text_text_js__WEBPACK_IMPORTED_MODULE_3__.SyncedStateManager,
            _src_card_js__WEBPACK_IMPORTED_MODULE_4__.VideoManager,
            _src_code_js__WEBPACK_IMPORTED_MODULE_6__.BehaviorViewManager,
        ];
    }
    constructor(model) {
        super(model);
        const threeRenderManager = this.service("ThreeRenderManager");
        const renderer = threeRenderManager.renderer;
        window.scene = threeRenderManager.scene;

        this.service("FontViewManager").setModel(model.service("FontModelManager"));

        renderer.toneMapping = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2;
        renderer.shadowMap.enabled = true;
        renderer.localClippingEnabled = true;
    }
}

function deleteParameter(url, key) {
    const urlObj = new URL(url, location.href);
    urlObj.searchParams.delete(key);
    return urlObj.toString();
}

function startWorld(appParameters, world) {
    // appParameters are loaded from apiKey.js (see index.js)
    // and typically provide apiKey and appId

    let sessionParameters = {
        // microverse defaults
        name: appParameters.name || _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.App.autoSession(),
        password: appParameters.password || _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.App.autoPassword(),
        model: MyModelRoot,
        view: MyViewRoot,
        tps: 30,
        eventRateLimit: 60,
        options: {world},
        // developer can override defaults
        ...appParameters,
        // except for the 'microverse' flag
        // which identifies microverse sessions for billing
        flags: ["microverse"],
    };

    // remove portal parameter from url for QR code
    _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.App.sessionURL = deleteParameter(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.App.sessionURL, "portal");

    return loadLoaders()
        .then(() => {
            return loadInitialBehaviors(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.SystemBehaviorModules, _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.SystemBehaviorDirectory);
        }).then(() => {
            return loadInitialBehaviors(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.UserBehaviorModules, _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Constants.UserBehaviorDirectory);
        }).then(() => {
            return (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.StartWorldcore)(sessionParameters);
        }).then(() => {
            let {basedir} = basenames();
            return fetch(`${basedir}meta/version.txt`);
        }).then((response) => {
            if (`${response.status}`.startsWith("2")) {
                return response.text();
            }
            return "(version not found)";
        }).then((text) => {
            console.log(`
Croquet Microverse
${text}
https://croquet.io`.trim());
        });
}


/***/ }),

/***/ "./src/avatar.js":
/*!***********************!*\
  !*** ./src/avatar.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AvatarActor": () => (/* binding */ AvatarActor),
/* harmony export */   "AvatarPawn": () => (/* binding */ AvatarPawn)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
/* harmony import */ var _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @croquet/worldcore-three */ "./node_modules/@croquet/worldcore-three/index.js");
/* harmony import */ var _frame_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./frame.js */ "./src/frame.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./src/Pointer.js");
/* harmony import */ var _card_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./card.js */ "./src/card.js");
/* harmony import */ var _worldMenu_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./worldMenu.js */ "./src/worldMenu.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io










const EYE_HEIGHT = 1.676;
// const EYE_EPSILON = 0.01;
const FALL_DISTANCE = EYE_HEIGHT / 12;
const MAX_FALL = -15;
const MAX_V = 0.015;
const KEY_V = MAX_V / 2;
const MAX_SPIN = 0.0004;
const JOYSTICK_V = 0.000030;
const COLLIDE_THROTTLE = 50;
const THROTTLE = 15; // 20
const PORTAL_DISTANCE = 0.3;
const COLLISION_RADIUS = 0.8;
const isMobile = !!("ontouchstart" in window);
const M4_ROTATIONY_180 = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_rotationY)(Math.PI);
const Q_ROTATION_180 = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, Math.PI, 0);
let initialPortalLookExternal;


class AvatarActor extends (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.mix)(_card_js__WEBPACK_IMPORTED_MODULE_4__.CardActor).with(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.AM_Player) {
    init(options) {
        let playerId = options.playerId;
        delete options.playerId;
        super.init(options);
        this._playerId = playerId;

        let layers = options.layers;
        if (!layers) {
            layers = ["avatar"];
        } else if (!layers.includes("avatar")) {
            layers = [...layers, "avatar"];
        }

        this._layers = layers;
        this.lookPitch = 0;
        this.lookYaw = 0;
        this.lookOffset = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)();

        this.fall = false;
        this.tug = 0.05; // minimize effect of unstable wifi
        this.set({tickStep: 30});
        this.listen("goHome", this.goHome);
        this.listen("goThere", this.goThere);
        this.listen("startMMotion", this.startFalling);
        this.listen("avatarLookTo", this.onLookTo);
        this.listen("comeToMe", this.comeToMe);
        this.listen("followMeToWorld", this.followMeToWorld);
        this.listen("stopPresentation", this.stopPresentation);
        this.listen("inWorldSet", this.inWorldSet);
        this.listen("fileUploaded", "fileUploaded");
        this.listen("addSticky", this.addSticky);
        this.listen("textPasted", this.textPasted);
        this.listen("resetStartPosition", this.resetStartPosition);
        this.subscribe("playerManager", "presentationStarted", this.presentationStarted);
        this.subscribe("playerManager", "presentationStopped", this.presentationStopped);
        this.listen("leavePresentation", this.leavePresentation);
        this.future(0).tick();
    }

    get pawn() { return AvatarPawnFactory; }
    get lookNormal() { return (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_rotate)([0,0,-1], this.rotation); }
    get collisionRadius() { return this._cardData.collisionRadius || COLLISION_RADIUS; } // minimum collison radius for avatar
    get maxFall(){ return this._maxFall || MAX_FALL; } // max fall before we goHome()
    get fallDistance(){ return this._fallDistance || FALL_DISTANCE }; // how far we fall per update
    get inWorld() { return !!this._inWorld; }   // our user is either in this world or render

    leavePresentation() {
        if (!this.follow) {return;}
        let manager = this.service("PlayerManager");
        let presentationMode = manager.presentationMode;
        if (!presentationMode) {return;}
        if (this.follow !== this.playerId) {
            this.presentationStopped();
            this.say("setLookAngles", {lookOffset: [0, 0, 0]});
            manager.leavePresentation(this.playerId);
        }
    }

    stopPresentation() {
        this.service("PlayerManager").stopPresentation();
    }

    inWorldSet({o, v}) {
        if (!o !== !v) this.service("PlayerManager").playerInWorldChanged(this);
    }

    startFalling() {
        this.fall = true;
    }

    resetStartPosition() {
        this.goTo(this.translation, this.rotation, false);
    }

    onLookTo(data) {
        let [pitch, yaw, lookOffset] = data;
        if (pitch !== undefined) {this.lookPitch = pitch;}
        if (yaw !== undefined) {this.lookYaw = yaw;}
        if (lookOffset !== undefined) this.lookOffset = lookOffset;
        this.rotateTo((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, this.lookYaw, 0));
        this.restoreTargetId = undefined; // if you look around, you can't jump back
    }

    goHome() {
        let v, q;
        if (this._anchor) {
            v = this._anchor.translation;
            q = this._anchor.rotation;
        } else {
            v = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)();
            q = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_identity)();
        }
        this.goTo(v, q, false);
        this.lookOffset = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)();
        this.lookPitch = 0;
        this.lookYaw = 0;
        this.say("setLookAngles", {pitch: 0, yaw: 0, lookOffset: this.lookOffset});
    }

    goTo(v, q, fall) {
        this.leavePresentation();
        this.vStart = [...this.translation];
        this.qStart = [...this.rotation];
        this.vEnd = v;
        this.qEnd = q;
        this.fall = fall;
        this.goToStep(0.1);
        //this.set({translation: there[0], rotation: there[1]});
    }

    goThere(p3d) {
        this.leavePresentation();
        this.vStart = [...this.translation];
        this.qStart = [...this.rotation];

        if (!this.fall && (p3d.targetId === this.restoreTargetId)) { // jumpback if you are  doubleclicking on the same target you did before
            this.vEnd = this.restoreTranslation;
            this.qEnd = this.restoreRotation;
            this.restoreRotation = undefined;
            this.restoreTranslation = undefined;
            this.restoreTargetId = undefined;
        } else {
            this.fall = false; // sticky until we move
            this.restoreRotation = [...this.rotation];
            this.restoreTranslation = [...this.translation];
            this.restoreTargetId = p3d.targetId;
            let normal = [...(p3d.normal || this.lookNormal)]; //target normal may not exist
            let point = p3d.xyz;
            this.vEnd = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_add)(point, (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_scale)(normal, p3d.offset || EYE_HEIGHT));
            normal[1] = 0; // clear up and down
            let nsq = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sqrMag)(normal);
            if (nsq < 0.0001) {
                this.qEnd = this.rotation; // use the current rotation
            }else {
                normal = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_normalize)(normal);
                let theta = Math.atan2(normal[0], normal[2]);
                this.qEnd = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, theta, 0);
            }
            if (p3d.look) {
                let pitch = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_pitch)(this.qEnd);
                let yaw = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_yaw)(this.qEnd);
                this.lookPitch = pitch;
                this.lookYaw = yaw;
                this.say("setLookAngles", {pitch, yaw});
            }
        }
        this.goToStep(0.1);
    }

    comeToMe(teleport) {
        this.service("PlayerManager").startPresentation(this.playerId, teleport);
    }

    followMeToWorld(portalURL) {
        const manager = this.service("PlayerManager");
        if (manager.presentationMode === this.playerId) {
            for (const playerId of manager.followers) {
                if (playerId === this.playerId) continue;
                const follower = manager.player(playerId);
                follower.leaveToWorld(portalURL);
            }
        }
    }

    leaveToWorld(portalURL) {
        this.say("leaveToWorld", portalURL);
    }

    presentationStarted(playerId, teleport) {
        if (this.playerId !== playerId && this.inWorld) {
            let leader = this.service("PlayerManager").player(playerId);
            if (teleport) {
                this._translation = [...leader.translation];
                this._rotation = [...leader.rotation];
                this.say("forceOnPosition");
            } else {
                this.goTo(leader.translation, leader.rotation, false);
            }
            this.follow = playerId;
            this.fall = false;
            this._anchor = leader._anchor;
        }
    }

    presentationStopped() {
        this.follow = null;
    }

    goToStep(delta, t) {
        if (!t) t = delta;
        if (t >= 1) t = 1;
        let v = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_lerp)(this.vStart, this.vEnd, t);
        let q = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_slerp)(this.qStart, this.qEnd, t);
        this.positionTo({v, q});
        this.say("forceOnPosition");
        if (t < 1) this.future(50).goToStep(delta, t + delta);
    }

    tick(_delta) {
        if (this.follow) {
            let followMe = this.service("PlayerManager").players.get(this.follow);
            if (followMe) {
                this.positionTo({v: followMe._translation, q: followMe._rotation});
                this.lookOffset = followMe.lookOffset;
                this.lookPitch = followMe.lookPitch;
                this.lookYaw = followMe.lookYaw;
                this.say("setLookAngles", {pitch: followMe.lookPitch, yaw: followMe.lookYaw, lookOffset: followMe.lookOffset});
            } else {
                this.presentationStopped();
            }
        }
        if (!this.doomed) this.future(this._tickStep).tick(this._tickStep);
    }

    dropPose(distance, optOffset) {
        // compute the position in front of the avatar
        // optOffset is perpendicular (on the same xz plane) to the lookNormal

        let n = this.lookNormal;
        let t = this.translation;
        let r = this.rotation;
        if (!optOffset) {
            let p = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_add)((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_scale)(n, distance), t);
            return {translation: p, rotation: r};
        }

        let q = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, -Math.PI / 2, 0);
        let perpendicular = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_rotate)(n, q);
        let offset = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_multiply)(optOffset, perpendicular);
        let p = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_add)((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_add)((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_scale)(n, distance), t), offset);
        return {translation:p, rotation:r};
    }

    fileUploaded(data) {
        let {dataId, fileName, type, translation, rotation} = data;
        let appManager = this.service("MicroverseAppManager");
        let CA = appManager.get("CardActor");

        let cardType = type === "exr" ? "lighting" : (type === "svg" || type === "img" || type === "pdf" ? "2d" : "3d");

        let options = {
            name: fileName,
            translation,
            rotation,
            type: cardType,
            fileName,
            modelType: type,
            shadow: true,
            singleSided: true
        };

        if (type === "img") {
            options = {
                ...options,
                textureLocation: dataId,
                textureType: "image",
                scale: [4, 4, 4],
                cornerRadius: 0.02,
                fullBright: false,
            };
        } else if (type === "pdf") {
            options = {
                ...options,
                behaviorModules: ["PDFView"],
                scale: [4, 4, 4],
                layers: ["pointer"],
                type: "2d",
                frameColor: 0xffffff,
                color: 0x888888,
                depth: 0.05,
                fullBright: true,
                pdfLocation: dataId
            };
        } else {
            options = {...options, dataLocation: dataId};
        }

        if (type !== "exr") {
            CA.load([{card: options}], this.wellKnownModel("ModelRoot"), "1")[0];
        } else {
            let light = [...this.service("ActorManager").actors.values()].find(o => o._cardData.type === "lighting");
            if (light) {
                light.updateOptions({...light._cardData, dataLocation: dataId, dataType: "exr"});
            }
        }

        this.publish(this.sessionId, "triggerPersist");
    }

    textPasted({string, translation, rotation}) {
        if (string.startsWith("http://") || string.startsWith("https://")) {
            this.createPortal(translation, rotation, string);
        } else {
            this.createStickyNote(translation, rotation, string);
        }
    }

    addSticky(pe) {
        const tackOffset = 0.1;
        let tackPoint = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_add)(pe.xyz, (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_scale)(pe.normal, tackOffset));
        let normal = [...pe.normal]; // clear up and down
        normal[1] = 0;
        let nsq = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sqrMag)(normal);
        let rotation;
        if (nsq > 0.0001) {
            normal = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_normalize)(normal);
            let theta = Math.atan2(normal[0], normal[2]);
            rotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, theta, 0);
        } else {
            rotation = this.rotation;
            tackPoint[1] += 2;
        }
        this.createStickyNote(tackPoint, rotation);
    }

    createStickyNote(translation, rotation, text) {
        let appManager = this.service("MicroverseAppManager");
        let CA = appManager.get("CardActor");

        let runs = [];
        if (!text) {
            text = "";
        }
        runs.push({text});
        let options = {
            name:'sticky note',
            className: "TextFieldActor",
            behaviorModules: ["StickyNote"],
            translation,
            rotation,
            type: "text",
            depth: 0.05,
            margins: {left: 20, top: 20, right: 20, bottom: 20},
            backgroundColor: 0xf4e056,
            frameColor: 0xfad912,
            runs,
            width: 1,
            height: 1,
            textScale: 0.002
        };

        CA.load([{card: options}], this.wellKnownModel("ModelRoot"), "1")[0];
        this.publish(this.sessionId, "triggerPersist");
    }

    createPortal(translation, rotation, portalURL) {
        let appManager = this.service("MicroverseAppManager");
        let CA = appManager.get("CardActor");

        // sigh - all portals are "backwards"
        // or maybe *all* models are backwards and we need to fix dropPose and avatar models?
        rotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_multiply)(Q_ROTATION_180, rotation); // flip by 180 degrees

        let card = {
            name: "portal",
            className: "PortalActor",
            translation,
            rotation,
            type: "2d",
            layers: ["pointer", "portal"],
            color: 0xFF66CC,
            frameColor: 0x888888,
            width: 3,
            height: 3,
            depth: 0.2,
            cornerRadius: 0.05,
            portalURL,
            sparkle: false,
        };

        CA.load([{card}], this.wellKnownModel("ModelRoot"), "1");
        this.publish(this.sessionId, "triggerPersist");
    }
}

AvatarActor.register('AvatarActor');

class AvatarPawnFactory extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.View {
    constructor(actor) {
        super(actor);
        if (this.viewId === actor.playerId) {
            return new AvatarPawn(actor);
        }
        return new RemoteAvatarPawn(actor);
    }
}

const PM_SmoothedDriver = superclass => class extends superclass {
    constructor(options) {
        super(options);
        this.throttle = 125; //ms
        this.ignore("scaleSet");
        this.ignore("rotationSet");
        this.ignore("translationSet");
        this.ignore("positionSet");
    }

    // If our global changes, so do the globals of our children
    globalChanged() {
        if (!this._global && this.renderObject && !this.renderObject.matrixWorldNeedsUpdate) {
            this.refreshDrawTransform();
            if (this.children)  {
                this.children.forEach(child => child.onGlobalChanged());
            }
        }
    }

    positionTo(v, q, throttle) {
        if (!this.actor.follow) {
            throttle = throttle || this.throttle;
            // we have special case here for avatar movement
            if ((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_equals)(this.actor.translation, v, 0) && (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_equals)(this.actor.rotation, q, 0)) {return;}

            this._translation = v;
            this._rotation = q;
            this.onLocalChanged();
            this.isTranslating = false;
            this.isRotating = false;
        }
        super.positionTo(v, q, throttle);
        this.globalChanged();
    }

    scaleTo(v, throttle) {
        if (!this.actor.follow) {
            throttle = throttle || this.throttle;
            this._scale = v;
            this.onLocalChanged();
            this.isScaling = false;
        }
        super.scaleTo(v, throttle);
        this.globalChanged();
    }

    rotateTo(q, throttle) {
        if (!this.actor.follow) {
            throttle = throttle || this.throttle;
            this._rotation = q;
            this.onLocalChanged();
            this.isRotating = false;
        }
        super.rotateTo(q, throttle);
        this.globalChanged();
    }

    translateTo(v, throttle)  {
        if (!this.actor.follow) {
            throttle = throttle || this.throttle;
            this._translation = v;
            this.isTranslating = false;
            this.onLocalChanged();
        }
        super.translateTo(v, throttle);
        this.globalChanged();
    }
}

class RemoteAvatarPawn extends (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.mix)(_card_js__WEBPACK_IMPORTED_MODULE_4__.CardPawn).with(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.PM_Player, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.PM_ThreeVisible) {
    constructor(actor) {
        super(actor);
        this.lastUpdateTime = 0;
        this.opacity = 1;

        this.spin = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_identity)();
        this.velocity = [0, 0, 0];

        this.lookPitch = this.actor.lookPitch;
        this.lookYaw = this.actor.lookYaw;
        this.lookOffset = [0, 0, 0]; // Vector displacing the camera from the avatar origin.
        this._rotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, this.lookYaw, 0);

        this.tug = 0.06; // instead of default 0.2, to work with spaced updates
    }

    setOpacity(opacity) {
        if (this.shape) {
            let transparent = opacity !== 1;
            this.shape.visible = this.actor.inWorld && opacity !== 0;
            this.shape.traverse(n => {
                if (n.material) {
                    n.material.opacity = opacity;
                    n.material.transparent = transparent;
                    n.material.side = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DoubleSide;
                    n.material.needsUpdate = true;
                }
            });
        }
    }
}

class AvatarPawn extends (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.mix)(_card_js__WEBPACK_IMPORTED_MODULE_4__.CardPawn).with(_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.PM_Player, PM_SmoothedDriver, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.PM_ThreeVisible, _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.PM_ThreeCamera, _Pointer_js__WEBPACK_IMPORTED_MODULE_3__.PM_Pointer) {
    constructor(actor) {
        super(actor);
        this.lastUpdateTime = 0;
        this.lastCollideTime = 0;
        this.lastPortalTime = 0;
        this.lastCollideTranslation = this.actor.translation;
        this.opacity = 1;

        this.spin = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_identity)();
        this.velocity = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)();

        this.lookPitch = this.actor.lookPitch;
        this.lookYaw = this.actor.lookYaw;
        this.lookOffset = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)(); // Vector displacing the camera from the avatar origin.
        this._rotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, this.lookYaw, 0);
        this.portalLookExternal = initialPortalLookExternal;

        this.isFalling = false;

        let renderMgr = this.service("ThreeRenderManager");
        this.camera = renderMgr.camera;
        this.scene = renderMgr.scene;
        this.lastHeight = EYE_HEIGHT; // tracking the height above ground
        this.yawDirection = -1; // which way the mouse moves the world depends on if we are using WASD or not

        this.walkCamera = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Object3D();

        this.walkcaster = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Raycaster(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(), new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, - 1, 0));
        this.portalcaster = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Raycaster(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(), new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(), 0, PORTAL_DISTANCE);

        this.future(100).fadeNearby();

        // clip halfspace behind portalCamera
        this.portalClip = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, 0, -1), 0);

        // 0.2 is to cover the gap of the portal thickness
        // if there is no anchor, this is the default clip plane
        // otherwise it will be updated below

        document.getElementById("homeBttn").onclick = () => this.goHome();
        document.getElementById("usersComeHereBttn").onclick = () => this.comeToMe();
        document.getElementById("editModeBttn").setAttribute("mobile", isMobile);
        document.getElementById("editModeBttn").setAttribute("pressed", false);

        let editButton = document.getElementById("editModeBttn");
        editButton.onpointerdown = (evt) => this.setEditMode(evt);
        editButton.onpointerup = (evt) => this.clearEditMode(evt);

        (0,_worldMenu_js__WEBPACK_IMPORTED_MODULE_5__.setupWorldMenuButton)(this, _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.App, this.sessionId);

        this.assetManager = this.service("AssetManager");
        window.assetManager = this.assetManager.assetManager;

        // drop and paste
        this.assetManager.assetManager.setupHandlersOn(document, (buffer, fileName, type) => {
            if (type === "pastedtext") {
                this.pasteText(buffer);
            } else if (type === "vrse") {
                this.loadvrse(buffer);
            } else {
                this.uploadFile(buffer, fileName, type);
            }
        });

        // keep track of being in the primary frame or not
        this.isPrimary = _frame_js__WEBPACK_IMPORTED_MODULE_2__.isPrimaryFrame;
        // this.say("_set", { inWorld: this.isPrimary });
        this.shellListener = (command, { frameType, spec, cameraMatrix, dx, dy, updateTime, forwardTime }) => {
            switch (command) {
                case "frame-type":
                    const isPrimary = frameType === "primary";
                    if (isPrimary !== this.isPrimary) {
                        this.frameTypeChanged(isPrimary, spec);
                        this.isPrimary = isPrimary;
                        this.lastPortalTime = Date.now();
                    }
                    // tell shell that we received this command (TODO: should only send this once)
                    (0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.sendToShell)("started");
                    break;
                case "start-sync-rendering":
                    renderMgr.setRender(false);
                    break;
                case "stop-sync-rendering":
                    renderMgr.setRender(true);
                    break;
                case "sync-render-now":
                    // console.log(Date.now() - updateTime);
                    renderMgr.composer.render();
                    break;
                case "portal-update":
                    if (cameraMatrix) {
                        this.portalLookExternal = cameraMatrix;
                        initialPortalLookExternal = cameraMatrix;
                        if (!this.isPrimary) {
                            this.refreshCameraTransform();
                            renderMgr.composer.render();
                            const renderedTime = Date.now();
                            (0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.sendToShell)("portal-world-rendered", { updateTime, forwardTime, renderedTime });
                        }
                    }
                    break;
                case "motion-start":
                    this.startMMotion();
                    if (dx || dy) this.updateMMotion(dx, dy);
                    break;
                case "motion-end":
                    this.endMMotion();
                    break;
                case "motion-update":
                    this.updateMMotion(dx, dy);
                    break;
            }
        }
        ;(0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.addShellListener)(this.shellListener);
        //initialize actor
        const actorSpec = { inWorld: this.isPrimary };
        const anchor = this.anchorFromURL(window.location, !this.isPrimary);
        if (anchor) {
            actorSpec.anchor = anchor; // actor or {translation, rotation}
            actorSpec.translation = anchor.translation;
            actorSpec.rotation = anchor.rotation;
        }
        this.say("_set", actorSpec);
        this.say("resetStartPosition");

        this.subscribe("playerManager", "playerCountChanged", this.showNumbers);
        this.listen("setLookAngles", this.setLookAngles);
        this.listen("leaveToWorld", this.leaveToWorld);
        this.showNumbers();

        //this.listenOnce("forceScaleSet", this.onScale);
        this.listen("forceOnPosition", this.onPosition);

        this.listen("goThere", this.stopFalling);
        console.log("MyPlayerPawn created", this, "primary:", this.isPrimary);

        this.wasdVelocity = [0, 0, 0];
        this.wasdMap = {w: false, a: false, d: false, s: false};
    }

    get presenting() {
        return this.actor.service("PlayerManager").presentationMode === this.viewId;
    }

    onPosition() {
        this._rotation = this.actor.rotation;
        this._translation = this.actor.translation;
        this.onLocalChanged();
    }

    setLookAngles(data) {
        let {pitch, yaw, lookOffset} = data;
        if (pitch !== undefined) {this.lookPitch = pitch;}
        if (yaw !== undefined) {this.lookYaw = yaw;}
        if (lookOffset !== undefined) {this.lookOffset = lookOffset;}
    }

    async uploadFile(buffer, fileName, type) {
        let handle = await _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Data.store(this.sessionId, buffer);
        let dataId = _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.Data.toId(handle);
        let pose = this.dropPose(6);
        this.say("fileUploaded", {
            dataId, fileName, type: /^(jpe?g|png|gif)$/.test(type) ? "img" : type,
            translation: pose.translation,
            rotation: pose.rotation
        });
    }

    async pasteText(string) {
        const MAX_PASTE_LENGTH = 2000;
        if (string.length > MAX_PASTE_LENGTH) {
            console.warn("Paste too long, truncating");
            string = string.substr(0, MAX_PASTE_LENGTH);
        }
        let pose = this.dropPose(6);
        this.say("textPasted", {
            string,
            translation: pose.translation,
            rotation: pose.rotation
        });
    }

    loadvrse(buffer) {
        let result = new TextDecoder("utf-8").decode(buffer);
        this.loadFromFile(result, false, true);
    }

    dropPose(distance, optOffset) { // compute the position in front of the avatar
        return this.actor.dropPose(distance, optOffset);
    }

    // if our URL specifies an anchor, this is our home location
    anchorFromURL(url, viaPortal) {
        const { actors } = this.actor.service("ActorManager");
        const { searchParams } = new URL(url);
        const anchorString = searchParams.get("anchor");
        if (!anchorString) {
            // if we are coming via a portal but with no anchor, assume the first portal
            if (viaPortal) {
                for (const actor of actors.values()) {
                    if (actor.isPortal) return actor;
                }
            }
            // otherwise use the default anchor
            for (const actor of actors.values()) {
                if (actor._cardData.spawn === "default") return actor;
            }
            // otherwise come in at [0,0,0]
            return null;
        }
        // see if it's a named actor
        for (const actor of actors.values()) {
            if (actor.name === anchorString) return actor;
        }
        // otherwise it might be explicit coordinates
        const coords = anchorString.split(",").map(x => parseFloat(x));
        if (coords.length !== 7 || coords.some(x => isNaN(x))) return null;
        const [vx, vy, vz, ru, rv, rw, rq] = coords;
        return {
            translation: [vx, vy, vz],
            rotation: [ru, rv, rw, rq]
        }
    }

    showNumbers() {
        let manager = this.actor.service("PlayerManager");
        let comeHere = document.getElementById("usersComeHereBttn");
        let userCountReadout = comeHere.querySelector("#userCountReadout");
        if (userCountReadout) {
            // TODO: change PlayerManager to only create avatars for players that are actually in the world
            let total = manager.players.size;
            let here = manager.playersInWorld().length;
            let tooltip = `${here} ${here === 1 ? "user is" : "users are"} in this world`;
            if (here !== total) {
                let watching = total - here;
                tooltip += `, ${watching} ${watching === 1 ? "user has" : "users have"} not entered yet`;
                total = `${here}+${watching}`;
            }
            if (manager.presentationMode) {
                let followers = manager.followers.size;
                userCountReadout.textContent = `${followers}/${total}`;
                tooltip = `${followers} ${followers === 1 ? "user" : "users"} in guided tour, ${tooltip}`;
            } else {
                userCountReadout.textContent = `${total}`;
            }
            comeHere.setAttribute("title", tooltip);
        }

        comeHere.setAttribute("presenting", this.presenting);
    }

    setEditMode(evt) {
        evt.target.setAttribute("pressed", true);
        evt.target.setPointerCapture(evt.pointerId);
        evt.stopPropagation();
        this.service("InputManager").setModifierKeys({ctrlKey: true});
    }

    clearEditMode(evt) {
        evt.target.setAttribute("pressed", false);
        evt.target.releasePointerCapture(evt.pointerId);
        evt.stopPropagation();
        this.service("InputManager").setModifierKeys({ctrlKey: false});
    }

    maybeLeavePresentation() {
        if (this.actor.follow) {
            this.say("leavePresentation");
        }
    }

    lookTo(pitch, yaw, lookOffset) {
        this.maybeLeavePresentation();
        this.setLookAngles({pitch, yaw, lookOffset});
        this.say("avatarLookTo", [pitch, yaw, lookOffset]);
        let q = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, this.lookYaw, 0);
        this.rotateTo(q);
    }

    destroy() {
        (0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.removeShellListener)(this.shellListener);
        // When the pawn is destroyed, we dispose of our Three.js objects.
        // the avatar memory will be reclaimed when the scene is destroyed - it is a clone, so leave the  geometry and material alone.
        super.destroy();
    }

    get lookGlobal() {
        if (this.lookOffset) {
            // This test above is relevant only at the start up.
            // This is called from ThreeCamera's constructor but
            // the look* values are not intialized yet.
            if (!this.isPrimary && this.portalLookExternal) return this.portalLook;
            else return this.walkLook;
        } else return this.global;
    }

    // the camera when walking: based on avatar but also 3rd person offset
    get walkLook() {
        const pitchRotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_axisAngle)([1,0,0], this.lookPitch);
        const m0 = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_translation)(this.lookOffset);
        const m1 = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_rotationQ)(pitchRotation);
        const m2 = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(m1, m0);
        return (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(m2, this.global);
    }

    // the camera when rendering world as portal: based on external camera
    // and our own anchor
    get portalLook() {
        // apply portal transform to external camera
        const anchor = this.anchor || this.actor._anchor || { translation: [0,0,0], rotation: [0,0,0,1] };
        const mtra = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_translation)(anchor.translation);
        const mrot = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_rotationQ)(anchor.rotation);
        const mrot_inv = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(mrot, M4_ROTATIONY_180); // flip by 180 degrees
        const mportal = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(mrot_inv, mtra);
        const mcam = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(this.portalLookExternal, mportal);
        // transform portal clip plane to match the anchor
        this.portalClip.normal.set(0, 0, -1);
        this.portalClip.constant = 0;
        const mclip = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Matrix4();
        mclip.set(...mrot);
        mclip.invert();
        this.portalClip.applyMatrix4(mclip);
        const pos = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(...anchor.translation);
        this.portalClip.constant = -this.portalClip.distanceToPoint(pos);
        // if portal is facing away from us, flip the clip plane
        // const facingAway = ???;
        // if (facingAway) {
        //     this.portalClip.normal.multiplyScalar(-1);
        //     this.portalClip.constant = -this.portalClip.constant;
        // }
        return mcam;
    }

    specForPortal(portal) {
        // we are about to enter this portal. meaning we disappear from this world and appear in the target world
        // visually nothing should change, so we need this avatar's position relative to the portal, as well as
        // its look pitch and offset. This will be passed to frameTypeChanged() in the target world.
        const t = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_invert)(portal.global);
        const m = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(this.global, t);
        // const log = (c, m) => console.log(c+"\n"+m.map((v, i) => +v.toFixed(2) + (i % 4 == 3 ? "\n" : ",")).join(''));
        // log("portal", portal.global);
        // log("avatar", this.global);
        // log("m", m);
        const translation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_getTranslation)(m);
        const rotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_getRotation)(m);
        return {
            translation,
            rotation,
            lookPitch: this.lookPitch,
            lookYaw: this.lookYaw,
            lookOffset: this.lookOffset,
            presenting: this.presenting,    // keep presenting
            cardData: this.actor._cardData, // keep avatar appearance
            url: portal.resolvePortalURL(),
        };
    }

    frameTypeChanged(isPrimary, spec) {
        // our avatar just came into or left this world, either through a portal
        // (in which case we have a view spec), or through a navigation event (browser's back/forward)
        // in all cases we set the actor's inWorld which will show/hide the avatar
        const enteringWorld = isPrimary;
        const leavingWorld = !isPrimary;
        const actorSpec = {
            inWorld: enteringWorld,
        };
        if (enteringWorld && spec) {
            let { translation, rotation } = spec;
            // transform spec relative to anchor
            const anchor = this.anchorFromURL(spec.url, true);
            if (anchor) {
                const m_avatar_tra = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_translation)(translation);
                const m_avatar_rot = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_rotationQ)(rotation);
                const m_avatar = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(m_avatar_rot, m_avatar_tra);
                const m_anchor_tra = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_translation)(anchor.translation);
                const m_anchor_rot = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_rotationQ)(anchor.rotation);
                const m_anchor_rot_inv = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(m_anchor_rot, M4_ROTATIONY_180); // flip by 180 degrees
                const m_anchor = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(m_anchor_rot_inv, m_anchor_tra);
                const m = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_multiply)(m_avatar, m_anchor);
                translation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_getTranslation)(m);
                rotation = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_getRotation)(m);
                actorSpec.anchor = anchor; // actor or {translation, rotation}
                this.anchor = anchor;
            }
            // move actor to the right place
            actorSpec.translation = translation;
            actorSpec.rotation = rotation;
            // keep avatar appearance
            actorSpec.cardData = spec.cardData;
            // move pawn to the right place
            this._translation = translation;
            this._rotation = rotation;
            this.onLocalChanged();
            // copy camera settings to pawn
            if (spec.lookPitch) this.lookPitch = spec.lookPitch;
            if (spec.lookYaw) this.lookYaw = spec.lookYaw;
            if (spec.lookOffset) this.lookOffset = spec.lookOffset;
        }
        if (leavingWorld) this.endMMotion();
        // now actually leave or enter the world (stops presenting in old world)
        console.log(`${(0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.frameName)()} setting actor`, actorSpec);
        this.say("_set", actorSpec);
        // start presenting in new space too
        if (enteringWorld && spec?.presenting) {
            let manager = this.actor.service("PlayerManager");
            if (!manager.presentationMode) {
                this.say("comeToMe", true);
            }
        }
        this.updatePortalRender();
    }

    leaveToWorld(portalURL) {
        if (this.isPrimary) {
            console.log(`${(0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.frameName)()} sending enter-world to ${portalURL}`);
            (0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.sendToShell)("enter-world", { portalURL });
        } else {
            console.log(`${(0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.frameName)()} not sending enter-world to ${portalURL}`);
        }
    }

    update(time, delta) {
        // console.log("position", this.translation);
        if (!this.actor.follow) {
            this.tug = 0.2;
            const manager = this.actor.service("PlayerManager");
            this.throttle = (manager.presentationMode === this.actor.playerId) ? 60 : 125;
            if (this.actor.inWorld) {
                let vq = this.updatePose(delta);
                if (this.collidePortal(vq)) {return;}
                if (!this.checkFloor(vq)) {
                    vq.v = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_lerp)(this.lastCollideTranslation, vq.v, -1);
                } else {
                    this.lastCollideTranslation = vq.v;
                }
                if (this.actor.fall && time - this.lastUpdateTime > THROTTLE) {
                    if (time - this.lastCollideTime > COLLIDE_THROTTLE) {
                        this.lastCollideTime = time;
                        vq = this.collide(vq);
                    }
                    this.lastUpdateTime = time;
                    this.positionTo(vq.v, vq.q);
                }
                this.refreshCameraTransform();
            }
        } else {
            this.tug = 0.06;
            super.update(time, delta);
        }
        this.updatePortalRender();
    }

    // compute motion from spin and velocity
    updatePose(delta) {
        let q, v;
        let tug = this.tug;
        if (delta) tug = Math.min(1, tug * delta / 15);

        if (!(0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_isZero)(this.spin)) {
            q = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_normalize)((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_slerp)(this.rotation, (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_multiply)(this.rotation, this.spin), tug));
        } else {
            q = this.rotation;
        }
        if (!(0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_isZero)(this.velocity)) {
            const relative = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_scale)(this.velocity, delta);
            const move = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_transform)(relative, (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.m4_rotationQ)(this.rotation));
            v = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_add)(this.translation, move);
        } else {
            v = this.translation;
        }

        return {v, q};
    }

    // update the camera transform and clipping planes if we are rendering a portal
    updatePortalRender() {
        let { clippingPlanes } = this.service("ThreeRenderManager").renderer;
        if (this.isPrimary) {
            // we are the top world, so we turn off portal clipping
            const idx = clippingPlanes.indexOf(this.portalClip);
            if (idx >= 0) clippingPlanes.splice(idx, 1);
        } else {
            // we are rendering a portal
            // if we have an anchor, the anchor may have been moved
            if (this.actor._anchor) {
                this.refreshCameraTransform(); // updates portalClip too
            }
            // turn on portal clipping
            if (!clippingPlanes.includes(this.portalClip)) {
                clippingPlanes.push(this.portalClip);
            }
            // check which half-space of the portal the camera is in,
            // and flip the portal's clip plane to the other side if needed

            // const cameraInFrontOfPortalPlane = this.lookGlobal[14] > 0;
            // const clippingBehindPortalPlane = this.portalClip.normal.z < 0;
            // if (clippingBehindPortalPlane !== cameraInFrontOfPortalPlane) {
            //     this.portalClip.normal.negate();
            // }

            // this ensures we can look "through" the portal from behind
            // and see the other half space
            // TODO: we assume the portal is at the origin looking down the z axis
            // when this is no longer true, we need to update this code
        }
    }

    checkFloor(vq) {
        let walkLayer = this.service("ThreeRenderManager").threeLayer("walk");
        let collideList = walkLayer.filter(obj => obj.collider);

        let someFloor = false;

        for (let j = 0; j < collideList.length; j++) {
            let c = collideList[j];
            let iMat = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Matrix4();
            iMat.copy(c.matrixWorld).invert();

            let down = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(0, -1, 0);
            let ray = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Ray(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(...vq.v), down);
            ray.applyMatrix4(iMat);
            let hit = c.children[0].geometry.boundsTree.raycastFirst(ray);
            someFloor = someFloor || hit;
        }

        return someFloor;
    }

    collideBVH(collideList, vq) {
        // uses:
        // https://github.com/gkjohnson/three-mesh-bvh
        // in particular, the characterMovement.js example

        let capsulePoint = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3();
        let triPoint = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3();

        const radius = this.actor.collisionRadius;
        const leg = EYE_HEIGHT / 2; // all fudge factors at this moment

        let positionChanged = false;

        let velocity = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sub)(vq.v, this.translation);
        // let currentPosition = this.translation;
        let newPosition = vq.v; // v3_add(currentPosition, stepVelocity);
        let onGround = false;

        for (let j = 0; j < collideList.length; j++) {
            let c = collideList[j];
            let iMat = c.children[0].matrixWorld.clone();
            iMat.invert();

            let segment = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Line3(
                new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(newPosition[0], newPosition[1], newPosition[2]),
                new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(newPosition[0], newPosition[1] - leg, newPosition[2])
            );

            let cBox = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Box3();
            cBox.makeEmpty();
            cBox.expandByPoint(segment.start);
            cBox.expandByPoint(segment.end);
            cBox.min.addScaledVector(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(-1, -1, -1), radius);
            cBox.max.addScaledVector(new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(1, 1, 1), radius);

            segment.applyMatrix4(iMat);
            cBox.applyMatrix4(iMat);

            let directions = [];
            // let start = Date.now();

            let maybeUp;

            c.children[0].geometry.boundsTree.shapecast({
                intersectsBounds: box => box.intersectsBox(cBox),
                intersectsTriangle: tri => {
                    const distance = tri.closestPointToSegment(segment, triPoint, capsulePoint);
                    if (distance < radius) {
                        const depth = radius - distance;
                        const direction = capsulePoint.sub(triPoint).normalize();

                        let h = Math.sqrt(direction.x ** 2 + direction.z ** 2);
                        let v = direction.y;

                        if (h < 0.1 && v > 0.9 && (!maybeUp || depth > maybeUp.depth)) {
                            maybeUp = tri.clone();
                            directions.unshift(maybeUp);
                        } else {
                            directions.push(tri.clone());
                        }
                    }
                }
            });

            directions.forEach((tri) => {
                const distance = tri.closestPointToSegment(segment, triPoint, capsulePoint);
                if (distance < radius) {
                    let depth = radius - distance;
                    const direction = capsulePoint.sub(triPoint).normalize();

                    // there is an issue when you double click a too low point, but it is
                    // a better problem than simply go up the wall
                    //if (direction.y < 0) {
                    //depth = -depth;
                    //}

                    segment.start.addScaledVector(direction, depth);
                    segment.end.addScaledVector(direction, depth);
                    positionChanged = true;
                }
            });

            // console.log(Date.now() - start);

            let outPosition = segment.start.clone();
            outPosition.applyMatrix4(c.children[0].matrixWorld); // convert back to world coordinates
            // outPosition.y -= centerLen;

            newPosition = outPosition.toArray();
            // console.log(deltaVector);
            onGround = onGround || positionChanged && velocity[1] < -0.1 && Math.abs(velocity[0]) < 0.001 && Math.abs(velocity[2]) < 0.001;
        }

        if (!this.checkFloor({v: newPosition, q: vq.q})) {
            let newv = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_lerp)(this.lastCollideTranslation, vq.v, -1);
            return {v: newv, q: vq.q};
        }

        if (onGround) {
            this.isFalling = false;
            return {v: this.translation, q: vq.q};
        }

        if (positionChanged) {
            this.isFalling = true;
            return {v: newPosition, q: vq.q};
        } else {
            this.isFalling = true;
            return vq;
        }
    }

    // given the 3D object, find the pawn
    pawnFrom3D(obj3d) {
        while (obj3d) {
            if (obj3d.wcPawn) return obj3d.wcPawn;
            obj3d = obj3d.parent;
        }
        return undefined;
    }

    collidePortal(vq) {
        let portalLayer = this.service("ThreeRenderManager").threeLayer("portal");
        if (!portalLayer) return false;

        // prevent re-entering the portal
        if (this.lastPortalTime > Date.now() - 500) return false;

        let dir = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_sub)(vq.v, this.translation);
        let len = Math.max((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_magnitude)(dir), PORTAL_DISTANCE);
        // not moving then return false
        if ((0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_isZero)(dir)) return false;

        dir = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_normalize)(dir);
        this.portalcaster.far = len;
        this.portalcaster.ray.direction.set(...dir);
        this.portalcaster.ray.origin.set(...this.translation);
        const intersections = this.portalcaster.intersectObjects(portalLayer, true);
        if (intersections.length > 0) {
            let portal = this.pawnFrom3D(intersections[0].object);
            if (portal) {
                // don't allow re-entering the portal
                this.lastPortalTime = Date.now();
                // remember which portal we left the world from
                this.anchor = portal.actor;
                // NOTE THIS IS NOT THE ONLY CODE PATH FOR ENTERING WORLDS
                // we also jump between worlds using the browser's "forward/back" buttons
                console.log((0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.frameName)(), "player", this.viewId, "enter portal", portal.portalId);
                // spec for this avatar in new world
                const avatarSpec = this.specForPortal(portal);
                // shell will swap iframes and trigger avatarPawn.frameTypeChanged() for this user in both worlds
                // but it also may delete this frame if is unowned
                (0,_frame_js__WEBPACK_IMPORTED_MODULE_2__.sendToShell)("portal-enter", { portalId: portal.portalId, avatarSpec });
                // if we were presenting, tell followers to come with us
                if (this.presenting) {
                    this.say("followMeToWorld", avatarSpec.url);
                    // calls leaveToWorld() in followers
                    // which will result in frameTypeChanged() on follower's clients
                }
                return true;
            }
        }
        return false;
    }

    collide(vq) {
        let walkLayer = this.service("ThreeRenderManager").threeLayer('walk');
        if (!walkLayer) return vq;

        let v = vq.v;

        if (this.isFalling) {
            v = [v[0], v[1] - this.actor.fallDistance, v[2]];
            this.isFalling = false;
            if (v[1] < this.actor.maxFall) {
                this.goHome();
                return {v: (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)(), q: (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_identity)()};
            }
        }

        let collideList = walkLayer.filter(obj => obj.collider);
        if (collideList.length > 0) {
            let a = this.collideBVH(collideList, {v, q: vq.q});
            window.abc = a;
            return a;
        }
        return vq;
    }

    startMMotion() {
        this.spin = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_identity)();
        this.velocity = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)();
        this.say("startMMotion");
    }

    endMMotion() {
        this.activeMMotion = false;
        this.spin = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_identity)();
        this.velocity = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_zero)();
    }

    updateMMotion(dx, dy) {
        // move the avatar

        let v = dy * JOYSTICK_V;

        v = Math.min(Math.max(v, -MAX_V), MAX_V);

        const yaw = dx * (isMobile ? -2.5 * MAX_SPIN : -MAX_SPIN);
        this.spin = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_euler)(0, yaw ,0);
        this.velocity = [0,0,v];
        this.maybeLeavePresentation();
    }

    keyDown(e) {
        let w = this.wasdVelocity;
        let nw;
        switch(e.key) {
            case 'Tab':
                this.jumpToNote(e); break;
            case 'w': case 'W': // forward
            case 'a': case 'A': // left strafe
            case 'd': case 'D': // right strafe
            case 's': case 'S': // backward
                this.yawDirection = -2;
                this.wasdMap[e.key.toLowerCase()] = true;
                switch (e.key) {
                    case 'w': case 'W': // forward
                        nw = w[2] === KEY_V ? 0 : -KEY_V;
                        this.wasdVelocity = [w[0], w[1], nw];
                        break;
                    case 'a': case 'A': // left strafe
                        nw = w[0] === KEY_V ? 0 : -KEY_V;
                        this.wasdVelocity = [nw, w[1], w[2]];
                        break;
                    case 'd': case 'D': // right strafe
                        nw = w[0] === -KEY_V ? 0 : KEY_V;
                        this.wasdVelocity = [nw, w[1], w[2]];
                        break;
                    case 's': case 'S': // backward
                        nw = w[2] === -KEY_V ? 0 : KEY_V;
                        this.wasdVelocity = [w[0], w[1], nw];
                        break;
                }
                this.velocity = this.wasdVelocity;
                this.maybeLeavePresentation();
                break;
            default:
                if (e.ctrlKey) {
                    switch(e.key) {
                        case 'a':
                            console.log("MyAvatar");
                            console.log("translation: ",this.actor.translation);
                            console.log("rotation:", (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_pitch)(this.actor.rotation),
                                (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_yaw)(this.actor.rotation), (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_roll)(this.actor.rotation));
                            console.log("scale:", this.actor.scale);
                            break;
                        case 'p':
                            if (this.profiling) {
                                console.log("end profiling");
                                console.profileEnd("profile");
                                this.profiling = false;
                            } else {
                                this.profiling = true;
                                console.log("start profiling");
                                console.profile("profile");
                            }
                            break;
                        case 'r':
                            let renderer = this.service("ThreeRenderManager").renderer;
                            console.log("Scene polycount:", renderer.info.render.triangles)
                            console.log("Active Drawcalls:", renderer.info.render.calls)
                            console.log("Textures in Memory", renderer.info.memory.textures)
                            console.log("Geometries in Memory", renderer.info.memory.geometries)
                            break;
                    }
                }
            /* console.log(e) */
        }
    }

    keyUp(e) {
        switch(e.key) {
            case 'w': case 'W': // forward
            case 'a': case 'A': // left strafe
            case 'd': case 'D': // right strafe
            case 's': case 'S': // backward
                this.yawDirection = -1;
                this.wasdMap[e.key.toLowerCase()] = false;
                let h;
                if (this.wasdMap.a && !this.wasdMap.d) {
                    h = -0.01;
                } else if (!this.wasdMap.a && this.wasdMap.d) {
                    h = 0.01;
                } else {
                    h = 0;
                }
                let v;
                if (this.wasdMap.w && !this.wasdMap.s) {
                    v = -0.01;
                } else if (!this.wasdMap.w && this.wasdMap.s) {
                    v = 0.01;
                } else {
                    v = 0;
                }
                this.wasdVelocity = [h, 0, v];
                this.velocity = this.wasdVelocity;;
        }
    }

    addSticky(e) {
        if (e.shiftKey) {
            const render = this.service("ThreeRenderManager");
            const rc = this.pointerRaycast(e.xy, render.threeLayerUnion('pointer', 'walk'));
            let pe = this.pointerEvent(rc, e);
            this.say("addSticky", pe);
        }
    }

    stopFalling() {
        this.isFalling = false;
    }

    xy2yp(xy) {
        let camera = this.service("ThreeRenderManager").camera;
        let fov = camera.fov / 2;
        let h = window.innerHeight / 2;
        let w = window.innerWidth / 2;
        let c = (fov * Math.PI / 180) / h;
        return[c * (xy[0] - w), c * (h - xy[1])];
    }

    pointerDown(e) {
        if (e.ctrlKey) { // should be the first responder case
            const render = this.service("ThreeRenderManager");
            const rc = this.pointerRaycast(e.xy, render.threeLayerUnion('pointer'));
            this.targetDistance = rc.distance;
            let p3e = this.pointerEvent(rc, e);
            p3e.lookNormal = this.actor.lookNormal;
            let pawn = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.GetPawn)(p3e.targetId);
            pawn = pawn || null;

            if (this.editPawn !== pawn) {
                if (this.editPawn) {
                    console.log('pointerDown clear old editPawn')
                    this.editPawn.unselectEdit();
                    this.editPawn = null;
                    this.editPointerId = null;
                }
                console.log('pointerDown set new editPawn', pawn)
                if (pawn) {
                    this.editPawn = pawn;
                    this.editPointerId = e.id;
                    this.editPawn.selectEdit();
                    this.buttonDown = e.button;
                    if (!p3e.normal) {p3e.normal = this.actor.lookNormal}
                    this.p3eDown = p3e;
                }
            } else {
                console.log("pointerDown in editMode");
            }
        } else {
            if (!this.focusPawn) {
                // because this case is called as the last responder, facusPawn should be always empty
                this.dragWorld = this.xy2yp(e.xy);
                this.lookYaw = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_yaw)(this._rotation);
            }
        }
    }

    pointerMove(e) {
        if (this.editPawn) {
            // a pawn is selected for draggging
            if (e.id === this.editPointerId) {
                if (this.buttonDown === 0) {
                    this.editPawn.dragPlane(this.setRayCast(e.xy), this.p3eDown);
                }else if (this.buttonDown == 2) {
                    this.editPawn.rotatePlane(this.setRayCast(e.xy), this.p3eDown);
                }
            }
        }else {
            // we should add and remove responders dynamically so that we don't have to check things this way
            if (!this.focusPawn && this.isPointerDown) {
                let yp = this.xy2yp(e.xy);
                let yaw = (this.lookYaw + (this.dragWorld[0] - yp[0]) * this.yawDirection);
                let pitch = this.lookPitch + this.dragWorld[1] - yp[1];
                pitch = pitch > 1 ? 1 : (pitch < -1 ? -1 : pitch);
                this.dragWorld = yp;
                this.lookTo(pitch, yaw);
            }
        }
    }

    pointerUp(_e) {
        if (this.editPawn) {
            this.editPawn.unselectEdit();
            this.editPawn = null;
            this.editPointerId = null;
            this.p3eDown = null;
            this.buttonDown = null;
        }

        // Below is a workaround to support an incomplete user program.
        // If there are left over first responders (pointer capture) from a user object,
        // delete them here.
        if (this.firstResponders) {
            for (let [_eventType, array] of this.firstResponders) {
                for (let i = array.length - 1; i >= 0; i--) {
                    let obj = array[i];
                    if (obj.pawn !== this) {
                        array.splice(i, 1);
                    }
                }
            }
        }
    }

    pointerTap(_e) {
        if (this.editPawn) { // this gets set in pointerDown
            this.editPawn.unselectEdit();
            this.editPawn.showControls({avatar: this.actor.id,distance: this.targetDistance});
            this.editPawn = null;
            this.editPointerId = null;
        }
    }

    pointerWheel(e) {
        let z = this.lookOffset[2];
        z += Math.max(1,z) * e.deltaY / 1000.0;
        z = Math.min(100, Math.max(z,0));
        this.lookOffset = [this.lookOffset[0], z, z];
        let pitch = (this.lookPitch * 11 + Math.max(-z / 2, -Math.PI / 4)) / 12;
        this.lookTo(pitch, (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.q_yaw)(this._rotation), this.lookOffset); //,
    }

    fadeNearby() {
        let manager = this.actor.service("PlayerManager");
        let presentationMode = manager.presentationMode;
        for (let [_viewId, a] of manager.players) {
            // a for actor, p for pawn
            let p = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.GetPawn)(a.id);
            if (!this.actor.inWorld) {
                p.setOpacity(1); // we are not even here so don't affect their opacity
            } else if (a.follow) {
                p.setOpacity(0); // never render followers
            } else if ((p === this || (a._playerId === presentationMode && this.actor.follow)) && (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.v3_isZero)(a.lookOffset)) {
                p.setOpacity(0); // never render me or my leader in 1st person
            } else { // fade based on their (or our own) distance between avatar and camera
                let m = this.lookGlobal; // camera location
                let cv = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(m[12], m[13], m[14]);
                m = a.global; // avatar location
                let av = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Vector3(m[12], m[13], m[14]);
                // fade between 0.5 and 3.3 meters (but we used squared distance)
                let d = Math.min(Math.max((cv.distanceToSquared(av) - 0.7) / 10, 0), 1);
                p.setOpacity(d);
            }
        }
        this.future(100).fadeNearby();
    }

    setOpacity(opacity) {
        if (this.shape) {
            let transparent = opacity !== 1;
            this.shape.visible = this.actor.inWorld && opacity !== 0;
            this.shape.traverse(n => {
                if (n.material && n.material.opacity !== opacity) {
                    n.material.opacity = opacity;
                    n.material.transparent = transparent;
                    n.material.side = _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DoubleSide;
                    n.material.needsUpdate = true;
                }
            });
        }
    }

    goHome() {
        this.say("goHome");
    }

    comeToMe() {
        let manager = this.actor.service("PlayerManager");
        if (!manager.presentationMode) {
            this.say("comeToMe");
            return;
        }

        if (manager.presentationMode === this.viewId) {
            this.say("stopPresentation");
        }
    }

    jumpToNote(e) {
        // collect the notes and jump to the next one or last.
        let cards = this.actor.queryCards({methodName: "filterNotes"}, this);
        let lastIndex;
        if (this.lastCardId === undefined) {
            lastIndex = 0;
        } else {
            lastIndex = cards.findIndex(c => c.id === this.lastCardId);
            if (e.shiftKey) {
                lastIndex--;
            } else {
                lastIndex++;
            }
        }

        if (lastIndex >= cards.length) {
            lastIndex = 0;
        }

        if (lastIndex < 0) {
            lastIndex = cards.length - 1;
        }

        let newCard = cards[lastIndex];

        if (newCard) {
            this.lastCardId = newCard.id;
            let pawn = (0,_croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__.GetPawn)(newCard.id);
            let pose = pawn.getJumpToPose ? pawn.getJumpToPose() : null;

            if (pose) {
                let obj = {xyz: pose[0], offset: pose[1], look: true, targetId: newCard.id, normal: pawn.hitNormal || [0, 0, 1]};
                this.say("goThere", obj);
            }
        }
    }

    filterNotes(c) {
        return c._behaviorModules && c._behaviorModules.includes("StickyNote");
    }

    loadFromFile(data, asScene, inFront) {
        let model = this.actor.wellKnownModel("ModelRoot");

        let array = new TextEncoder().encode(data);
        let ind = 0;
        let key = Math.random();

        this.publish(model.id, "loadStart", key);

        while (ind < array.length) {
            let buf = array.slice(ind, ind + 2880);
            this.publish(model.id, "loadOne", {key, buf});
            ind += 2880;
        }

        let pose;

        if (inFront) {
            pose = this.dropPose(6);
        }
        this.publish(model.id, "loadDone", {asScene, key, pose});
    }
}


/***/ }),

/***/ "./src/frame.js":
/*!**********************!*\
  !*** ./src/frame.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addShellListener": () => (/* binding */ addShellListener),
/* harmony export */   "frameId": () => (/* binding */ frameId),
/* harmony export */   "frameName": () => (/* binding */ frameName),
/* harmony export */   "isPrimaryFrame": () => (/* binding */ isPrimaryFrame),
/* harmony export */   "removeShellListener": () => (/* binding */ removeShellListener),
/* harmony export */   "sendToShell": () => (/* binding */ sendToShell),
/* harmony export */   "worldName": () => (/* binding */ worldName)
/* harmony export */ });
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io

// if this frame is the primary frame, then this is the current world
let isPrimaryFrame;

// this is the portalId of the current frame
const frameId = new URL(window.location.href).searchParams.get("portal");

// this is the world of the current frame
const worldName = new URL(window.location.href).searchParams.get("world") || "default";

// a name for the frame
function frameName() {
    return `frame["${worldName}",${frameId}${isPrimaryFrame ? ",primary" : ""}]`;
}

// shared prefix for shell messages
const PREFIX = "croquet:microverse:";

// sending to shell
function sendToShell(command, args) {
    window.parent.postMessage({ message: PREFIX+command, ...args }, "*");
}

// registry of callback functions to receive from shell
const shellListeners = new Set();

function addShellListener(fn) {
    shellListeners.add(fn);
}

function removeShellListener(fn) {
    shellListeners.delete(fn);
}

// we register one global event listener for all messages from the shell
// that invokes all callbacks in the registry
window.addEventListener("message", e => {
    if (e.source === window.parent) {
        const { message }  = e.data;
        if (typeof message === "string" && message.startsWith(PREFIX)) {
            const command = message.slice(PREFIX.length);
            shellListeners.forEach(fn => fn(command, e.data));
        };
    }
});

addShellListener((command, data) => {
    // console.log(`${frameId} received: ${JSON.stringify(data)}`);
    if (command === "frame-type") {
        const primary = data.frameType === "primary";
        if (isPrimaryFrame !== primary) {
            console.log(frameName(), "frame-type", data.frameType);
            isPrimaryFrame = primary;
            document.body.style.background = "transparent";
            document.getElementById("hud").classList.toggle("primary-frame", isPrimaryFrame);
            if (isPrimaryFrame) window.focus();
        }
    }
});


/***/ }),

/***/ "./src/portal.js":
/*!***********************!*\
  !*** ./src/portal.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PortalActor": () => (/* binding */ PortalActor),
/* harmony export */   "PortalPawn": () => (/* binding */ PortalPawn)
/* harmony export */ });
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
/* harmony import */ var _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @croquet/worldcore-three */ "./node_modules/@croquet/worldcore-three/index.js");
/* harmony import */ var _card_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./card.js */ "./src/card.js");
/* harmony import */ var _frame_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./frame.js */ "./src/frame.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io








class PortalActor extends _card_js__WEBPACK_IMPORTED_MODULE_2__.CardActor {
    init(options) {
        super.init(options);
        this._isOpen = true;
        this._portalTime = this.now();
    }

    get isPortal() { return true; }

    get isOpen() { return this._isOpen; }
    get portalTime() { return this._portalTime; }

    get portalURL() { return this._cardData.portalURL; }

    get sparkle() { return this._cardData.sparkle; }

    get pawn() { return PortalPawn; }
}
PortalActor.register("PortalActor");

class PortalPawn extends _card_js__WEBPACK_IMPORTED_MODULE_2__.CardPawn {
    constructor(actor) {
        super(actor);

        this.createPortalMaterials();

        this.portalId = undefined;
        this.targetMatrix = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Matrix4();
        this.targetMatrixBefore = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Matrix4();
        this.openPortal();

        this.setGhostWorld({ v: this.actor._ghostWorld });
        this.listen("ghostWorldSet", this.setGhostWorld);
        this.listen("isOpenSet", this.setIsOpen);

        this.addEventListener("pointerDown", this.onPointerDown);
        this.addEventListener("keyDown", e => { switch (e.key) {
            case " ": this.enterPortal(); break;
            case "G": case "g": this.say("_set", { ghostWorld: this.actor._ghostWorld === null ? 20 : null}); break;
        }});

        this.shellListener = (command, data) => this.receiveFromShell(command, data);
        (0,_frame_js__WEBPACK_IMPORTED_MODULE_3__.addShellListener)(this.shellListener);
    }

    destroy() {
        this.closePortal();
        (0,_frame_js__WEBPACK_IMPORTED_MODULE_3__.removeShellListener)(this.shellListener);
        super.destroy();
    }

    get globalPlane() {
        if (!this._globalPlane) {
            this._globalPlane = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Plane();
            this._globalPlane.normal.set(0, 0, 1);
            this._globalPlane.applyMatrix4(this.shape.matrixWorld);
        }
        return this._globalPlane;
    }

    objectCreated(obj, options) {
        super.objectCreated(obj, options);
        this.applyPortalMaterial(obj);
        if (this.actor.sparkle) this.addParticles();
    }

    createPortalMaterials() {
        // "invisible" animated spiral portal
        this.portalMaterial = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `
                #include <clipping_planes_pars_vertex>
                varying vec3 vUv;
                void main() {
                    #include <begin_vertex>             // transformed = position
                    #include <project_vertex>           // mvPosition and gl_Position
                    #include <clipping_planes_vertex>   // vClipPosition
                    vUv = transformed;
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vUv;
                #include <clipping_planes_pars_fragment>
                void main() {
                    #include <clipping_planes_fragment>
                    float r = length(vUv.xy);
                    float angle = atan(vUv.y, vUv.x);
                    float v = sin(time * 30.0 - r * 1.0 + 5.0 * angle) + r - time * 2.0 + 2.0;
                    float alpha = clamp(v, 0.0, 1.0);
                    gl_FragColor = vec4(0, 0, 0, alpha); // we only care about alpha
                }
            `,
            clipping: true,
            // transparent: true,
            // blending: THREE.CustomBlending,
            // blendEquation: THREE.AddEquation,
            // blendSrc: THREE.ZeroFactor,
            // blendDst: THREE.OneMinusSrcAlphaFactor,
        });
    }

    applyPortalMaterial(obj) {
        if (!obj) obj = this.shape;
        if (!obj.material) obj = obj.children[0];
        if (!obj) return;

        const { isOpen } = this.actor;
        if (Array.isArray(obj.material)) {
            if (obj.material[0] !== this.portalMaterial) this.originalMaterial = obj.material[0];
            obj.material[0] = isOpen ? this.portalMaterial : this.originalMaterial;
        } else {
            if (obj.material !== this.portalMaterial) this.originalMaterial = obj.material;
            obj.material = isOpen ? this.portalMaterial : this.originalMaterial;
        }
    }

    addParticles() {
        if (this.particleSystem) return;
        const width = this.actor._cardData.width * 0.5 + 0.002;
        const height = this.actor._cardData.height * 0.5 + 0.002;
        const particles = 1000;
        const uniforms = {
            pointTexture: { value: new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.TextureLoader().load( './assets/images/spark.png' ) }
        };
        const shaderMaterial = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.ShaderMaterial( {
            uniforms,
            vertexShader: `
                attribute float size;
                #include <clipping_planes_pars_vertex>
                void main() {
                    #include <begin_vertex>
                    #include <project_vertex>
                    mvPosition += vec4( 0.0, 0.0, 0.1, 0.0 ); // offset towards camera to avoid z clipping
                    #include <clipping_planes_vertex>
                    gl_PointSize = size * ( 20.0 / -mvPosition.z );
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                #include <clipping_planes_pars_fragment>
                void main() {
                    #include <clipping_planes_fragment>
                    gl_FragColor = texture2D( pointTexture, gl_PointCoord );
                }
            `,
            clipping: true,
            blending: _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            vertexColors: true
        } );

        const positions = [];
        const sizes = [];
        for ( let i = 0; i < particles; i ++ ) {
            const edge = Math.random() * 2 - 1;
            const side = Math.random() < 0.5 ? 1 : -1;
            const swap = Math.random() < 0.5;
            positions.push((swap ? edge : side) * width);
            positions.push((swap ? side : edge) * height);
            positions.push(0);
            sizes.push(20);
        }
        const geometry = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.BufferGeometry();
        geometry.setAttribute( 'position', new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Float32BufferAttribute( positions, 3 ) );
        geometry.setAttribute( 'size', new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Float32BufferAttribute( sizes, 1 ).setUsage( _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.DynamicDrawUsage ) );

        this.particleSystem = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Points( geometry, shaderMaterial );

        this.shape.add(this.particleSystem);
    }

    removeParticles() {
        if (!this.particleSystem) return;
        this.shape.remove(this.particleSystem);
        this.particleSystem = undefined;
    }

    // double-click should move avatar to the front of the portal
    get hitNormal() {
        return [0, 0, -1];
    }

    update(t) {
        super.update();
        this.updatePortalCamera();
        this.updatePortalMaterial();
        this.updateParticles();
    }

    updatePortalCamera() {
        // if the portal's position with respect to the camera has changed, tell the
        // embedded world to re-render itself from the suitably adjusted camera angle.
        // while these changes continue, the shell will take over the scheduling of
        // the worlds' rendering with the goal of ensuring that the embedded world has
        // always finished its rendering by the time the outer world (and the portal)
        // is rendered.
        if (!this.portalId) return;
        const { targetMatrix, targetMatrixBefore, portalId } = this;
        const renderMgr = this.service("ThreeRenderManager");
        const { camera } = renderMgr;
        camera.updateMatrixWorld(true); // evidently not guaranteed to have been handled since last time, perhaps because the "synced" rendering is decoupled from render-objects' update() invocations
        this.renderObject.updateMatrixWorld(true); // ditto
        const frustum = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Frustum()
        const matrix = new _croquet_worldcore_three__WEBPACK_IMPORTED_MODULE_1__.THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        frustum.setFromProjectionMatrix(matrix);
        // if the portal isn't on view, tell the shell there's no need to do synchronised
        // rendering right now (even though the portal is moving)
        if (!frustum.intersectsObject(this.renderObject.children[0])) {
            (0,_frame_js__WEBPACK_IMPORTED_MODULE_3__.sendToShell)("portal-update", { portalId, cameraMatrix: null });
            return;
        }
        targetMatrix.copy(this.renderObject.matrixWorld);
        targetMatrix.invert();
        targetMatrix.multiply(camera.matrixWorld);
        if (!targetMatrixBefore.equals(targetMatrix)) {
            (0,_frame_js__WEBPACK_IMPORTED_MODULE_3__.sendToShell)("portal-update", { portalId, cameraMatrix: targetMatrix.elements, updateTime: Date.now() });
            targetMatrixBefore.copy(targetMatrix);
        }
    }

    updatePortalMaterial() {
        let { portalTime } = this.actor;
        const time = (this.extrapolatedNow() - portalTime) / 1000;
        this.portalMaterial.uniforms.time.value = time;
    }

    updateParticles() {
        if (this.actor.sparkle && !this.particleSystem) this.addParticles();
        else if (!this.actor.sparkle && this.particleSystem) this.removeParticles();
        if (!this.particleSystem) return;
        const { geometry} = this.particleSystem;
        const sizes = geometry.attributes.size.array;
        const time = Date.now() / 100;
        for ( let i = 0; i < sizes.length; i ++ ) {
            sizes[ i ] = 10 * ( 1 + Math.sin( 0.1 * i + time ) );
        }
        geometry.attributes.size.needsUpdate = true;
    }

    updateShape(options) {
        this.removeParticles();
        super.updateShape(options);
        this.updateParticles(); // rebuild with new shape
    }

    cardDataUpdated(data) {
        super.cardDataUpdated(data);
        if (this.didPropertyChange(data, "portalURL")) this.openPortal();
        if (this.didPropertyChange(data, "sparkle")) this.updateParticles();
    }

    refreshDrawTransform() {
        super.refreshDrawTransform();
        this._globalPlane = null;
    }

    onPointerDown() {
        // replay opening animation to remind user that this is a portal
        // and they can't interact with the inner world yet
        this.say("_set", {
            isOpen: !this.actor.isOpen,
            portalTime: this.now(),
        });
    }

    openPortal() {
        const portalURL = this.resolvePortalURL();
        (0,_frame_js__WEBPACK_IMPORTED_MODULE_3__.sendToShell)("portal-open", {
            portalURL,
            portalId: this.portalId, // initially undefined
        });
    }

    closePortal() {
        (0,_frame_js__WEBPACK_IMPORTED_MODULE_3__.sendToShell)("portal-close", { portalId: this.portalId });
        this.portalId = null;
        this.targetMatrixBefore.identity();
    }

    resolvePortalURL() {
        // if portalURL does not have a sessionName or password, we need to resolve it
        // we do this by appending our own sessionName and password to the URL
        let portalURL = this.actor.portalURL;
        const portalTempUrl = new URL(portalURL, location.href);
        const portalSearchParams = portalTempUrl.searchParams;
        const portalHashParams = new URLSearchParams(portalTempUrl.hash.slice(1));
        let sessionName = portalSearchParams.get("q");
        let password = portalHashParams.get("pw");
        if (!sessionName || !password) {
            const worldUrl = new URL(location.href);
            if (!sessionName) {
                sessionName = worldUrl.searchParams.get("q");
                password = '';
                portalSearchParams.set("q", sessionName);
            }
            if (!password) {
                const worldHashParams = new URLSearchParams(worldUrl.hash.slice(1));
                password = worldHashParams.get("pw");
                portalHashParams.set("pw", password);
                portalTempUrl.hash = portalHashParams.toString();
            }
        }
        // remove origin from portalURL if it is the same as the world URL
        // we could also construct an even shorter relative URL, but this is easier
        portalURL = portalTempUrl.toString();
        if (portalTempUrl.origin === location.origin) {
            portalURL = portalURL.slice(location.origin.length);
            if (portalTempUrl.pathname === location.pathname) {
                portalURL = portalURL.slice(location.pathname.length);
            }
        }
        if (this.actor.portalURL !== portalURL) this.say("setCardData", { portalURL });
        // send full URL to shell
        return portalTempUrl.toString();
    }

    setIsOpen({v}) {
        this.applyPortalMaterial();
        if (v) this.openPortal();
        else this.closePortal();
    }

    setGhostWorld({v}) {
        let canvas = document.getElementById("ThreeCanvas");
        let slider = document.getElementById("ghostSlider");
        if (typeof v === "number" && _frame_js__WEBPACK_IMPORTED_MODULE_3__.isPrimaryFrame) {
            // make our own world translucent, blurry, and desaturated so
            // the portal world becames visible
            slider.style.display = "block";
            slider.oninput = () => this.say("_set", { ghostWorld: +slider.value });
            canvas.style.filter = `opacity(${100 - v}%) saturate(${100-v}%) contrast(${80 + v * 0.2}%) blur(4px)`;
            slider.value = v;
        } else {
            slider.style.display = "none";
            canvas.style.filter = "";
        }
    }

    receiveFromShell(command, { portalId }) {
        switch (command) {
            case "portal-opened":
                this.portalId = portalId;
                this.updatePortalCamera();
                break;
            case "frame-type":
                this.updatePortalCamera();
                this.setGhostWorld({v: this.actor._ghostWorld});
                break;
        }
    }
}


/***/ }),

/***/ "./src/wcAssetManager.js":
/*!*******************************!*\
  !*** ./src/wcAssetManager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssetManager": () => (/* binding */ AssetManager)
/* harmony export */ });
/* harmony import */ var _assetManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assetManager.js */ "./src/assetManager.js");
/* harmony import */ var _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @croquet/worldcore-kernel */ "./node_modules/@croquet/worldcore-kernel/index.js");
// Copyright 2022 by Croquet Corporation, Inc. All Rights Reserved.
// https://croquet.io
// info@croquet.io





class AssetManager extends _croquet_worldcore_kernel__WEBPACK_IMPORTED_MODULE_1__.ViewService {
    constructor(name) {
        super(name || "AssetManager");
        this.assetManager = new _assetManager_js__WEBPACK_IMPORTED_MODULE_0__.AssetManager();
    }

    destroy() {
        super.destroy();
    }
}



/***/ }),

/***/ "./src/worldMenu.js":
/*!**************************!*\
  !*** ./src/worldMenu.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setupWorldMenuButton": () => (/* binding */ setupWorldMenuButton)
/* harmony export */ });
let worldMenu = null;
let worldMenuVisible = false;
let imageInput = null;

let isMobile = !!("ontouchstart" in window);

function qrPressed(_myAvatar, url) {
    let div = document.createElement("div");
    div.innerHTML = `<a id="link" target="_blank" rel="noopener noreferrer" href="${url}"></a>`;
    document.getElementById("hud").appendChild(div);
    let a = div.querySelector("#link");
    a.click();
    div.remove();
}

function savePressed(myAvatar) {
    let model = myAvatar.actor.wellKnownModel("ModelRoot");

    let div = document.createElement("a");

    let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(model.saveData(), null, 4));

    div.setAttribute("href", dataStr);
    div.setAttribute("download", "scene.vrse");
    div.click();
    if (worldMenuVisible) {
        toggleMenu();
    }
}

function loadPressed(myAvatar) {
    if (!imageInput) {
        let input = document.createElement("div");
        input.innerHTML = `<input id="imageinput" type="file" accept="application/json;">`;
        imageInput = input.firstChild;

        imageInput.onchange = () => {
            for (const file of imageInput.files) {
                new Promise(resolve => {
                    let reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsBinaryString(file);
                }).then((data) => {
                    myAvatar.loadFromFile(data);
                })
            }
            imageInput.value = "";
        };
    }

    document.getElementById("hud").appendChild(imageInput);

    imageInput.click();
    if (worldMenuVisible) {
        toggleMenu();
    }
}

function connectPressed() {
    window.BehaviorViewManager.setURL("ws://localhost:9011");
    if (worldMenuVisible) {
        toggleMenu();
    }
}

function switchQRView(_myAvatar) {
    let qrDiv = worldMenu.querySelector("#qrDiv");
    let statsDiv = worldMenu.querySelector("#statsDiv");

    let cls = "statsHidden";

    if (qrDiv.classList.contains(cls)) {
        qrDiv.classList.toggle(cls, false);
        statsDiv.classList.toggle(cls, true);
    } else {
        qrDiv.classList.toggle(cls, true);
        statsDiv.classList.toggle(cls, false);
    }
}

function forceStop(myAvatar) {
    myAvatar.say("stopPresentation");
    if (worldMenuVisible) {
        toggleMenu();
    }
}

function initWorldMenu(badge) {
    let html = document.createElement("div");
    html.id = "worldMenu";
    html.classList.add("worldMenu");

    html.appendChild(badge);
    badge.id = "worldMenu-qr";
    badge.classList.add("menu-qr", "menu-item");

    let buttons = `
<div id="worldMenu-save" class="menu-label menu-item">
    <span class="menu-label-text">Save</span>
    <div class="menu-icon save-icon"></div>
</div>
<div id="worldMenu-load" class="menu-label menu-item">
    <span class="menu-label-text">Load</span>
    <div class="menu-icon load-icon"></div>
</div>
<div id="worldMenu-connect" class="menu-label menu-item">
    <span class="menu-label-text">Connect</span>
    <div class="menu-icon connect-icon"></div>
</div>`.trim();

    let div = document.createElement("div");
    div.innerHTML = buttons;

    let save = div.querySelector("#worldMenu-save");
    let load = div.querySelector("#worldMenu-load");
    let connect = div.querySelector("#worldMenu-connect");

    html.appendChild(save);
    html.appendChild(load);
    html.appendChild(connect);

    worldMenu = html;
    worldMenuVisible = false;
    document.getElementById("hud").appendChild(worldMenu);
}

function toggleMenu(myAvatar) {
    if (worldMenuVisible) {
        worldMenu.classList.remove("menuVisible");
        worldMenuVisible = false;
        return;
    }

    if (worldMenu.lastChild.id === "worldMenu-forceStop") {
        worldMenu.lastChild.remove();
    }

    if (myAvatar.actor.service("PlayerManager").presentationMode) {
        let presentation = `
<div id="worldMenu-forceStop" class="menu-label menu-item">
    <span class="menu-label-text">Stop Presentation</span>
</div>`.trim();

        let div = document.createElement("div");
        div.innerHTML = presentation;
        worldMenu.appendChild(div.firstChild);
    }

    let div;

    div = worldMenu.querySelector("#worldMenu-qr");
    div.onclick = (evt) => {
        evt.preventDefault();
        evt.stopPropagation();

        if (evt.shiftKey || isMobile) {
            switchQRView(myAvatar);
            return;
        }
        qrPressed(myAvatar, window.location);
    }

    div = worldMenu.querySelector("#worldMenu-save");
    div.onclick = (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        savePressed(myAvatar);
    }

    div = worldMenu.querySelector("#worldMenu-load");
    div.onclick = (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        loadPressed(myAvatar);
    }

    div = worldMenu.querySelector("#worldMenu-connect");
    div.onclick = () => connectPressed(myAvatar);

    div = worldMenu.querySelector("#worldMenu-forceStop");
    if (div) {
        div.onclick = () => forceStop(myAvatar);
    }

    worldMenuVisible = true;
    worldMenu.classList.add("menuVisible");
    return worldMenu;
}

function setupWorldMenuButton(myAvatar, App, sessionId) {
    if (!worldMenu) {
        let ownerDiv = document.createElement("div");
        let statsDiv = document.createElement("div");
        statsDiv.id = "statsDiv";
        let qrDiv = document.createElement("div");
        qrDiv.id = "qrDiv";

        statsDiv.classList.add("statsHidden");

        ownerDiv.appendChild(qrDiv);
        ownerDiv.appendChild(statsDiv);

        App.root = ownerDiv;
        App.badge = false;
        App.qrcode = qrDiv;
        App.stats = statsDiv;
        App.makeSessionWidgets(sessionId);
        qrDiv.onclick = null;

        initWorldMenu(ownerDiv);
    }
    let worldMenuButton = document.querySelector("#worldMenuBttn");
    worldMenuButton.onclick = () => toggleMenu(myAvatar);
}


/***/ }),

/***/ "./three/threeLibsLoader.js":
/*!**********************************!*\
  !*** ./three/threeLibsLoader.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadThreeLibs": () => (/* binding */ loadThreeLibs)
/* harmony export */ });
function loadThreeLibs(THREE) {
    window.THREE = THREE;
    return __webpack_require__.e(/*! import() */ "three_bundledThreeLibs_js").then(__webpack_require__.t.bind(__webpack_require__, /*! ./bundledThreeLibs.js */ "./three/bundledThreeLibs.js", 23));
}



/***/ })

}]);